{
  "name": "xbytechat-api/Features",
  "part": 4,
  "of": 4,
  "generatedAt": "2025-10-02 10:25:32 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingService.cs",
      "sha256": "90d3f4b3c6a0d5d10d83300d0c3ed58fc81149c2dec145768cfafe2886dccb0b",
      "language": "csharp",
      "size": 9142,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Shared.TrackingUtils;\nusing Serilog;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.CRM.Dtos;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing AutoMapper;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class TrackingService : ITrackingService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMapper _mapper;\n        public TrackingService(AppDbContext context, IMapper mapper)\n        {\n            _context = context;\n            _mapper = mapper;\n        }\n\n\n        public async Task<ResponseResult> LogCTAClickWithEnrichmentAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                // üß† 1. Try enrich from MessageLog (if msg ID provided)\n                if (!string.IsNullOrEmpty(dto.MessageId))\n                {\n                    var messageLog = await _context.MessageLogs\n                        .FirstOrDefaultAsync(m => m.MessageId == dto.MessageId || m.Id.ToString() == dto.MessageId);\n\n                    if (messageLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty ? messageLog.BusinessId : dto.BusinessId;\n                        dto.ContactId ??= messageLog.ContactId;\n                        dto.CampaignId ??= messageLog.CampaignId;\n                        dto.MessageLogId ??= messageLog.Id;\n                    }\n                }\n\n                // üß© 2. Enrich from CampaignSendLog if sourceType = campaign\n                CampaignSendLog? sendLog = null;\n\n                if (dto.SourceType == \"campaign\")\n                {\n                    if (!string.IsNullOrEmpty(dto.MessageId))\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .FirstOrDefaultAsync(c => c.MessageId == dto.MessageId);\n                    }\n\n                    if (sendLog == null && dto.CampaignId != null)\n                    {\n                        sendLog = await _context.CampaignSendLogs\n                            .Include(c => c.Recipient)\n                            .Where(c => c.CampaignId == dto.CampaignId)\n                            .OrderByDescending(c => c.CreatedAt)\n                            .FirstOrDefaultAsync();\n                    }\n\n                    if (sendLog != null)\n                    {\n                        dto.BusinessId = dto.BusinessId == Guid.Empty\n                            ? sendLog.Recipient?.BusinessId ?? Guid.Empty\n                            : dto.BusinessId;\n\n                        dto.ContactId ??= sendLog.ContactId;\n                        dto.CampaignId ??= sendLog.CampaignId;\n                        dto.CampaignSendLogId ??= sendLog.Id;\n\n                        // ‚úÖ Update campaign send log click details\n                        sendLog.IsClicked = true;\n                        sendLog.ClickedAt = dto.ClickedAt ?? DateTime.UtcNow;\n                        sendLog.ClickType = dto.ButtonText;\n\n                        await _context.SaveChangesAsync();\n                    }\n                }\n\n                // ‚úÖ 3. Validate business context\n                if (dto.BusinessId == Guid.Empty)\n                {\n                    Log.Warning(\"‚ùå TrackingLog failed: No BusinessId available for click.\");\n                    return ResponseResult.ErrorInfo(\"Business context is missing.\");\n                }\n\n                // üíæ 4. Save tracking log (inline instead of separate method)\n                var trackingLog = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(trackingLog);\n                await _context.SaveChangesAsync();\n\n                // ‚úÖ Return the TrackingLog.Id in the response\n                return ResponseResult.SuccessInfo(\"CTA click tracked successfully.\", trackingLog.Id);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Exception during CTA tracking enrichment\");\n                return ResponseResult.ErrorInfo(\"Exception during tracking: \" + ex.Message);\n            }\n        }\n\n        public async Task LogCTAClickAsync(TrackingLogDto dto)\n        {\n            try\n            {\n                var log = new TrackingLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    ContactPhone = dto.ContactPhone,\n                    SourceType = dto.SourceType,\n                    SourceId = dto.SourceId,\n                    ButtonText = dto.ButtonText,\n                    CTAType = dto.CTAType,\n                    MessageId = dto.MessageId,\n                    TemplateId = dto.TemplateId,\n                    MessageLogId = dto.MessageLogId,\n                    ClickedVia = dto.ClickedVia ?? \"web\",\n                    Referrer = dto.Referrer,\n                    ClickedAt = dto.ClickedAt ?? DateTime.UtcNow,\n                    IPAddress = dto.IPAddress,\n                    DeviceType = dto.DeviceType,\n                    Browser = dto.Browser,\n                    Country = dto.Country,\n                    City = dto.City,\n                    FollowUpSent = false,\n                    LastInteractionType = \"Clicked\",\n                    SessionId = Guid.TryParse(dto.SessionId, out var sid) ? sid : (Guid?)null,\n                    ThreadId = Guid.TryParse(dto.ThreadId, out var tid) ? tid : (Guid?)null,\n                    CampaignId = dto.CampaignId,\n                    CampaignSendLogId = dto.CampaignSendLogId\n                };\n\n                await _context.TrackingLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to log CTA click\");\n            }\n        }\n        public async Task<TrackingLogDetailsDto?> GetLogDetailsAsync(Guid logId)\n        {\n            var tracking = await _context.TrackingLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(x => x.Id == logId);\n\n            if (tracking == null)\n                return null;\n\n            var contact = tracking.ContactId != null\n                ? await _context.Contacts.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.ContactId)\n                : null;\n\n            var campaign = tracking.CampaignId != null\n                ? await _context.Campaigns.AsNoTracking().FirstOrDefaultAsync(c => c.Id == tracking.CampaignId)\n                : null;\n\n            var messageLog = tracking.MessageLogId != null\n                ? await _context.MessageLogs.AsNoTracking().FirstOrDefaultAsync(m => m.Id == tracking.MessageLogId)\n                : null;\n\n            return new TrackingLogDetailsDto\n            {\n                Tracking = _mapper.Map<TrackingLogDto>(tracking),\n                Contact = contact != null ? _mapper.Map<ContactDto>(contact) : null,\n                Campaign = campaign != null ? _mapper.Map<CampaignDto>(campaign) : null,\n                MessageLog = messageLog != null ? _mapper.Map<MessageLogDto>(messageLog) : null\n            };\n        }\n        public async Task<List<TrackingLog>> GetFlowClickLogsAsync(Guid businessId)\n        {\n            return await _context.TrackingLogs\n                .Where(x => x.BusinessId == businessId && x.SourceType == \"cta-flow\")\n                .OrderByDescending(x => x.ClickedAt)\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/TrackingToken.cs",
      "sha256": "b5250fc25e3e0ca598d78eba428d651a345550debbc5696ceb32b55ce684019e",
      "language": "csharp",
      "size": 809,
      "content": "using System.Text.Json;\nusing Microsoft.AspNetCore.WebUtilities;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public static class TrackingToken\n    {\n        public static string Create(object payload)\n        {\n            var json = JsonSerializer.Serialize(payload);\n            var bytes = System.Text.Encoding.UTF8.GetBytes(json);\n            return WebEncoders.Base64UrlEncode(bytes);\n        }\n\n        public static T Decode<T>(string token)\n        {\n            var bytes = WebEncoders.Base64UrlDecode(token);\n            var json = System.Text.Encoding.UTF8.GetString(bytes);\n            return JsonSerializer.Deserialize<T>(json)!;\n        }\n    }\n\n    // What we put inside the token:\n    public record ClickToken(Guid cid, int btnIndex, string btnTitle, string to, string phone);\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Tracking/Services/UrlBuilderService.cs",
      "sha256": "8f3156fd79a3ab196299a3f0ebb88e74ebe340db9a0d13bd47189ecc5996109d",
      "language": "csharp",
      "size": 4999,
      "content": "// Features/Tracking/Services/UrlBuilderService.cs\nusing System;\nusing Microsoft.Extensions.Options;\nusing xbytechat.api.Features.CampaignTracking.Config;\nusing xbytechat.api.Features.CampaignTracking.Services;\n\nnamespace xbytechat.api.Features.Tracking.Services\n{\n    public class UrlBuilderService : IUrlBuilderService\n    {\n        private readonly IClickTokenService _token;\n        private readonly TrackingOptions _opt;\n\n        // Allowed schemes for destination links\n        private static readonly string[] AllowedSchemes = new[] { \"http\", \"https\", \"tel\", \"wa\", \"whatsapp\" };\n\n        public UrlBuilderService(IClickTokenService token, IOptions<TrackingOptions> opt)\n        {\n            _token = token;\n            _opt = opt.Value;\n        }\n\n        /// <summary>\n        /// Normalizes destination and enforces an allowlist of schemes:\n        /// http, https, tel, wa, whatsapp.\n        /// Also supports shorthand WhatsApp hosts: wa.me/... and api.whatsapp.com/...\n        /// </summary>\n        private static string NormalizeAbsoluteUrlOrThrow(string input)\n        {\n            if (input is null) throw new ArgumentException(\"Destination URL is null.\", nameof(input));\n\n            // Trim and remove any non-printable/control whitespace characters\n            var s = input.Trim();\n            s = new string(Array.FindAll(s.ToCharArray(), c => !char.IsControl(c)));\n\n            if (s.Length == 0)\n                throw new ArgumentException(\"Destination URL is empty after trimming.\", nameof(input));\n\n            // Short-circuit for already tracked links, just in case this ever gets called that way\n            if (s.Contains(\"/r/\", StringComparison.Ordinal))\n                return s;\n\n            // Support common WhatsApp shorthands without scheme\n            // e.g. \"wa.me/9170...\" or \"api.whatsapp.com/send?phone=...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal))\n            {\n                if (s.StartsWith(\"wa.me/\", StringComparison.OrdinalIgnoreCase) ||\n                    s.StartsWith(\"api.whatsapp.com/\", StringComparison.OrdinalIgnoreCase))\n                {\n                    var guessWa = \"https://\" + s;\n                    if (Uri.TryCreate(guessWa, UriKind.Absolute, out var waAbs))\n                        return waAbs.AbsoluteUri;\n                }\n            }\n\n            // Accept absolute URIs with allowed schemes\n            if (Uri.TryCreate(s, UriKind.Absolute, out var abs))\n            {\n                var scheme = abs.Scheme ?? string.Empty;\n\n                // Allow only whitelisted schemes\n                var isAllowed = false;\n                for (int i = 0; i < AllowedSchemes.Length; i++)\n                {\n                    if (scheme.Equals(AllowedSchemes[i], StringComparison.OrdinalIgnoreCase))\n                    {\n                        isAllowed = true;\n                        break;\n                    }\n                }\n\n                if (!isAllowed)\n                    throw new ArgumentException(\n                        $\"Destination must use one of: http, https, tel, wa, whatsapp. Got '{scheme}:'\",\n                        nameof(input));\n\n                // http/https ‚Üí return canonical AbsoluteUri\n                if (scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase))\n                {\n                    return abs.AbsoluteUri;\n                }\n\n                // tel:/wa:/whatsapp://send ‚Üí return as provided (trimmed), do not modify\n                return s;\n            }\n\n            // Human input like \"www.example.com/...\" or \"example.com/...\"\n            if (!s.Contains(\"://\", StringComparison.Ordinal) && s.Contains('.', StringComparison.Ordinal))\n            {\n                var guess = \"https://\" + s;\n                if (Uri.TryCreate(guess, UriKind.Absolute, out var httpAbs))\n                    return httpAbs.AbsoluteUri;\n            }\n\n            throw new ArgumentException(\n                $\"Destination must be an absolute URL or allowed deep link (http, https, tel, wa, whatsapp). Got: '{input}'\",\n                nameof(input));\n        }\n\n        public string BuildTrackedButtonUrl(\n            Guid campaignSendLogId,\n            int buttonIndex,\n            string? buttonTitle,\n            string destinationUrlAbsolute)\n        {\n            var dest = NormalizeAbsoluteUrlOrThrow(destinationUrlAbsolute);\n\n            var now = DateTimeOffset.UtcNow.ToUnixTimeSeconds();\n            var exp = now + (long)_opt.TokenTtl.TotalSeconds;\n\n            var payload = new ClickTokenPayload(\n                cid: campaignSendLogId,\n                bi: buttonIndex,\n                bt: buttonTitle ?? string.Empty,\n                to: dest,\n                iat: now,\n                exp: exp\n            );\n\n            var token = _token.Create(payload);\n            return $\"{_opt.BaseUrl.TrimEnd('/')}/r/{token}\";\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookAutoCleanupWorker.cs",
      "sha256": "5149c73a4fbcb11d9e501321407b1c7ae7ee660b8f7d612eca136b528f0467f2",
      "language": "csharp",
      "size": 1212,
      "content": "using xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.BackgroundWorkers\n{\n    public class WebhookAutoCleanupWorker : BackgroundService\n    {\n        private readonly ILogger<WebhookAutoCleanupWorker> _logger;\n        private readonly IServiceProvider _services;\n\n        public WebhookAutoCleanupWorker(IServiceProvider services, ILogger<WebhookAutoCleanupWorker> logger)\n        {\n            _services = services;\n            _logger = logger;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                using var scope = _services.CreateScope();\n                var maintenanceService = scope.ServiceProvider.GetRequiredService<IMaintenanceService>();\n\n                if (await maintenanceService.IsAutoCleanupEnabledAsync())\n                {\n                    var count = await maintenanceService.RunCleanupAsync();\n                    _logger.LogInformation($\"üßπ Auto-cleaned {count} old webhook logs.\");\n                }\n\n                await Task.Delay(TimeSpan.FromHours(12), stoppingToken);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/BackgroundWorkers/WebhookQueueWorker.cs",
      "sha256": "4a0dbbf63a7e5e5dbdea08790538d449d81f91e4234da7a4b8acedf0ff744b25",
      "language": "csharp",
      "size": 3019,
      "content": "using System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.DependencyInjection;\nusing Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Services;\nusing xbytechat.api.Features.Webhooks.DTOs;\n\npublic class WebhookQueueWorker : BackgroundService\n{\n    private readonly IWebhookQueueService _queueService;\n    private readonly IServiceScopeFactory _scopeFactory;\n    private readonly ILogger<WebhookQueueWorker> _logger;\n\n    public WebhookQueueWorker(\n        IWebhookQueueService queueService,\n        IServiceScopeFactory scopeFactory,\n        ILogger<WebhookQueueWorker> logger)\n    {\n        _queueService = queueService;\n        _scopeFactory = scopeFactory;\n        _logger = logger;\n    }\n\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        _logger.LogInformation(\"üöÄ Webhook Queue Worker started.\");\n\n        while (!stoppingToken.IsCancellationRequested)\n        {\n            try\n            {\n                var payload = await _queueService.DequeueAsync(stoppingToken);\n                var clonedPayload = payload.Clone(); // ‚úÖ Avoid disposal issue\n\n                using var scope = _scopeFactory.CreateScope();\n\n                // üîÑ Resolve scoped dependencies\n                var dispatcher = scope.ServiceProvider.GetRequiredService<IWhatsAppWebhookDispatcher>();\n                var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                // üöÄ Dispatch\n                await dispatcher.DispatchAsync(clonedPayload);\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogInformation(\"üõë Graceful shutdown requested.\");\n                break;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Error while processing webhook payload.\");\n\n                try\n                {\n                    using var scope = _scopeFactory.CreateScope();\n                    var failureLogger = scope.ServiceProvider.GetRequiredService<IFailedWebhookLogService>();\n\n                    var fallback = new FailedWebhookLogDto\n                    {\n                        SourceModule = \"WebhookQueueWorker\",\n                        FailureType = \"DispatchError\",\n                        ErrorMessage = ex.Message,\n                       // RawJson = ex.Data[\"payload\"]?.ToString() ?? \"(unavailable)\",\n                        RawJson = ex.Data[\"payload\"]?.ToString() ?? \"{}\",\n                        CreatedAt = DateTime.UtcNow\n                    };\n\n                    await failureLogger.LogFailureAsync(fallback);\n                }\n                catch (Exception innerEx)\n                {\n                    _logger.LogError(innerEx, \"‚ö†Ô∏è Failed to log to FailedWebhookLogs table.\");\n                }\n            }\n        }\n\n        _logger.LogInformation(\"üõë Webhook Queue Worker stopped.\");\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/FailedWebhookLogsController.cs",
      "sha256": "f16ada5c238d2293688a73b0c4428da7f91567d1ca100da1809f0b95ea65c2fc",
      "language": "csharp",
      "size": 1018,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Tracking.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Tracking.Controllers\n{\n    [ApiController]\n    [Route(\"api/failed-webhooks\")]\n    public class FailedWebhookLogsController : ControllerBase\n    {\n        private readonly IFailedWebhookLogService _service;\n\n        public FailedWebhookLogsController(IFailedWebhookLogService service)\n        {\n            _service = service;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllAsync()\n        {\n            var logs = await _service.GetAllAsync();\n            return Ok(logs);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetById(Guid id)\n        {\n            var log = await _service.GetByIdAsync(id);\n            if (log == null)\n                return NotFound();\n\n            return Ok(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/MaintenanceController.cs",
      "sha256": "2936737cca434f20b27184b1885f94a5a90a6a94453b29dc0a597b264cc6325d",
      "language": "csharp",
      "size": 3242,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks\")]\n    public class MaintenanceController : ControllerBase\n    {\n        private readonly AppDbContext _context;\n        private readonly IMaintenanceService _maintenance;\n\n        public MaintenanceController(AppDbContext context, IMaintenanceService maintenance)\n        {\n            _context = context;\n            _maintenance = maintenance;\n        }\n\n        // ‚úÖ Injected Test Log for Dev Testing\n        [HttpPost(\"inject-test-log\")]\n        public async Task<IActionResult> InjectTestLog()\n        {\n            var testLog = new FailedWebhookLog\n            {\n                SourceModule = \"WebhookQueueWorker\",\n                FailureType = \"DispatchError\",\n                ErrorMessage = \"üß™ Simulated webhook dispatch failure for testing.\",\n                RawJson = \"{\\\"sample\\\":\\\"test_payload\\\",\\\"reason\\\":\\\"unit_test\\\"}\",\n                CreatedAt = DateTime.UtcNow\n            };\n\n            _context.FailedWebhookLogs.Add(testLog);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = \"‚úÖ Injected test log successfully.\" });\n        }\n\n        // ‚úÖ Manual Cleanup Trigger\n        [HttpPost(\"cleanup-now\")]\n        public async Task<IActionResult> CleanupNow()\n        {\n            var cutoff = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(x => x.CreatedAt < cutoff)\n                .ToListAsync();\n\n            if (!oldLogs.Any())\n                return Ok(new { message = \"‚úÖ No logs to delete.\" });\n\n            _context.FailedWebhookLogs.RemoveRange(oldLogs);\n            await _context.SaveChangesAsync();\n\n            return Ok(new { message = $\"‚úÖ Deleted {oldLogs.Count} old logs.\" });\n        }\n\n        // ‚úÖ Count of all failed logs\n        [HttpGet(\"failed/count\")]\n        public async Task<IActionResult> GetFailedCount()\n        {\n            var count = await _context.FailedWebhookLogs.CountAsync();\n            return Ok(count);\n        }\n\n        // ‚úÖ Cleanup Setting Status\n             [HttpGet(\"settings\")]\n        public async Task<IActionResult> GetCleanupStatus()\n        {\n            var enabled = await _maintenance.IsAutoCleanupEnabledAsync();\n            var lastRun = await _maintenance.GetLastCleanupTimeAsync();\n\n            return Ok(new\n            {\n                enabled,\n                lastCleanupAt = lastRun\n            });\n        }\n\n        // ‚úÖ Enable Auto Cleanup\n        [HttpPost(\"enable-cleanup\")]\n        public async Task<IActionResult> EnableCleanup()\n        {\n            await _maintenance.EnableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup enabled.\" });\n        }\n\n        // ‚úÖ Disable Auto Cleanup\n        [HttpPost(\"disable-cleanup\")]\n        public async Task<IActionResult> DisableCleanup()\n        {\n            await _maintenance.DisableAutoCleanupAsync();\n            return Ok(new { message = \"‚úÖ Auto-cleanup disabled.\" });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookCallback.cs",
      "sha256": "0353a97ed4f6c1349262de94a5e68f37d87955d3b6735e595aedc13f2b2f7365",
      "language": "csharp",
      "size": 2481,
      "content": "// üìÑ File: Features/Webhooks/Controllers/WebhookCallbackController.cs\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhookcallback\")]\n    public class WebhookCallbackController : ControllerBase\n    {\n        private readonly ILogger<WebhookCallbackController> _logger;\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookCallbackController(\n            ILogger<WebhookCallbackController> logger,\n            IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _queue = queue;\n        }\n\n        // ‚úÖ Single POST endpoint: Pinnacle (and others) send responses here\n        [HttpPost]\n        [Consumes(\"application/json\")]\n        [Produces(\"application/json\")]\n        public IActionResult Post([FromBody] JsonElement payload, CancellationToken ct)\n        {\n            if (!Request.HasJsonContentType())\n            {\n                return BadRequest(new { error = \"Content-Type must be application/json\" });\n            }\n\n            try\n            {\n                var raw = payload.GetRawText();\n                _logger.LogInformation(\"üì• Webhook received. bytes={Len}\", raw.Length);\n\n                // Clone JsonElement before queueing\n                _queue.Enqueue(payload.Clone());\n\n                // Return 200 OK so Pinnacle won‚Äôt retry unnecessarily\n                return Ok(new { received = true });\n            }\n            catch (OperationCanceledException)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Webhook processing cancelled by client.\");\n                return StatusCode(499);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue webhook payload.\");\n                // 500 lets BSP retry later\n                return StatusCode(500, new { error = \"webhook_enqueue_failed\" });\n            }\n        }\n    }\n\n    // Small helper for JSON content-type\n    internal static class HttpRequestContentTypeExtensions\n    {\n        public static bool HasJsonContentType(this HttpRequest request)\n        {\n            if (request?.ContentType is null) return false;\n            return request.ContentType.StartsWith(\"application/json\", StringComparison.OrdinalIgnoreCase);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WebhookTestController.cs",
      "sha256": "d3d3ac0e403d42baaa151d62e86135b71a0116ed7231d86c04b87bbd4ae6ac61",
      "language": "csharp",
      "size": 1569,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/test\")]\n    public class WebhookTestController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n\n        public WebhookTestController(IWebhookQueueService queue)\n        {\n            _queue = queue;\n        }\n\n        [HttpPost(\"simulate-failure\")]\n        public IActionResult SimulateWebhookFailure()\n        {\n            var fakePayload = new\n            {\n                entry = new[]\n                {\n                    new\n                    {\n                        changes = new[]\n                        {\n                            new\n                            {\n                                value = new\n                                {\n                                    // This will cause dispatcher to throw due to invalid structure\n                                    unexpected = \"üß™ Simulated bad structure\"\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n\n            var json = JsonSerializer.Serialize(fakePayload);\n            var element = JsonDocument.Parse(json).RootElement;\n\n            _queue.Enqueue(element);\n\n            return Ok(new\n            {\n                message = \"‚úÖ Test payload enqueued to simulate failure.\",\n                enqueued = true\n            });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Controllers/WhatsAppWebhookController.cs",
      "sha256": "d25c1bf6870c1712f3270bf8e478e741c09e7d32497bb0f3e64885e8e5c6c7ec",
      "language": "csharp",
      "size": 2801,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp\")]\n    public class WhatsAppWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppWebhookController> _logger;\n        private readonly IConfiguration _config;\n        private readonly AppDbContext _context;\n        private readonly IWhatsAppWebhookService _webhookService;\n        private readonly IWebhookQueueService _queue;\n            public WhatsAppWebhookController(ILogger<WhatsAppWebhookController> logger,\n            IConfiguration config, AppDbContext context, IWhatsAppWebhookService webhookService, IWebhookQueueService queue)\n        {\n            _logger = logger;\n            _config = config;\n            _context = context;\n            _webhookService = webhookService;\n            _queue = queue;\n        }\n\n        // ‚úÖ Step 1: Meta verification endpoint (GET)\n        // Meta calls this to verify your webhook with hub.verify_token and expects you to return hub.challenge\n        [HttpGet]\n        public IActionResult VerifyWebhook(\n            [FromQuery(Name = \"hub.mode\")] string mode,\n            [FromQuery(Name = \"hub.verify_token\")] string token,\n            [FromQuery(Name = \"hub.challenge\")] string challenge)\n        {\n            // üîê Load your secret token from config or environment\n            var expectedToken = _config[\"WhatsApp:MetaToken\"];\n\n            if (mode == \"subscribe\" && token == expectedToken)\n            {\n                _logger.LogInformation(\"‚úÖ WhatsApp webhook verified successfully.\");\n                return Ok(challenge); // Meta expects a 200 OK with the challenge value\n            }\n\n            _logger.LogWarning(\"‚ùå WhatsApp webhook verification failed.\");\n            return Forbid(\"Token mismatch.\");\n        }\n\n     \n        [HttpPost]\n        public IActionResult HandleStatus([FromBody] JsonElement payload)\n        {\n            _logger.LogWarning(\"üì• Webhook received at controller:\\n\" + payload.ToString());\n\n            try\n            {\n                var cloned = payload.Clone(); // Important to clone here\n                _queue.Enqueue(cloned);\n\n                _logger.LogInformation(\"üì• Webhook payload enqueued successfully.\");\n                return Ok(new { received = true });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to enqueue WhatsApp webhook payload.\");\n                return StatusCode(500, new { error = \"Webhook queue failed\" });\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/IProviderDirectory.cs",
      "sha256": "9c5e07f8d7488efd67624a5d0b04fe85acf0163688ba6a704f500383e17210d4",
      "language": "csharp",
      "size": 995,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// Resolves BusinessId from provider-specific webhook identifiers.\n    /// </summary>\n    public interface IProviderDirectory\n    {\n        /// <param name=\"provider\">\"meta\" or \"pinnacle\" (lowercase preferred)</param>\n        /// <param name=\"phoneNumberId\">Meta/Pinnacle phone_number_id (strongest key)</param>\n        /// <param name=\"displayPhoneNumber\">Formatted sending number (e.g. \"+91XXXXXXXXXX\")</param>\n        /// <param name=\"wabaId\">WhatsApp Business Account ID (Meta)</param>\n        /// <param name=\"waId\">Optional WA ID (recipient); used only as a last-ditch heuristic</param>\n        Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Directory/ProviderDirectory.cs",
      "sha256": "3017c25bfb327e9028a837abd11188b17d3a1b2c4a768126a3f5eb2f040dfb59",
      "language": "csharp",
      "size": 5591,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Directory\n{\n    /// <summary>\n    /// EF-backed resolver for mapping provider identifiers to BusinessId, with a short cache.\n    /// </summary>\n    public class ProviderDirectory : IProviderDirectory\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<ProviderDirectory> _logger;\n        private readonly IMemoryCache _cache;\n\n        // reduce DB hits during webhook bursts\n        private static readonly TimeSpan CacheTtl = TimeSpan.FromMinutes(2);\n\n        public ProviderDirectory(AppDbContext db, ILogger<ProviderDirectory> logger, IMemoryCache cache)\n        {\n            _db = db;\n            _logger = logger;\n            _cache = cache;\n        }\n        private static string NormalizeProviderKey(string? raw)\n        {\n            var p = (raw ?? \"\").Trim().ToLowerInvariant();\n            return p switch\n            {\n                \"meta\" or \"meta-cloud\" or \"meta_cloud\" => \"meta_cloud\",\n                \"pinnacle\" => \"pinnacle\",\n                _ => p\n            };\n        }\n        public async Task<Guid?> ResolveBusinessIdAsync(\n            string? provider,\n            string? phoneNumberId,\n            string? displayPhoneNumber,\n            string? wabaId,\n            string? waId,\n            CancellationToken ct = default)\n        {\n            provider = NormalizeProviderKey(provider);\n            if (provider is \"meta\" or \"meta-cloud\") provider = \"meta_cloud\";\n            var cacheKey = $\"provdir:{provider}:{phoneNumberId}:{Normalize(displayPhoneNumber)}:{wabaId}\";\n            if (_cache.TryGetValue<Guid?>(cacheKey, out var cached))\n                return cached;\n\n            try\n            {\n                // ‚öì 1) Strongest match: provider + phone_number_id\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(phoneNumberId))\n                {\n                    var hit = await QueryByAsync(provider, phoneNumberId: phoneNumberId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 2) Next: provider + display_phone_number (normalized)\n                var normalizedDisplay = Normalize(displayPhoneNumber);\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(normalizedDisplay))\n                {\n                    var hit = await QueryByAsync(provider, displayPhoneNumber: normalizedDisplay, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                // ‚öì 3) Next: provider + wabaId (Meta)\n                if (!string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(wabaId))\n                {\n                    var hit = await QueryByAsync(provider, wabaId: wabaId, ct: ct);\n                    if (hit.HasValue) return CacheAndReturn(cacheKey, hit);\n                }\n\n                _logger.LogWarning(\n                    \"ProviderDirectory: No match for provider={Provider}, pnid={PhoneId}, disp={Display}, waba={Waba}\",\n                    provider, phoneNumberId, normalizedDisplay, wabaId\n                );\n                return CacheAndReturn(cacheKey, null);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"ProviderDirectory lookup failed.\");\n                return null;\n            }\n        }\n\n        private Guid? CacheAndReturn(string key, Guid? value)\n        {\n            _cache.Set(key, value, CacheTtl);\n            return value;\n        }\n\n        /// <summary>\n        /// Centralized query; now materializes candidates so Normalize() runs in-memory.\n        /// </summary>\n        private async Task<Guid?> QueryByAsync(\n            string provider,\n            string? phoneNumberId = null,\n            string? displayPhoneNumber = null,\n            string? wabaId = null,\n            CancellationToken ct = default)\n        {\n            // Only bring back what we need\n            var candidates = await _db.Set<WhatsAppSettingEntity>()\n                .AsNoTracking()\n                .Where(s => s.IsActive && s.Provider.ToLower() == provider)\n                .Select(s => new\n                {\n                    s.BusinessId,\n                    s.PhoneNumberId,\n                    s.WhatsAppBusinessNumber,\n                    s.WabaId\n                })\n                .ToListAsync(ct);\n\n            var normDisp = Normalize(displayPhoneNumber);\n\n            var hit = candidates.FirstOrDefault(s =>\n                (!string.IsNullOrEmpty(phoneNumberId) && s.PhoneNumberId == phoneNumberId) ||\n                (!string.IsNullOrEmpty(normDisp) && Normalize(s.WhatsAppBusinessNumber) == normDisp) ||\n                (!string.IsNullOrEmpty(wabaId) && s.WabaId == wabaId)\n            );\n\n            return hit?.BusinessId;\n        }\n\n        /// <summary>\n        /// Normalize phone formatting for robust comparisons.\n        /// </summary>\n        private static string? Normalize(string? phone)\n        {\n            if (string.IsNullOrWhiteSpace(phone)) return null;\n            var trimmed = phone.Trim();\n            var hasPlus = trimmed.StartsWith(\"+\");\n            var digits = new string(trimmed.Where(char.IsDigit).ToArray());\n            return hasPlus ? \"+\" + digits : digits;\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/DTOs/FailedWebhookLogDto.cs",
      "sha256": "6b14d817a983f7eb6626a70cc5aceedd50b164ce0e0282dcf155a1d6eb4b5a51",
      "language": "csharp",
      "size": 391,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.DTOs\n{\n    public class FailedWebhookLogDto\n    {\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; }\n        public string? FailureType { get; set; }\n        public string RawJson { get; set; } = string.Empty;\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/FailedWebhookLog.cs",
      "sha256": "549e466af9a80b67809dd9e25d2bf5b9b5991ce11754225bda46dac4df1e6da6",
      "language": "csharp",
      "size": 624,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Webhooks.Models\n{\n    public class FailedWebhookLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // üß† Debug Metadata\n        public string? ErrorMessage { get; set; }\n        public string? SourceModule { get; set; } // e.g., StatusProcessor, ClickProcessor\n        public string? FailureType { get; set; }  // e.g., JSON_PARSE_ERROR, DB_LOOKUP_FAILED\n\n        // üì¶ Raw Data Snapshot\n        public string RawJson { get; set; } = string.Empty;\n\n        // üïí Timeline\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Models/WebhookSettings.cs",
      "sha256": "c0eeeaa5e14f839b159f28d337450f595c7604994690c66fa7df82a56c6a3093",
      "language": "csharp",
      "size": 267,
      "content": "namespace xbytechat.api.Features.Webhooks.Models\n{\n    public class WebhookSettings\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public bool AutoCleanupEnabled { get; set; } = true;\n        public DateTime? LastCleanupAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Controllers/PinnacleWebhookController.cs",
      "sha256": "347412f9e7ce91e2e2852339fcb267da0f2153f38df4bfe8902a1f0b4a678ca8",
      "language": "csharp",
      "size": 1235,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System.Text.Json;\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Controllers\n{\n    [ApiController]\n    [Route(\"api/pinnacle/callback\")]\n    public sealed class PinnacleWebhookController : ControllerBase\n    {\n        private readonly IWebhookQueueService _queue;\n        private readonly IPinnacleToMetaAdapter _adapter;\n        private readonly ILogger<PinnacleWebhookController> _logger;\n\n        public PinnacleWebhookController(IWebhookQueueService queue, IPinnacleToMetaAdapter adapter, ILogger<PinnacleWebhookController> logger)\n        {\n            _queue = queue;\n            _adapter = adapter;\n            _logger = logger;\n        }\n\n        [HttpPost]\n        public IActionResult Post([FromBody] JsonElement body)\n        {\n            // Transform to the envelope WhatsAppWebhookDispatcher already expects\n            var metaEnvelope = _adapter.ToMetaEnvelope(body);\n            _queue.Enqueue(metaEnvelope);\n            _logger.LogInformation(\"üì® Pinnacle payload transformed and enqueued.\");\n            return Ok(new { received = true });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/IPinnacleToMetaAdapter.cs",
      "sha256": "7daf100e2d244ce83b0c3f91f8e006bce5359eddf8fe6f7cf2b046f9e071c17b",
      "language": "csharp",
      "size": 364,
      "content": "using System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters\n{\n    public interface IPinnacleToMetaAdapter\n    {\n        /// <summary>Converts provider-native payload to Meta-like envelope:\n        /// { \"entry\":[{ \"changes\":[{ \"value\": { ... } }]}] }</summary>\n        JsonElement ToMetaEnvelope(JsonElement pinnPayload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Pinnacle/Services/Adapters/PinnacleToMetaAdapter.cs",
      "sha256": "38b4863c5f4881b2196ae42ce86a47b8d92904a61daad400ab8d1e7e5db2d289",
      "language": "csharp",
      "size": 9751,
      "content": "using System.Buffers;\nusing System.Text.Json;\n\nnamespace xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\n\npublic sealed class PinnacleToMetaAdapter : IPinnacleToMetaAdapter\n{\n    public JsonElement ToMetaEnvelope(JsonElement p)\n    {\n        var buf = new ArrayBufferWriter<byte>();\n        using var w = new Utf8JsonWriter(buf);\n\n        w.WriteStartObject();\n        w.WritePropertyName(\"entry\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // entry[0]\n        w.WritePropertyName(\"changes\");\n        w.WriteStartArray();\n        w.WriteStartObject(); // changes[0]\n        w.WritePropertyName(\"value\");\n        w.WriteStartObject();\n\n        // NEW: try to emit metadata up-front (harmless if not found)\n        WriteMetadata(p, w);\n\n        if (!TryMapStatuses(p, w) && !TryMapMessages(p, w))\n        {\n            w.WritePropertyName(\"provider_raw\");\n            p.WriteTo(w);\n        }\n\n        w.WriteEndObject(); // value\n        w.WriteEndObject(); // change\n        w.WriteEndArray();  // changes\n        w.WriteEndObject(); // entry[0]\n        w.WriteEndArray();  // entry\n        w.WriteEndObject(); // root\n        w.Flush();\n\n        var ros = new ReadOnlySequence<byte>(buf.WrittenMemory);\n        using var doc = JsonDocument.Parse(ros);\n        return doc.RootElement.Clone();\n    }\n\n    // ---- NEW ----\n    // Best-effort extraction; tolerate any Pinnacle layout you have.\n    // We only write fields if we can resolve them.\n    private static void WriteMetadata(JsonElement p, Utf8JsonWriter w)\n    {\n        string? displayPhone = null;\n        string? phoneNumberId = null;\n        string? wabaId = null;\n\n        // common guesses; add/rename to match your Pinnacle payload\n        // 1) flat\n        if (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) displayPhone = d1.GetString();\n        if (p.TryGetProperty(\"phone_number_id\", out var pid1) && pid1.ValueKind == JsonValueKind.String) phoneNumberId = pid1.GetString();\n        if (p.TryGetProperty(\"waba_id\", out var wa1) && wa1.ValueKind == JsonValueKind.String) wabaId = wa1.GetString();\n\n        // 2) channel\n        if (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && ch.TryGetProperty(\"display_phone_number\", out var d2) && d2.ValueKind == JsonValueKind.String) displayPhone = d2.GetString();\n            if (displayPhone is null && ch.TryGetProperty(\"phone\", out var d3) && d3.ValueKind == JsonValueKind.String) displayPhone = d3.GetString();\n\n            if (phoneNumberId is null && ch.TryGetProperty(\"phone_number_id\", out var pid2) && pid2.ValueKind == JsonValueKind.String) phoneNumberId = pid2.GetString();\n            if (phoneNumberId is null && ch.TryGetProperty(\"id\", out var pid3) && pid3.ValueKind == JsonValueKind.String) phoneNumberId = pid3.GetString();\n\n            if (wabaId is null && ch.TryGetProperty(\"waba_id\", out var wa2) && wa2.ValueKind == JsonValueKind.String) wabaId = wa2.GetString();\n        }\n\n        // 3) meta-style wrapper\n        if (p.TryGetProperty(\"metadata\", out var meta) && meta.ValueKind == JsonValueKind.Object)\n        {\n            if (displayPhone is null && meta.TryGetProperty(\"display_phone_number\", out var d4) && d4.ValueKind == JsonValueKind.String) displayPhone = d4.GetString();\n            if (phoneNumberId is null && meta.TryGetProperty(\"phone_number_id\", out var pid4) && pid4.ValueKind == JsonValueKind.String) phoneNumberId = pid4.GetString();\n            if (wabaId is null && meta.TryGetProperty(\"waba_id\", out var wa3) && wa3.ValueKind == JsonValueKind.String) wabaId = wa3.GetString();\n        }\n\n        if (displayPhone is null && p.TryGetProperty(\"business\", out var biz) && biz.ValueKind == JsonValueKind.Object)\n        {\n            if (biz.TryGetProperty(\"phone\", out var d5) && d5.ValueKind == JsonValueKind.String) displayPhone = d5.GetString();\n            if (biz.TryGetProperty(\"phone_id\", out var pid5) && pid5.ValueKind == JsonValueKind.String) phoneNumberId = pid5.GetString();\n        }\n\n        // Only emit if we have at least one of them.\n        if (displayPhone is not null || phoneNumberId is not null || wabaId is not null)\n        {\n            w.WritePropertyName(\"metadata\");\n            w.WriteStartObject();\n            if (displayPhone is not null) w.WriteString(\"display_phone_number\", displayPhone);\n            if (phoneNumberId is not null) w.WriteString(\"phone_number_id\", phoneNumberId);\n            if (wabaId is not null) w.WriteString(\"waba_id\", wabaId);\n            w.WriteEndObject();\n        }\n    }\n    // ---- NEW END ----\n\n    private static bool TryMapStatuses(JsonElement p, Utf8JsonWriter w)\n    {\n        string? id = null, status = null;\n        long? ts = null;\n\n        if (p.TryGetProperty(\"messageId\", out var mid) && mid.ValueKind == JsonValueKind.String) id = mid.GetString();\n        if (p.TryGetProperty(\"id\", out var pid) && pid.ValueKind == JsonValueKind.String) id ??= pid.GetString();\n        if (p.TryGetProperty(\"status\", out var st) && st.ValueKind == JsonValueKind.String) status = st.GetString();\n\n        if (p.TryGetProperty(\"timestamp\", out var t))\n        {\n            if (t.ValueKind == JsonValueKind.Number) ts = t.GetInt64();\n            else if (t.ValueKind == JsonValueKind.String && long.TryParse(t.GetString(), out var n)) ts = n;\n        }\n\n        if (p.TryGetProperty(\"data\", out var d) && d.ValueKind == JsonValueKind.Object)\n        {\n            if (id is null && d.TryGetProperty(\"id\", out var did) && did.ValueKind == JsonValueKind.String) id = did.GetString();\n            if (status is null && d.TryGetProperty(\"status\", out var ds) && ds.ValueKind == JsonValueKind.String) status = ds.GetString();\n            if (ts is null && d.TryGetProperty(\"ts\", out var dts) && dts.ValueKind == JsonValueKind.Number) ts = dts.GetInt64();\n        }\n\n        if (id is null || status is null) return false;\n\n        w.WritePropertyName(\"statuses\");\n        w.WriteStartArray();\n        w.WriteStartObject();\n        w.WriteString(\"id\", id);\n        w.WriteString(\"status\", status);\n        if (ts.HasValue) w.WriteNumber(\"timestamp\", ts.Value);\n        w.WriteEndObject();\n        w.WriteEndArray();\n        return true;\n    }\n\n    \n    private static bool TryMapMessages(JsonElement p, Utf8JsonWriter w)\n    {\n        // { \"click\": { \"title\":\"Flow Test\", \"contextId\":\"wamid..\", \"from\":\"<biz_phone?>\" , \"user\":\"<customer_wa_id?>\" } }\n        if (p.TryGetProperty(\"click\", out var c) && c.ValueKind == JsonValueKind.Object)\n        {\n            var title = c.TryGetProperty(\"title\", out var t) ? t.GetString() : null;\n            var ctxId = c.TryGetProperty(\"contextId\", out var ctx) ? ctx.GetString() : null;\n\n            // customer who clicked\n            var customerFrom = c.TryGetProperty(\"user\", out var u) && u.ValueKind == JsonValueKind.String\n                ? u.GetString()\n                : (c.TryGetProperty(\"from\", out var f1) && f1.ValueKind == JsonValueKind.String ? f1.GetString() : null);\n\n            // **business** number that sent the message (Meta provides this as context.from)\n            var businessFrom =\n                (p.TryGetProperty(\"display_phone_number\", out var d1) && d1.ValueKind == JsonValueKind.String) ? d1.GetString() :\n                (p.TryGetProperty(\"channel\", out var ch) && ch.ValueKind == JsonValueKind.Object &&\n                 ch.TryGetProperty(\"phone\", out var d2) && d2.ValueKind == JsonValueKind.String) ? d2.GetString() :\n                (c.TryGetProperty(\"from\", out var f2) && f2.ValueKind == JsonValueKind.String ? f2.GetString() : null); // last resort\n\n            if (!string.IsNullOrWhiteSpace(title) && !string.IsNullOrWhiteSpace(ctxId))\n            {\n                w.WritePropertyName(\"messages\");\n                w.WriteStartArray();\n                w.WriteStartObject();\n                w.WriteString(\"type\", \"button\");\n                w.WriteString(\"from\", customerFrom ?? \"\");          // customer wa_id\n                w.WritePropertyName(\"button\");\n                w.WriteStartObject();\n                w.WriteString(\"text\", title!);\n                w.WriteEndObject();\n                w.WritePropertyName(\"context\");\n                w.WriteStartObject();\n                w.WriteString(\"id\", ctxId!);\n                if (!string.IsNullOrWhiteSpace(businessFrom))\n                    w.WriteString(\"from\", businessFrom!);           // **important for directory resolution**\n                w.WriteEndObject();\n                w.WriteEndObject();\n                w.WriteEndArray();\n                return true;\n            }\n        }\n\n        // { \"message\": { \"from\":\"<customer_wa_id>\", \"body\":\"hi\", \"type\":\"text\" }, \"channel\":{ \"phone\":\"<biz_phone>\" } }\n        if (p.TryGetProperty(\"message\", out var m) && m.ValueKind == JsonValueKind.Object)\n        {\n            var type = m.TryGetProperty(\"type\", out var tp) ? tp.GetString() : \"text\";\n            var from = m.TryGetProperty(\"from\", out var fr) ? fr.GetString() : \"\";\n\n            w.WritePropertyName(\"messages\");\n            w.WriteStartArray();\n            w.WriteStartObject();\n            w.WriteString(\"type\", type ?? \"text\");\n            w.WriteString(\"from\", from ?? \"\");\n            if ((type ?? \"text\") == \"text\")\n            {\n                var body = m.TryGetProperty(\"body\", out var bd) ? bd.GetString() : \"\";\n                w.WritePropertyName(\"text\");\n                w.WriteStartObject();\n                w.WriteString(\"body\", body ?? \"\");\n                w.WriteEndObject();\n            }\n            w.WriteEndObject();\n            w.WriteEndArray();\n            return true;\n        }\n\n        return false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogCleanupService.cs",
      "sha256": "68f4211391a24a94d3096c5cd71fbd6cbd0fed0211dd2929b92b1780ffd02fc8",
      "language": "csharp",
      "size": 2109,
      "content": "using Microsoft.Extensions.Hosting;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogCleanupService : BackgroundService\n    {\n        private readonly ILogger<FailedWebhookLogCleanupService> _logger;\n        private readonly IServiceProvider _services;\n        private readonly TimeSpan _interval = TimeSpan.FromHours(24); // daily run\n\n        public FailedWebhookLogCleanupService(ILogger<FailedWebhookLogCleanupService> logger, IServiceProvider services)\n        {\n            _logger = logger;\n            _services = services;\n        }\n\n        protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n        {\n            _logger.LogInformation(\"üßπ FailedWebhookLogCleanupService started.\");\n\n            while (!stoppingToken.IsCancellationRequested)\n            {\n                try\n                {\n                    using var scope = _services.CreateScope();\n                    var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n\n                    var cutoff = DateTime.UtcNow.AddDays(-7);\n                    var oldLogs = await db.FailedWebhookLogs\n                        .Where(x => x.CreatedAt < cutoff)\n                        .ToListAsync(stoppingToken);\n\n                    if (oldLogs.Any())\n                    {\n                        db.FailedWebhookLogs.RemoveRange(oldLogs);\n                        await db.SaveChangesAsync(stoppingToken);\n                        _logger.LogInformation(\"üßπ Deleted {Count} old failed webhook logs.\", oldLogs.Count);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"‚ùå Failed to clean up old webhook logs.\");\n                }\n\n                await Task.Delay(_interval, stoppingToken); // wait before next cleanup\n            }\n\n            _logger.LogInformation(\"üõë FailedWebhookLogCleanupService stopped.\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/FailedWebhookLogService.cs",
      "sha256": "3da6a5ad043773f7684b6ea9bc208441cbc36a7e53f01eacdd7c17848118c2af",
      "language": "csharp",
      "size": 1791,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class FailedWebhookLogService : IFailedWebhookLogService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<FailedWebhookLogService> _logger;\n\n        public FailedWebhookLogService(AppDbContext context, ILogger<FailedWebhookLogService> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task LogFailureAsync(FailedWebhookLogDto dto)\n        {\n            try\n            {\n                var log = new FailedWebhookLog\n                {\n                    ErrorMessage = dto.ErrorMessage,\n                    SourceModule = dto.SourceModule,\n                    FailureType = dto.FailureType,\n                    RawJson = dto.RawJson,\n                    CreatedAt = dto.CreatedAt\n                };\n\n                await _context.FailedWebhookLogs.AddAsync(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to persist webhook error log\");\n            }\n        }\n\n        public async Task<List<FailedWebhookLog>> GetAllAsync()\n        {\n            return await _context.FailedWebhookLogs\n                .OrderByDescending(x => x.CreatedAt)\n                .Take(100) // prevent DB overload\n                .ToListAsync();\n        }\n\n        public async Task<FailedWebhookLog?> GetByIdAsync(Guid id)\n        {\n            return await _context.FailedWebhookLogs.FindAsync(id);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IFailedWebhookLogService.cs",
      "sha256": "9366c7a087317049e7dee346a65f7ea81a76fe95fb98fe21ca457e0ed5db6a7c",
      "language": "csharp",
      "size": 396,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.Webhooks.DTOs;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IFailedWebhookLogService\n    {\n        Task LogFailureAsync(FailedWebhookLogDto dto);\n        Task<List<FailedWebhookLog>> GetAllAsync();\n        Task<FailedWebhookLog?> GetByIdAsync(Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IMaintenanceService.cs",
      "sha256": "76ef1df941e3536bbdce5e7213554b593e6431592ba6527334cf274c78357e26",
      "language": "csharp",
      "size": 323,
      "content": "namespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IMaintenanceService\n    {\n        Task<bool> IsAutoCleanupEnabledAsync();\n        Task EnableAutoCleanupAsync();\n        Task DisableAutoCleanupAsync();\n        Task<DateTime?> GetLastCleanupTimeAsync();\n        Task<int> RunCleanupAsync();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWebhookQueueService.cs",
      "sha256": "34e2e37f5ba5da57159852cecd9adde2f085640e1eb55a67116b5381ffa2e4b0",
      "language": "csharp",
      "size": 333,
      "content": "using System.Text.Json;\nusing xbytechat.api.Features.Tracking.DTOs;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWebhookQueueService\n    {\n        void Enqueue(JsonElement payload);\n        ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken);\n        int GetQueueLength();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookDispatcher.cs",
      "sha256": "844865d879bca5e59aa9d82cf7fabfb3ac241233391ca0544922a8902eed4a88",
      "language": "csharp",
      "size": 219,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookDispatcher\n    {\n        Task DispatchAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/IWhatsAppWebhookService.cs",
      "sha256": "ad5a6464f10897dfa75f4fdc1d7914492c73a593d01d71de18ed75df95de1836",
      "language": "csharp",
      "size": 293,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public interface IWhatsAppWebhookService\n    {\n        Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/MaintenanceService.cs",
      "sha256": "c8c7e803e34fb97d2edfbaaf824d332f8de8b1483327e364e63d68dd0082a20e",
      "language": "csharp",
      "size": 2411,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Webhooks.Models;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class MaintenanceService : IMaintenanceService\n    {\n        private readonly AppDbContext _context;\n\n        public MaintenanceService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<bool> IsAutoCleanupEnabledAsync()\n        {\n            var setting = await _context.WebhookSettings\n                .AsNoTracking()\n                .FirstOrDefaultAsync();\n\n            return setting?.AutoCleanupEnabled ?? false;\n        }\n\n        public async Task<DateTime?> GetLastCleanupTimeAsync()\n        {\n            return await _context.WebhookSettings\n                .AsNoTracking()\n                .Select(s => s.LastCleanupAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task EnableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = true;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task DisableAutoCleanupAsync()\n        {\n            var setting = await GetOrCreateAsync();\n            setting.AutoCleanupEnabled = false;\n            await _context.SaveChangesAsync();\n        }\n\n        public async Task<int> RunCleanupAsync()\n        {\n            var threshold = DateTime.UtcNow.AddDays(-7);\n            var oldLogs = await _context.FailedWebhookLogs\n                .Where(l => l.CreatedAt < threshold)\n                .ToListAsync();\n\n            if (oldLogs.Any())\n                _context.FailedWebhookLogs.RemoveRange(oldLogs);\n\n            var setting = await GetOrCreateAsync();\n            setting.LastCleanupAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return oldLogs.Count;\n        }\n\n        private async Task<WebhookSettings> GetOrCreateAsync()\n        {\n            var setting = await _context.WebhookSettings.FirstOrDefaultAsync();\n            if (setting == null)\n            {\n                setting = new WebhookSettings\n                {\n                    AutoCleanupEnabled = false,\n                    LastCleanupAt = null\n                };\n                _context.WebhookSettings.Add(setting);\n                await _context.SaveChangesAsync();\n            }\n            return setting;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ClickWebhookProcessor.cs",
      "sha256": "6b025b9d044452157f8b52ed8e8f22334fb8195987a5a048655e63c7b99a37ac",
      "language": "csharp",
      "size": 69988,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.IO.Pipelines;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing xbytechat.api;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.Contacts.Services;\nusing xbytechat.api.Features.CTAFlowBuilder.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Services;\nusing xbytechat.api.Features.CustomeApi.Models;\nusing xbytechat.api.Features.CustomeApi.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Tracking.DTOs;\nusing xbytechat.api.Features.Tracking.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared.TrackingUtils;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class ClickWebhookProcessor : IClickWebhookProcessor\n    {\n        private readonly ILogger<ClickWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n        private readonly ITrackingService _trackingService;\n        private readonly AppDbContext _context;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly ICTAFlowService _flowService;\n        private readonly IFlowRuntimeService _flowRuntime;\n        private readonly IContactProfileService _contactProfile;\n        private readonly ICtaJourneyPublisher _journeyPublisher;\n        public ClickWebhookProcessor(\n            ILogger<ClickWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver,\n            ITrackingService trackingService,\n            AppDbContext context,\n            IMessageEngineService messageEngine,\n            ICTAFlowService flowService,\n                        IFlowRuntimeService flowRuntime,\n                         IContactProfileService contactProfile,\n                          ICtaJourneyPublisher journeyPublisher\n            )\n        {\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n            _trackingService = trackingService;\n            _context = context;\n            _messageEngine = messageEngine;\n            _flowService = flowService;\n            _flowRuntime = flowRuntime;\n            _contactProfile = contactProfile;\n            _journeyPublisher = journeyPublisher;\n\n        }\n\n        // working code\n\n        public async Task ProcessClickAsync(JsonElement value)\n        {\n            _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n            try\n            {\n                if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n                    return;\n\n                static string Norm(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n                    return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n                                 .Trim()\n                                 .ToLowerInvariant();\n                }\n\n                // ‚úÖ Canonical phone: keep only digits (matches how we store & search contacts)\n                static string NormalizePhone(string? raw)\n                    => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n                // ‚úÖ contacts[0].profile.name (Meta shape)\n                static string? TryGetProfileName(JsonElement root)\n                {\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var profEl) &&\n                            profEl.ValueKind == JsonValueKind.Object &&\n                            profEl.TryGetProperty(\"name\", out var nameEl) &&\n                            nameEl.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nameEl.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                // >>> BEGIN MOD: helpers for CTAJourney key + botId extraction\n                static string ToKey(string? s)\n                {\n                    if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n                    var t = s.Trim().ToLowerInvariant();\n                    var sb = new System.Text.StringBuilder(t.Length);\n                    foreach (var ch in t)\n                    {\n                        if (char.IsLetterOrDigit(ch)) sb.Append(ch);\n                        else if (char.IsWhiteSpace(ch) || ch == '-' || ch == '_' || ch == '.') sb.Append('_');\n                    }\n                    var k = sb.ToString().Trim('_');\n                    return string.IsNullOrEmpty(k) ? \"unknown\" : k;\n                }\n\n                // read WA display number once (used as botId)\n                string botIdFromWebhook = \"\";\n                if (value.TryGetProperty(\"metadata\", out var md) &&\n                    md.TryGetProperty(\"display_phone_number\", out var dpnEl) &&\n                    dpnEl.ValueKind == JsonValueKind.String)\n                {\n                    botIdFromWebhook = NormalizePhone(dpnEl.GetString());\n                }\n                // >>> END MOD\n\n                foreach (var msg in messages.EnumerateArray())\n                {\n                    if (!msg.TryGetProperty(\"type\", out var typeProp))\n                        continue;\n\n                    var type = typeProp.GetString();\n\n                    string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                    string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n                        ? ctxId.GetString()\n                        : null;\n                    var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n                    var fromDigits = NormalizePhone(fromRaw);\n\n                    // ‚Äî‚Äî‚Äî button label extraction\n                    string? buttonText = null;\n                    if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n                    {\n                        buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n                                     btn.TryGetProperty(\"text\", out var textProp)\n                                       ? textProp.GetString()?.Trim()\n                                       : null;\n                    }\n                    else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n                             msg.TryGetProperty(\"interactive\", out var interactive))\n                    {\n                        if (interactive.TryGetProperty(\"type\", out var intrType) &&\n                            string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n                            interactive.TryGetProperty(\"button_reply\", out var br) &&\n                            br.TryGetProperty(\"title\", out var titleProp))\n                        {\n                            buttonText = titleProp.GetString()?.Trim();\n                        }\n                        else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n                                 lr.TryGetProperty(\"title\", out var listTitleProp))\n                        {\n                            buttonText = listTitleProp.GetString()?.Trim();\n                        }\n                    }\n\n                    if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n                    {\n                        _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}\", type);\n                        continue;\n                    }\n\n                    _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n                        fromDigits, clickMessageId, originalMessageId, buttonText);\n\n                    // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)\n                    var origin = await _context.MessageLogs\n                        .AsNoTracking()\n                        .FirstOrDefaultAsync(m =>\n                            m.MessageId == originalMessageId &&\n                            m.CTAFlowConfigId != null &&\n                            m.CTAFlowStepId != null);\n\n                    Guid businessId;\n                    Guid flowId;\n                    Guid stepId;\n                    string? bundleJson = null;\n                    int? flowVersion = null;\n\n                    Guid? campaignSendLogId = null; // link the click to the shown message\n                    Guid? runId = null;             // copy from parent CSL when available\n\n                    if (origin != null)\n                    {\n                        businessId = origin.BusinessId;\n                        flowId = origin.CTAFlowConfigId!.Value;\n                        stepId = origin.CTAFlowStepId!.Value;\n                        bundleJson = origin.ButtonBundleJson;\n                        flowVersion = origin.FlowVersion;\n\n                        // Map back to CSL via MessageLogId or WAMID and fetch RunId\n                        var cslInfo = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n                            .OrderByDescending(csl => csl.CreatedAt)\n                            .Select(csl => new { csl.Id, csl.RunId })\n                            .FirstOrDefaultAsync();\n\n                        campaignSendLogId = cslInfo?.Id;\n                        runId = cslInfo?.RunId;\n                    }\n                    else\n                    {\n                        // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n                        var sendLog = await _context.CampaignSendLogs\n                            .Include(sl => sl.Campaign)\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n                        if (sendLog == null)\n                        {\n                            _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        businessId = sendLog.BusinessId != Guid.Empty\n                            ? sendLog.BusinessId\n                            : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n                        if (businessId == Guid.Empty)\n                        {\n                            _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        campaignSendLogId = sendLog.Id;\n                        runId = sendLog.RunId;\n\n                        if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n                        {\n                            flowId = sendLog.CTAFlowConfigId.Value;\n                            stepId = sendLog.CTAFlowStepId.Value;\n                        }\n                        else if (sendLog.Campaign?.CTAFlowConfigId != null)\n                        {\n                            flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n                            var entry = await _context.CTAFlowSteps\n                                .Where(s => s.CTAFlowConfigId == flowId)\n                                .OrderBy(s => s.StepOrder)\n                                .Select(s => s.Id)\n                                .FirstOrDefaultAsync();\n\n                            if (entry == Guid.Empty)\n                            {\n                                _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n                                continue;\n                            }\n\n                            stepId = entry;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n                            continue;\n                        }\n\n                        bundleJson = sendLog.ButtonBundleJson;\n                    }\n\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step\n                    //    and make sure we look up by digits-only phone.\n                    // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n                    try\n                    {\n                        var profileName = TryGetProfileName(value);\n                        if (!string.IsNullOrWhiteSpace(profileName))\n                        {\n                            var now = DateTime.UtcNow;\n                            var contact = await _context.Contacts\n                                .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n                                                          (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n                            if (contact == null)\n                            {\n                                profileName = profileName ?? \"User\";\n                                contact = new Contact\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    PhoneNumber = fromDigits, // store canonical\n                                    Name = profileName,\n                                    ProfileName = profileName,\n                                    ProfileNameUpdatedAt = now,\n                                    CreatedAt = now,\n                                };\n                                _context.Contacts.Add(contact);\n                                await _context.SaveChangesAsync();\n                                _logger.LogInformation(\"üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n                                    profileName, fromDigits, businessId);\n                            }\n                            else\n                            {\n                                var changed = false;\n\n                                if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n                                {\n                                    contact.ProfileName = profileName;\n                                    contact.ProfileNameUpdatedAt = now;\n                                    changed = true;\n                                }\n\n                                if (string.IsNullOrWhiteSpace(contact.Name) ||\n                                    contact.Name == \"WhatsApp User\" ||\n                                    contact.Name == contact.PhoneNumber)\n                                {\n                                    if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n                                    {\n                                        contact.Name = profileName;\n                                        changed = true;\n                                    }\n                                }\n\n                                if (changed)\n                                {\n                                    contact.ProfileNameUpdatedAt = now;\n                                    await _context.SaveChangesAsync();\n                                    _logger.LogInformation(\"üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n                                        profileName, fromDigits, businessId);\n                                }\n                            }\n                        }\n                    }\n                    catch (Exception exProf)\n                    {\n                        _logger.LogWarning(exProf, \"‚ö†Ô∏è Failed to upsert WA profile name on click webhook.\");\n                    }\n\n                    // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n                    short? buttonIndex = null;\n                    FlowBtnBundleNode? hit = null;\n\n                    if (!string.IsNullOrWhiteSpace(bundleJson))\n                    {\n                        try\n                        {\n                            var nodes = System.Text.Json.JsonSerializer\n                                .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n                            hit = nodes.FirstOrDefault(n =>\n                                      string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                  ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n                            if (hit != null)\n                                buttonIndex = (short)hit.i;\n                        }\n                        catch (Exception ex)\n                        {\n                            _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n                        }\n                    }\n\n                    // ‚Äî‚Äî Fallback: find link by TEXT for this step\n                    FlowButtonLink? linkMatchedByText = null;\n                    if (buttonIndex == null)\n                    {\n                        var stepLinks = await _context.FlowButtonLinks\n                            .Where(l => l.CTAFlowStepId == stepId)\n                            .OrderBy(l => l.ButtonIndex)\n                            .ToListAsync();\n\n                        if (stepLinks.Count > 0)\n                        {\n                            linkMatchedByText = stepLinks.FirstOrDefault(l =>\n                                string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n                                ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n                            if (linkMatchedByText == null && stepLinks.Count == 1)\n                            {\n                                linkMatchedByText = stepLinks[0];\n                                _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n                            }\n\n                            if (linkMatchedByText != null)\n                            {\n                                buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n                                _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n                                    buttonIndex, flowId, stepId);\n                            }\n                        }\n                    }\n\n                    if (buttonIndex == null)\n                    {\n                        _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n                            originalMessageId, buttonText);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n                    var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n                               ?? linkMatchedByText;\n\n                    if (link == null)\n                    {\n                        _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n                            flowId, stepId, buttonIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî Resolve index + step name (for logging)\n                    short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n                    var stepName = await _context.CTAFlowSteps\n                        .Where(s => s.Id == stepId)\n                        .Select(s => s.TemplateToSend)\n                        .FirstOrDefaultAsync() ?? string.Empty;\n\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    // üìù WRITE CLICK LOG (always, even if terminal)\n                    // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n                    try\n                    {\n                        var clickExec = new FlowExecutionLog\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            FlowId = flowId,\n                            StepId = stepId,\n                            StepName = stepName,\n                            CampaignSendLogId = campaignSendLogId,\n                            MessageLogId = origin?.Id,\n                            ContactPhone = fromDigits,      // ‚úÖ digits-only, consistent\n                            ButtonIndex = resolvedIndex,\n                            TriggeredByButton = buttonText,\n                            TemplateName = null,\n                            TemplateType = \"quick_reply\",\n                            Success = true,\n                            ExecutedAt = DateTime.UtcNow,\n                            RequestId = Guid.NewGuid(),\n                            RunId = runId\n                        };\n\n                        _context.FlowExecutionLogs.Add(clickExec);\n                        await _context.SaveChangesAsync();\n                    }\n                    catch (Exception exSave)\n                    {\n                        _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n                    }\n                    // ===== RUNNING CTA JOURNEY STATE UPSERT (ONLY IF THIS BIZ IS CONFIGURED) =====\n                    string runningJourney;\n\n                    // Check once if this business is configured to receive CTAJourney.\n                    // If not, we won't touch ContactJourneyStates at all.\n                    bool shouldTrackState = await _context.CustomerWebhookConfigs\n                        .AsNoTracking()\n                        .AnyAsync(x => x.BusinessId == businessId && x.IsActive);\n\n                    if (shouldTrackState)\n                    {\n                        try\n                        {\n                            // load current state for (business, flow, phone)\n                            var state = await _context.ContactJourneyStates\n                                .SingleOrDefaultAsync(s =>\n                                    s.BusinessId == businessId &&\n                                    s.FlowId == flowId &&\n                                    s.ContactPhone == fromDigits);\n\n                            if (state == null)\n                            {\n                                // first click -> start with this button text (original casing)\n                                state = new ContactJourneyState\n                                {\n                                    Id = Guid.NewGuid(),\n                                    BusinessId = businessId,\n                                    FlowId = flowId,\n                                    ContactPhone = fromDigits,\n                                    JourneyText = buttonText ?? string.Empty,\n                                    ClickCount = 1,\n                                    LastButtonText = buttonText,\n                                    CreatedAt = DateTime.UtcNow,\n                                    UpdatedAt = DateTime.UtcNow\n                                };\n                                _context.ContactJourneyStates.Add(state);\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText;\n                                _logger.LogInformation(\"üßµ Journey init: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                            else\n                            {\n                                // append EVERY press (duplicates allowed), keep original casing\n                                var parts = (state.JourneyText ?? string.Empty)\n                                    .Split('/', StringSplitOptions.RemoveEmptyEntries | StringSplitOptions.TrimEntries)\n                                    .ToList();\n\n                                if (!string.IsNullOrWhiteSpace(buttonText))\n                                    parts.Add(buttonText!);\n\n                                // optional safety: cap growth\n                                const int cap = 15;\n                                if (parts.Count > cap) parts = parts.Skip(parts.Count - cap).ToList();\n\n                                state.JourneyText = string.Join('/', parts);\n                                state.ClickCount += 1;\n                                state.LastButtonText = buttonText;\n                                state.UpdatedAt = DateTime.UtcNow;\n\n                                await _context.SaveChangesAsync();\n                                runningJourney = state.JourneyText ?? string.Empty;\n\n                                _logger.LogInformation(\"üßµ Journey update: {Journey} (biz={Biz}, flow={Flow}, phone={Phone})\",\n                                    runningJourney, businessId, flowId, fromDigits);\n                            }\n                        }\n                        catch (Exception exState)\n                        {\n                            _logger.LogWarning(exState, \"‚ö†Ô∏è Failed to upsert ContactJourneyState.\");\n                            // fall back to this click only\n                            runningJourney = buttonText ?? string.Empty;\n                        }\n                    }\n                    else\n                    {\n                        // Business not configured ‚Üí do NOT save any state. Just use the current button for emit.\n                        runningJourney = buttonText ?? string.Empty;\n                    }\n                    // ===== END RUNNING CTA JOURNEY STATE UPSERT =====\n\n\n                    // ===== CTAJourney EMIT (running journey) =====\n                    try\n                    {\n                        // contact (for userName / userPhone)\n                        var contact = await _context.Contacts\n                            .AsNoTracking()\n                            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n                        // prefer PhoneNumberId (botId) from the originating send; otherwise pick any active one\n                        string? phoneNumberId = null;\n                        if (campaignSendLogId.HasValue)\n                        {\n                            phoneNumberId = await _context.CampaignSendLogs\n                                .AsNoTracking()\n                                .Where(s => s.Id == campaignSendLogId.Value)\n                                .Select(s => s.Campaign.PhoneNumberId)\n                                .FirstOrDefaultAsync();\n                        }\n                        if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n                        {\n                            phoneNumberId = await _context.Campaigns\n                                .AsNoTracking()\n                                .Where(c => c.Id == origin.CampaignId.Value)\n                                .Select(c => c.PhoneNumberId)\n                                .FirstOrDefaultAsync();\n                        }\n\n                        //if (string.IsNullOrWhiteSpace(phoneNumberId))\n                        //{\n                        //    phoneNumberId = await _context.WhatsAppSettings\n                        //        .AsNoTracking()\n                        //        .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n                        //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                        //        .Select(s => s.PhoneNumberId)\n                        //        .FirstOrDefaultAsync();\n                        //}\n                        // 2) Map PhoneNumberId -> WhatsAppBusinessNumber\n                        string? botWaNumber = null;\n                        if (!string.IsNullOrWhiteSpace(phoneNumberId))\n                        {\n                            botWaNumber = await _context.WhatsAppPhoneNumbers\n                                .AsNoTracking()\n                                .Where(n => n.BusinessId == businessId && n.PhoneNumberId == phoneNumberId)\n                                .Select(n => n.WhatsAppBusinessNumber)\n                                .FirstOrDefaultAsync();\n                        }\n                        // business WA display number (fallback botId if no PhoneNumberId)\n                        var displayProfilename = await _context.WhatsAppSettings\n                            .AsNoTracking()\n                            .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n                            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                            .Select(s => s.WhatsAppBusinessNumber)\n                            .FirstOrDefaultAsync();\n\n                        // Build DTO and POST (CTAJourney = the running slash-joined string with original casing)\n                        var dto = CtaJourneyMapper.Build(\n                            journeyKey: runningJourney,                    // <<‚Äî‚Äî use the running state\n                            contact: contact,\n                            profileName: contact?.ProfileName ?? contact?.Name,\n                            userId: null,\n                            phoneNumberId: botWaNumber,                  // preferred botId\n                            businessDisplayPhone: displayProfilename,               // fallback botId if above missing\n                            categoryBrowsed: null,\n                            productBrowsed: null\n                        );\n\n                        await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n                        _logger.LogInformation(\"üì§ CTAJourney posted (running): {Journey} (biz={Biz}, phone={Phone})\",\n                            dto.CTAJourney, businessId, dto.userPhone);\n                    }\n                    catch (Exception ex)\n                    {\n                        _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n                    }\n                    // ===== end CTAJourney EMIT =====\n\n\n                    // ===== CTAJourney EMIT (button name) =====\n                    //try\n                    //{\n                    //    CTAJourney must be the button name now\n                    //   var journeyKey = ToKey(buttonText);\n                    //    var journeyKey = buttonText?.Trim();\n                    //    contact(for userName / userPhone)\n                    //        var contact = await _context.Contacts\n                    //            .AsNoTracking()\n                    //            .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n                    //    prefer PhoneNumberId(botId) from the originating send; otherwise pick any active one\n                    //    string? phoneNumberId = null;\n                    //    if (campaignSendLogId.HasValue)\n                    //    {\n                    //        phoneNumberId = await _context.CampaignSendLogs\n                    //            .AsNoTracking()\n                    //            .Where(s => s.Id == campaignSendLogId.Value)\n                    //            .Select(s => s.Campaign.PhoneNumberId)\n                    //            .FirstOrDefaultAsync();\n                    //    }\n                    //    if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n                    //    {\n                    //        phoneNumberId = await _context.Campaigns\n                    //            .AsNoTracking()\n                    //            .Where(c => c.Id == origin.CampaignId.Value)\n                    //            .Select(c => c.PhoneNumberId)\n                    //            .FirstOrDefaultAsync();\n                    //    }\n                    //    if (string.IsNullOrWhiteSpace(phoneNumberId))\n                    //    {\n                    //        phoneNumberId = await _context.WhatsAppSettings\n                    //            .AsNoTracking()\n                    //            .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n                    //            .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    //            .Select(s => s.PhoneNumberId)\n                    //            .FirstOrDefaultAsync();\n                    //    }\n\n                    //    business WA display number(fallback botId if no PhoneNumberId)\n                    //    var displayWa = await _context.WhatsAppSettings\n                    //        .AsNoTracking()\n                    //        .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n                    //        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n                    //        .Select(s => s.WhatsAppBusinessNumber)\n                    //        .FirstOrDefaultAsync();\n\n                    //    build DTO and POST(maps to: userName / profileName, userPhone, botId, CTAJourney)\n                    //    var dto = CtaJourneyMapper.Build(\n                    //        journeyKey: journeyKey,                         // <<‚Äî‚Äî button name\n                    //        contact: contact,\n                    //        profileName: contact?.ProfileName ?? contact?.Name,\n                    //        userId: null,                                   // we don't have external user id\n                    //        phoneNumberId: phoneNumberId,                   // preferred botId\n                    //        businessDisplayPhone: displayWa,                // fallback botId if above missing\n                    //        categoryBrowsed: null,\n                    //        productBrowsed: null\n                    //    );\n\n                    //    await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n                    //    _logger.LogInformation(\"üì§ CTAJourney posted (button): {Journey} (biz={Biz}, phone={Phone})\",\n                    //        dto.CTAJourney, businessId, dto.userPhone);\n                    //}\n                    //catch (Exception ex)\n                    //{\n                    //    _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n                    //}\n\n\n\n\n\n                    // ‚Äî‚Äî If terminal/URL button: already logged the click\n                    if (link.NextStepId == null)\n                    {\n                        _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n                            flowId, stepId, resolvedIndex, link.ButtonText);\n                        continue;\n                    }\n\n                    if (_flowRuntime == null)\n                    {\n                        _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n                        continue;\n                    }\n\n                    // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA)\n                    string? providerFromCampaign = null;\n                    string? phoneNumberIdFromCampaign = null;\n\n                    if (campaignSendLogId.HasValue)\n                    {\n                        var originSend = await _context.CampaignSendLogs\n                            .AsNoTracking()\n                            .Include(s => s.Campaign)\n                            .Where(s => s.Id == campaignSendLogId.Value)\n                            .Select(s => new\n                            {\n                                s.Campaign.Provider,\n                                s.Campaign.PhoneNumberId\n                            })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originSend?.Provider;\n                        phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n                    }\n                    else if (origin != null && origin.CampaignId.HasValue)\n                    {\n                        var originCamp = await _context.Campaigns\n                            .AsNoTracking()\n                            .Where(c => c.Id == origin.CampaignId.Value)\n                            .Select(c => new { c.Provider, c.PhoneNumberId })\n                            .FirstOrDefaultAsync();\n\n                        providerFromCampaign = originCamp?.Provider;\n                        phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n                    }\n\n                    // ‚Äî‚Äî Execute next (carry sender forward)\n                    var ctxObj = new NextStepContext\n                    {\n                        BusinessId = businessId,\n                        FlowId = flowId,\n                        Version = flowVersion ?? 1,\n                        SourceStepId = stepId,\n                        TargetStepId = link.NextStepId!.Value,\n                        ButtonIndex = resolvedIndex,\n                        MessageLogId = origin?.Id ?? Guid.Empty,\n                        ContactPhone = fromDigits,     // ‚úÖ digits-only, so runtime finds the Contact\n                        RequestId = Guid.NewGuid(),\n                        ClickedButton = link,\n\n                        // üß∑ Sender from campaign so runtime won‚Äôt guess or fail with ‚ÄúMissing PhoneNumberId‚Äù\n                        Provider = providerFromCampaign,\n                        PhoneNumberId = phoneNumberIdFromCampaign,\n                        AlwaysSend = true // üî• force runtime to send even if it‚Äôs a loopback/same step\n                    };\n\n                    try\n                    {\n                        var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n                        if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n                        {\n                            _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n                        }\n                    }\n                    catch (Exception exRun)\n                    {\n                        _logger.LogError(exRun,\n                            \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n                            ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n            }\n        }\n\n\n        //public async Task ProcessClickAsync(JsonElement value)\n        //{\n        //    _logger.LogWarning(\"üì• [ENTERED CLICK PROCESSOR]\");\n\n        //    try\n        //    {\n        //        if (!value.TryGetProperty(\"messages\", out var messages) || messages.GetArrayLength() == 0)\n        //            return;\n\n        //        static string Norm(string? s)\n        //        {\n        //            if (string.IsNullOrWhiteSpace(s)) return string.Empty;\n        //            return string.Join(' ', s.Split(new[] { ' ', '\\t', '\\r', '\\n' }, StringSplitOptions.RemoveEmptyEntries))\n        //                         .Trim()\n        //                         .ToLowerInvariant();\n        //        }\n\n        //        // ‚úÖ Canonical phone: keep only digits (matches how we store & search contacts)\n        //        static string NormalizePhone(string? raw)\n        //            => new string((raw ?? string.Empty).Where(char.IsDigit).ToArray());\n\n        //        // ‚úÖ contacts[0].profile.name (Meta shape)\n        //        static string? TryGetProfileName(JsonElement root)\n        //        {\n        //            if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n        //                contactsEl.ValueKind == JsonValueKind.Array &&\n        //                contactsEl.GetArrayLength() > 0)\n        //            {\n        //                var c0 = contactsEl[0];\n        //                if (c0.TryGetProperty(\"profile\", out var profEl) &&\n        //                    profEl.ValueKind == JsonValueKind.Object &&\n        //                    profEl.TryGetProperty(\"name\", out var nameEl) &&\n        //                    nameEl.ValueKind == JsonValueKind.String)\n        //                {\n        //                    var n = nameEl.GetString();\n        //                    return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n        //                }\n        //            }\n        //            return null;\n        //        }\n\n        //        foreach (var msg in messages.EnumerateArray())\n        //        {\n        //            if (!msg.TryGetProperty(\"type\", out var typeProp))\n        //                continue;\n\n        //            var type = typeProp.GetString();\n\n        //            string? clickMessageId = msg.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n        //            string? originalMessageId = msg.TryGetProperty(\"context\", out var ctx) && ctx.TryGetProperty(\"id\", out var ctxId)\n        //                ? ctxId.GetString()\n        //                : null;\n        //            var fromRaw = msg.TryGetProperty(\"from\", out var fromProp) ? (fromProp.GetString() ?? \"\") : \"\";\n        //            var fromDigits = NormalizePhone(fromRaw);\n\n        //            // ‚Äî‚Äî‚Äî button label extraction\n        //            string? buttonText = null;\n        //            if (string.Equals(type, \"button\", StringComparison.OrdinalIgnoreCase))\n        //            {\n        //                buttonText = msg.TryGetProperty(\"button\", out var btn) &&\n        //                             btn.TryGetProperty(\"text\", out var textProp)\n        //                               ? textProp.GetString()?.Trim()\n        //                               : null;\n        //            }\n        //            else if (string.Equals(type, \"interactive\", StringComparison.OrdinalIgnoreCase) &&\n        //                     msg.TryGetProperty(\"interactive\", out var interactive))\n        //            {\n        //                if (interactive.TryGetProperty(\"type\", out var intrType) &&\n        //                    string.Equals(intrType.GetString(), \"button_reply\", StringComparison.OrdinalIgnoreCase) &&\n        //                    interactive.TryGetProperty(\"button_reply\", out var br) &&\n        //                    br.TryGetProperty(\"title\", out var titleProp))\n        //                {\n        //                    buttonText = titleProp.GetString()?.Trim();\n        //                }\n        //                else if (interactive.TryGetProperty(\"list_reply\", out var lr) &&\n        //                         lr.TryGetProperty(\"title\", out var listTitleProp))\n        //                {\n        //                    buttonText = listTitleProp.GetString()?.Trim();\n        //                }\n        //            }\n\n        //            if (string.IsNullOrWhiteSpace(buttonText) || string.IsNullOrWhiteSpace(originalMessageId))\n        //            {\n        //                _logger.LogDebug(\"‚ÑπÔ∏è Not a recognized click or missing context.id. type={Type}\", type);\n        //                continue;\n        //            }\n\n        //            _logger.LogInformation(\"üñ±Ô∏è Button Click ‚Üí From: {From}, ClickId: {ClickId}, OrigMsgId: {OrigId}, Text: {Text}\",\n        //                fromDigits, clickMessageId, originalMessageId, buttonText);\n\n        //            // ‚Äî‚Äî Try 1: originating MessageLog (for flow-sent messages)\n        //            var origin = await _context.MessageLogs\n        //                .AsNoTracking()\n        //                .FirstOrDefaultAsync(m =>\n        //                    m.MessageId == originalMessageId &&\n        //                    m.CTAFlowConfigId != null &&\n        //                    m.CTAFlowStepId != null);\n\n        //            Guid businessId;\n        //            Guid flowId;\n        //            Guid stepId;\n        //            string? bundleJson = null;\n        //            int? flowVersion = null;\n\n        //            Guid? campaignSendLogId = null; // link the click to the shown message\n        //            Guid? runId = null;             // copy from parent CSL when available\n\n        //            if (origin != null)\n        //            {\n        //                businessId = origin.BusinessId;\n        //                flowId = origin.CTAFlowConfigId!.Value;\n        //                stepId = origin.CTAFlowStepId!.Value;\n        //                bundleJson = origin.ButtonBundleJson;\n        //                flowVersion = origin.FlowVersion;\n\n        //                // Map back to CSL via MessageLogId or WAMID and fetch RunId\n        //                var cslInfo = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Where(csl => (csl.MessageLogId == origin.Id) || (csl.MessageId == originalMessageId))\n        //                    .OrderByDescending(csl => csl.CreatedAt)\n        //                    .Select(csl => new { csl.Id, csl.RunId })\n        //                    .FirstOrDefaultAsync();\n\n        //                campaignSendLogId = cslInfo?.Id;\n        //                runId = cslInfo?.RunId;\n        //            }\n        //            else\n        //            {\n        //                // ‚Äî‚Äî Try 2: first campaign message (CampaignSendLogs)\n        //                var sendLog = await _context.CampaignSendLogs\n        //                    .Include(sl => sl.Campaign)\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(sl => sl.MessageId == originalMessageId);\n\n        //                if (sendLog == null)\n        //                {\n        //                    _logger.LogWarning(\"‚ùå No MessageLog or CampaignSendLog for original WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                businessId = sendLog.BusinessId != Guid.Empty\n        //                    ? sendLog.BusinessId\n        //                    : (sendLog.Campaign?.BusinessId ?? Guid.Empty);\n\n        //                if (businessId == Guid.Empty)\n        //                {\n        //                    _logger.LogWarning(\"‚ùå Could not resolve BusinessId for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                campaignSendLogId = sendLog.Id;\n        //                runId = sendLog.RunId;\n\n        //                if (sendLog.CTAFlowConfigId.HasValue && sendLog.CTAFlowStepId.HasValue)\n        //                {\n        //                    flowId = sendLog.CTAFlowConfigId.Value;\n        //                    stepId = sendLog.CTAFlowStepId.Value;\n        //                }\n        //                else if (sendLog.Campaign?.CTAFlowConfigId != null)\n        //                {\n        //                    flowId = sendLog.Campaign.CTAFlowConfigId.Value;\n\n        //                    var entry = await _context.CTAFlowSteps\n        //                        .Where(s => s.CTAFlowConfigId == flowId)\n        //                        .OrderBy(s => s.StepOrder)\n        //                        .Select(s => s.Id)\n        //                        .FirstOrDefaultAsync();\n\n        //                    if (entry == Guid.Empty)\n        //                    {\n        //                        _logger.LogWarning(\"‚ùå No entry step found for flow {Flow}\", flowId);\n        //                        continue;\n        //                    }\n\n        //                    stepId = entry;\n        //                }\n        //                else\n        //                {\n        //                    _logger.LogWarning(\"‚ùå No flow context on CampaignSendLog for WAMID {Orig}\", originalMessageId);\n        //                    continue;\n        //                }\n\n        //                bundleJson = sendLog.ButtonBundleJson;\n        //            }\n\n        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //            // ‚úÖ UPSERT PROFILE NAME (create-or-update) *before* next step\n        //            //    and make sure we look up by digits-only phone.\n        //            // ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n        //            try\n        //            {\n        //                var profileName = TryGetProfileName(value);\n        //                if (!string.IsNullOrWhiteSpace(profileName))\n        //                {\n        //                    var now = DateTime.UtcNow;\n        //                    var contact = await _context.Contacts\n        //                        .FirstOrDefaultAsync(c => c.BusinessId == businessId &&\n        //                                                  (c.PhoneNumber == fromDigits || c.PhoneNumber == fromRaw));\n\n        //                    if (contact == null)\n        //                    {\n        //                        profileName = profileName ?? \"User\";\n        //                        contact = new Contact\n        //                        {\n        //                            Id = Guid.NewGuid(),\n        //                            BusinessId = businessId,\n        //                            PhoneNumber = fromDigits, // store canonical\n        //                            Name = profileName,\n        //                            ProfileName = profileName,\n        //                            ProfileNameUpdatedAt = now,\n        //                            CreatedAt = now,\n\n        //                        };\n        //                        _context.Contacts.Add(contact);\n        //                        await _context.SaveChangesAsync();\n        //                        _logger.LogInformation(\"üë§ Created contact + stored WA profile '{Name}' for {Phone} (biz {Biz})\",\n        //                            profileName, fromDigits, businessId);\n        //                    }\n        //                    else\n        //                    {\n        //                        var changed = false;\n\n        //                        if (!string.Equals(contact.ProfileName, profileName, StringComparison.Ordinal))\n        //                        {\n        //                            contact.ProfileName = profileName;\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            changed = true;\n        //                        }\n\n        //                        if (string.IsNullOrWhiteSpace(contact.Name) ||\n        //                            contact.Name == \"WhatsApp User\" ||\n        //                            contact.Name == contact.PhoneNumber)\n        //                        {\n        //                            if (!string.Equals(contact.Name, profileName, StringComparison.Ordinal))\n        //                            {\n        //                                contact.Name = profileName;\n        //                                changed = true;\n        //                            }\n        //                        }\n\n        //                        if (changed)\n        //                        {\n        //                            contact.ProfileNameUpdatedAt = now;\n        //                            await _context.SaveChangesAsync();\n        //                            _logger.LogInformation(\"üë§ Updated WA profile name to '{Name}' for {Phone} (biz {Biz})\",\n        //                                profileName, fromDigits, businessId);\n        //                        }\n        //                    }\n        //                }\n        //            }\n        //            catch (Exception exProf)\n        //            {\n        //                _logger.LogWarning(exProf, \"‚ö†Ô∏è Failed to upsert WA profile name on click webhook.\");\n        //            }\n\n        //            // ‚Äî‚Äî Map clicked text -> button index via the shown bundle\n        //            short? buttonIndex = null;\n        //            FlowBtnBundleNode? hit = null;\n\n        //            if (!string.IsNullOrWhiteSpace(bundleJson))\n        //            {\n        //                try\n        //                {\n        //                    var nodes = System.Text.Json.JsonSerializer\n        //                        .Deserialize<List<FlowBtnBundleNode>>(bundleJson) ?? new();\n\n        //                    hit = nodes.FirstOrDefault(n =>\n        //                              string.Equals(n.t ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                          ?? nodes.FirstOrDefault(n => Norm(n.t) == Norm(buttonText));\n\n        //                    if (hit != null)\n        //                        buttonIndex = (short)hit.i;\n        //                }\n        //                catch (Exception ex)\n        //                {\n        //                    _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to parse ButtonBundleJson\");\n        //                }\n        //            }\n\n        //            // ‚Äî‚Äî Fallback: find link by TEXT for this step\n        //            FlowButtonLink? linkMatchedByText = null;\n        //            if (buttonIndex == null)\n        //            {\n        //                var stepLinks = await _context.FlowButtonLinks\n        //                    .Where(l => l.CTAFlowStepId == stepId)\n        //                    .OrderBy(l => l.ButtonIndex)\n        //                    .ToListAsync();\n\n        //                if (stepLinks.Count > 0)\n        //                {\n        //                    linkMatchedByText = stepLinks.FirstOrDefault(l =>\n        //                        string.Equals(l.ButtonText ?? \"\", buttonText, StringComparison.OrdinalIgnoreCase))\n        //                        ?? stepLinks.FirstOrDefault(l => Norm(l.ButtonText) == Norm(buttonText));\n\n        //                    if (linkMatchedByText == null && stepLinks.Count == 1)\n        //                    {\n        //                        linkMatchedByText = stepLinks[0];\n        //                        _logger.LogInformation(\"üü® Falling back to single available link for step {Step}\", stepId);\n        //                    }\n\n        //                    if (linkMatchedByText != null)\n        //                    {\n        //                        buttonIndex = (short?)linkMatchedByText.ButtonIndex;\n        //                        _logger.LogInformation(\"‚úÖ Mapped click by TEXT to index {Idx} (flow={Flow}, step={Step})\",\n        //                            buttonIndex, flowId, stepId);\n        //                    }\n        //                }\n        //            }\n\n        //            if (buttonIndex == null)\n        //            {\n        //                _logger.LogInformation(\"üü° Button text not found in bundle or flow links. Ref={Ref}, Text='{Text}'\",\n        //                    originalMessageId, buttonText);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî Prefer exact link by index; otherwise use the text-matched link\n        //            var link = await _flowService.GetLinkAsync(flowId, stepId, buttonIndex.Value)\n        //                       ?? linkMatchedByText;\n\n        //            if (link == null)\n        //            {\n        //                _logger.LogInformation(\"üü° No button link for (flow={Flow}, step={Step}, idx={Idx})\",\n        //                    flowId, stepId, buttonIndex);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî Resolve index + step name (for logging)\n        //            short resolvedIndex = buttonIndex ?? Convert.ToInt16(link.ButtonIndex);\n        //            var stepName = await _context.CTAFlowSteps\n        //                .Where(s => s.Id == stepId)\n        //                .Select(s => s.TemplateToSend)\n        //                .FirstOrDefaultAsync() ?? string.Empty;\n\n        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n        //            // üìù WRITE CLICK LOG (always, even if terminal)\n        //            // ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî\n        //            try\n        //            {\n        //                var clickExec = new FlowExecutionLog\n        //                {\n        //                    Id = Guid.NewGuid(),\n        //                    BusinessId = businessId,\n        //                    FlowId = flowId,\n        //                    StepId = stepId,\n        //                    StepName = stepName,\n        //                    CampaignSendLogId = campaignSendLogId,\n        //                    MessageLogId = origin?.Id,\n        //                    ContactPhone = fromDigits,      // ‚úÖ digits-only, consistent\n        //                    ButtonIndex = resolvedIndex,\n        //                    TriggeredByButton = buttonText,\n        //                    TemplateName = null,\n        //                    TemplateType = \"quick_reply\",\n        //                    Success = true,\n        //                    ExecutedAt = DateTime.UtcNow,\n        //                    RequestId = Guid.NewGuid(),\n        //                    RunId = runId\n        //                };\n\n        //                _context.FlowExecutionLogs.Add(clickExec);\n        //                await _context.SaveChangesAsync();\n\n\n        //            }\n        //            catch (Exception exSave)\n        //            {\n        //                _logger.LogWarning(exSave, \"‚ö†Ô∏è Failed to persist FlowExecutionLog (click). Continuing‚Ä¶\");\n        //            }\n        //            // ===== CTAJourney EMIT (inserted here) =====\n        //            try\n        //            {\n        //                // load current & next step names for readable journey key\n        //                var fromStepName = await _context.CTAFlowSteps\n        //                    .AsNoTracking()\n        //                    .Where(s => s.Id == stepId)\n        //                    .Select(s => s.TemplateToSend)\n        //                    .FirstOrDefaultAsync();\n\n        //                string? toStepName = null;\n        //                if (link.NextStepId.HasValue)\n        //                {\n        //                    toStepName = await _context.CTAFlowSteps\n        //                        .AsNoTracking()\n        //                        .Where(s => s.Id == link.NextStepId.Value)\n        //                        .Select(s => s.TemplateToSend)\n        //                        .FirstOrDefaultAsync();\n        //                }\n\n        //                var journeyKey = $\"{ToKey(fromStepName)}_to_{ToKey(toStepName)}\";\n\n        //                // contact (for userName / userPhone)\n        //                var contact = await _context.Contacts\n        //                    .AsNoTracking()\n        //                    .FirstOrDefaultAsync(c => c.BusinessId == businessId && c.PhoneNumber == fromDigits);\n\n        //                // prefer PhoneNumberId (botId) from the originating send; otherwise pick any active one\n        //                string? phoneNumberId = null;\n        //                if (campaignSendLogId.HasValue)\n        //                {\n        //                    phoneNumberId = await _context.CampaignSendLogs\n        //                        .AsNoTracking()\n        //                        .Where(s => s.Id == campaignSendLogId.Value)\n        //                        .Select(s => s.Campaign.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId) && origin?.CampaignId != null)\n        //                {\n        //                    phoneNumberId = await _context.Campaigns\n        //                        .AsNoTracking()\n        //                        .Where(c => c.Id == origin.CampaignId.Value)\n        //                        .Select(c => c.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n        //                if (string.IsNullOrWhiteSpace(phoneNumberId))\n        //                {\n        //                    phoneNumberId = await _context.WhatsAppSettings\n        //                        .AsNoTracking()\n        //                        .Where(s => s.BusinessId == businessId && s.IsActive && s.PhoneNumberId != null)\n        //                        .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                        .Select(s => s.PhoneNumberId)\n        //                        .FirstOrDefaultAsync();\n        //                }\n\n        //                // business WA display number (fallback botId if no PhoneNumberId)\n        //                var displayWa = await _context.WhatsAppSettings\n        //                    .AsNoTracking()\n        //                    .Where(s => s.BusinessId == businessId && s.IsActive && s.WhatsAppBusinessNumber != null)\n        //                    .OrderByDescending(s => s.UpdatedAt ?? s.CreatedAt)\n        //                    .Select(s => s.WhatsAppBusinessNumber)\n        //                    .FirstOrDefaultAsync();\n\n        //                // build DTO and POST (maps to: userName/profileName, userPhone, botId, CTAJourney)\n        //                var dto = CtaJourneyMapper.Build(\n        //                    journeyKey: journeyKey,\n        //                    contact: contact,\n        //                    profileName: contact?.ProfileName ?? contact?.Name,\n        //                    userId: null,                         // we don't have an external user id\n        //                    phoneNumberId: phoneNumberId,         // preferred botId\n        //                    businessDisplayPhone: displayWa,      // fallback botId if above missing\n        //                    categoryBrowsed: null,\n        //                    productBrowsed: null\n        //                );\n\n        //                await _journeyPublisher.PublishAsync(businessId, dto, CancellationToken.None);\n        //                _logger.LogInformation(\"üì§ CTAJourney posted: {Journey} (biz={Biz}, phone={Phone})\",\n        //                    dto.CTAJourney, businessId, dto.userPhone);\n        //            }\n        //            catch (Exception ex)\n        //            {\n        //                _logger.LogWarning(ex, \"‚ö†Ô∏è Failed to post CTAJourney (click). Continuing‚Ä¶\");\n        //            }\n        //            // ===== end CTAJourney EMIT =====\n\n        //            // ‚Äî‚Äî If terminal/URL button: already logged the click\n        //            if (link.NextStepId == null)\n        //            {\n        //                _logger.LogInformation(\"üîö Terminal/URL button: no NextStepId. flow={Flow}, step={Step}, idx={Idx}, text='{Text}'\",\n        //                    flowId, stepId, resolvedIndex, link.ButtonText);\n        //                continue;\n        //            }\n\n        //            if (_flowRuntime == null)\n        //            {\n        //                _logger.LogError(\"‚ùå _flowRuntime is null. Cannot execute next step. flow={Flow}, step={Step}, idx={Idx}\", flowId, stepId, resolvedIndex);\n        //                continue;\n        //            }\n\n        //            // ‚Äî‚Äî üîé Resolve sender from the originating campaign/send (use SAME WABA)\n        //            string? providerFromCampaign = null;\n        //            string? phoneNumberIdFromCampaign = null;\n\n        //            if (campaignSendLogId.HasValue)\n        //            {\n        //                var originSend = await _context.CampaignSendLogs\n        //                    .AsNoTracking()\n        //                    .Include(s => s.Campaign)\n        //                    .Where(s => s.Id == campaignSendLogId.Value)\n        //                    .Select(s => new\n        //                    {\n        //                        s.Campaign.Provider,\n        //                        s.Campaign.PhoneNumberId\n        //                    })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originSend?.Provider;\n        //                phoneNumberIdFromCampaign = originSend?.PhoneNumberId;\n        //            }\n        //            else if (origin != null && origin.CampaignId.HasValue)\n        //            {\n        //                var originCamp = await _context.Campaigns\n        //                    .AsNoTracking()\n        //                    .Where(c => c.Id == origin.CampaignId.Value)\n        //                    .Select(c => new { c.Provider, c.PhoneNumberId })\n        //                    .FirstOrDefaultAsync();\n\n        //                providerFromCampaign = originCamp?.Provider;\n        //                phoneNumberIdFromCampaign = originCamp?.PhoneNumberId;\n        //            }\n\n        //            // ‚Äî‚Äî Execute next (carry sender forward)\n        //            var ctxObj = new NextStepContext\n        //            {\n        //                BusinessId = businessId,\n        //                FlowId = flowId,\n        //                Version = flowVersion ?? 1,\n        //                SourceStepId = stepId,\n        //                TargetStepId = link.NextStepId!.Value,\n        //                ButtonIndex = resolvedIndex,\n        //                MessageLogId = origin?.Id ?? Guid.Empty,\n        //                ContactPhone = fromDigits,     // ‚úÖ digits-only, so runtime finds the Contact\n        //                RequestId = Guid.NewGuid(),\n        //                ClickedButton = link,\n\n        //                // üß∑ Sender from campaign so runtime won‚Äôt guess or fail with ‚ÄúMissing PhoneNumberId‚Äù\n        //                Provider = providerFromCampaign,\n        //                PhoneNumberId = phoneNumberIdFromCampaign,\n        //                AlwaysSend = true // üî• force runtime to send even if it‚Äôs a loopback/same step\n        //            };\n\n        //            try\n        //            {\n        //                var result = await _flowRuntime.ExecuteNextAsync(ctxObj);\n\n        //                if (result.Success && !string.IsNullOrWhiteSpace(result.RedirectUrl))\n        //                {\n        //                    _logger.LogInformation(\"üîó URL button redirect (logical): {Url}\", result.RedirectUrl);\n        //                }\n        //            }\n        //            catch (Exception exRun)\n        //            {\n        //                _logger.LogError(exRun,\n        //                    \"‚ùå ExecuteNextAsync failed. ctx: flow={Flow} step={Step} next={Next} idx={Idx} from={From} orig={Orig} text='{Text}'\",\n        //                    ctxObj.FlowId, ctxObj.SourceStepId, ctxObj.TargetStepId, ctxObj.ButtonIndex, fromDigits, originalMessageId, buttonText);\n        //            }\n        //        }\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"‚ùå Failed to process CTA button click.\");\n        //    }\n        //}\n\n        private sealed class FlowBtnBundleNode\n        {\n            public int i { get; init; }\n            public string? t { get; init; }   // button text/title\n            public string? ty { get; init; }  // button type (URL/QUICK_REPLY/FLOW)\n            public string? v { get; init; }   // value/payload (e.g., URL)\n            public Guid? ns { get; init; }    // next step id\n        }\n        private static string ToKey(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return \"unknown\";\n            // letters/digits ‚Üí lower, spaces/._- ‚Üí underscore, strip the rest\n            var chars = s.Trim().ToLowerInvariant()\n                .Select(ch => char.IsLetterOrDigit(ch) ? ch : '_')\n                .ToArray();\n            var key = new string(chars);\n            // squeeze duplicate underscores\n            while (key.Contains(\"__\")) key = key.Replace(\"__\", \"_\");\n            return key.Trim('_');\n        }\n\n\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IClickWebhookProcessor.cs",
      "sha256": "5c42427d1e6c36dd122b3a10412eb70d7c412baf00ce54a614491a5b1590afeb",
      "language": "csharp",
      "size": 228,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IClickWebhookProcessor\n    {\n        Task ProcessClickAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IInboundMessageProcessor.cs",
      "sha256": "ec5496c7810122c99affe09fa17861d6d0c371457d9284e0ba58be6a93ea60f2",
      "language": "csharp",
      "size": 229,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IInboundMessageProcessor\n    {\n        Task ProcessChatAsync(JsonElement value);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/InboundMessageProcessor.cs",
      "sha256": "18ebaad4bf7dd762289357eea42665c0cfc4bd2c42dec9a37a1c88f2d5398c73",
      "language": "csharp",
      "size": 13083,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.SignalR;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Inbox.Hubs;\nusing Microsoft.Extensions.DependencyInjection;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.CRM.Services;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Features.Contacts.Services;\n\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class InboundMessageProcessor : IInboundMessageProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly IHubContext<InboxHub> _hubContext;\n        private readonly ILogger<InboundMessageProcessor> _logger;\n        private readonly IInboxService _inboxService;\n        private readonly IServiceScopeFactory _serviceScopeFactory;\n        private readonly IHubContext<InboxHub> _hub;\n        private readonly IContactProfileService _contactProfile;\n        public InboundMessageProcessor(\n            AppDbContext context,\n            IHubContext<InboxHub> hubContext,\n            ILogger<InboundMessageProcessor> logger,\n            IInboxService inboxService,\n            IServiceScopeFactory serviceScopeFactory,\n            IHubContext<InboxHub> hub, IContactProfileService contactProfile)\n        {\n            _context = context;\n            _hubContext = hubContext;\n            _logger = logger;\n            _inboxService = inboxService;\n            _serviceScopeFactory = serviceScopeFactory;\n            _hub = hub;\n            _contactProfile = contactProfile;\n        }\n\n        public async Task ProcessChatAsync(JsonElement value)\n        {\n            try\n            {\n                using var scope = _serviceScopeFactory.CreateScope();\n                var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n                var contactService = scope.ServiceProvider.GetRequiredService<IContactService>();\n                var chatSessionStateService = scope.ServiceProvider.GetRequiredService<IChatSessionStateService>();\n                var automationService = scope.ServiceProvider.GetRequiredService<IAutomationService>();\n                var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n                // ‚úÖ INSERT: resolve profile updater\n                var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n\n                string Normalize(string? number) =>\n                    string.IsNullOrWhiteSpace(number)\n                        ? \"\"\n                        : new string(number.Where(char.IsDigit).ToArray());\n\n                // 1) Extract WA metadata and message\n                var msg = value.GetProperty(\"messages\")[0];\n                var rawContactPhone = msg.GetProperty(\"from\").GetString()!;\n                var contactPhone = Normalize(rawContactPhone);\n                var content = msg.GetProperty(\"text\").GetProperty(\"body\").GetString();\n                var rawBusinessNumber = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString()!;\n                var cleanIncomingBusiness = Normalize(rawBusinessNumber);\n\n                // 2) Resolve business\n                var candidateBusinesses = await db.Businesses\n                    .Include(b => b.WhatsAppSettings)\n                    .Where(b => b.WhatsAppSettings != null &&\n                                b.WhatsAppSettings.Any(s => s.WhatsAppBusinessNumber != null))\n                    .ToListAsync();\n\n                var business = candidateBusinesses.FirstOrDefault(b =>\n                    b.WhatsAppSettings.Any(s => Normalize(s.WhatsAppBusinessNumber!) == cleanIncomingBusiness));\n\n                if (business == null)\n                {\n                    logger.LogWarning(\"‚ùå Business not found for WhatsApp number: {Number}\", rawBusinessNumber);\n                    return;\n                }\n\n                var businessId = business.Id;\n\n                // 3) Find or create contact\n                var contact = await contactService.FindOrCreateAsync(businessId, contactPhone);\n                if (contact == null)\n                {\n                    logger.LogWarning(\"‚ùå Could not resolve contact for phone: {Phone}\", contactPhone);\n                    return;\n                }\n\n                // ‚úÖ INSERT: Extract profile.name (Meta shape) and upsert into Contacts\n                string? TryGetProfileName(JsonElement root)\n                {\n                    // Safe TryGetProperty chain for: contacts[0].profile.name\n                    if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                        contactsEl.ValueKind == JsonValueKind.Array &&\n                        contactsEl.GetArrayLength() > 0)\n                    {\n                        var c0 = contactsEl[0];\n                        if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n                            profileEl.ValueKind == JsonValueKind.Object &&\n                            profileEl.TryGetProperty(\"name\", out var nameEl) &&\n                            nameEl.ValueKind == JsonValueKind.String)\n                        {\n                            var n = nameEl.GetString();\n                            return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                        }\n                    }\n                    return null;\n                }\n\n                var profileName = TryGetProfileName(value);\n                if (!string.IsNullOrWhiteSpace(profileName))\n                {\n                    try\n                    {\n                        await contactProfileService.UpsertProfileNameAsync(businessId, contactPhone, profileName!, CancellationToken.None);\n                    }\n                    catch (Exception ex)\n                    {\n                        logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName for {Phone}\", contactPhone);\n                        // non-fatal; continue processing\n                    }\n                }\n\n                // 4) Check chat mode‚Ä¶\n                var mode = await chatSessionStateService.GetChatModeAsync(businessId, contact.Id);\n                var isAgentMode = mode == \"agent\";\n\n                // 5) Log incoming message\n                var messageLog = new MessageLog\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contact.Id,\n                    RecipientNumber = contactPhone,\n                    MessageContent = content,\n                    Status = \"received\",\n                    CreatedAt = DateTime.UtcNow,\n                    SentAt = DateTime.UtcNow,\n                    IsIncoming = true\n                };\n\n                db.MessageLogs.Add(messageLog);\n                await db.SaveChangesAsync();\n\n                await _hub.Clients\n                    .Group($\"business_{businessId}\")\n                    .SendAsync(\"ReceiveInboxMessage\", new\n                    {\n                        contactId = contact.Id,\n                        message = messageLog.MessageContent,\n                        isIncoming = true,\n                        senderId = (Guid?)null,\n                        sentAt = messageLog.CreatedAt\n                    });\n\n                // 6) Try to trigger automation by keyword\n                try\n                {\n                    var triggerKeyword = (content ?? string.Empty).Trim().ToLowerInvariant();\n                    var handled = await automationService.TryRunFlowByKeywordAsync(\n                        businessId,\n                        triggerKeyword,\n                        contact.PhoneNumber,\n                        sourceChannel: \"whatsapp\",\n                        industryTag: \"default\"\n                    );\n\n                    if (!handled)\n                    {\n                        logger.LogInformation(\"üïµÔ∏è No automation flow matched keyword: {Keyword}\", triggerKeyword);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    logger.LogError(ex, \"‚ùå Automation flow execution failed.\");\n                }\n\n                // 7) Sync to inbox only if agent mode\n                if (isAgentMode)\n                {\n                    var inboxService = scope.ServiceProvider.GetRequiredService<IInboxService>();\n                    await inboxService.SaveIncomingMessageAsync(new InboxMessageDto\n                    {\n                        BusinessId = businessId,\n                        ContactId = contact.Id,\n                        RecipientPhone = contact.PhoneNumber,\n                        MessageBody = messageLog.MessageContent,\n                        IsIncoming = true,\n                        Status = messageLog.Status,\n                        SentAt = messageLog.CreatedAt\n                    });\n\n                    logger.LogInformation(\"üì• Message synced to inbox for contact {Phone}\", contactPhone);\n                }\n                else\n                {\n                    logger.LogInformation(\"üö´ Skipping inbox sync: chat mode is not 'agent'\");\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process inbound WhatsApp chat.\");\n            }\n        }\n        public async Task ProcessInteractiveAsync(JsonElement value, CancellationToken ct = default)\n        {\n            using var scope = _serviceScopeFactory.CreateScope();\n            var db = scope.ServiceProvider.GetRequiredService<AppDbContext>();\n            var contactProfileService = scope.ServiceProvider.GetRequiredService<IContactProfileService>();\n            var logger = scope.ServiceProvider.GetRequiredService<ILogger<InboundMessageProcessor>>();\n\n            string Normalize(string? number) =>\n                string.IsNullOrWhiteSpace(number) ? \"\" : new string(number.Where(char.IsDigit).ToArray());\n\n            // Extract Meta-shaped fields safely:\n            string? TryGetProfileName(JsonElement root)\n            {\n                if (root.TryGetProperty(\"contacts\", out var contactsEl) &&\n                    contactsEl.ValueKind == JsonValueKind.Array &&\n                    contactsEl.GetArrayLength() > 0)\n                {\n                    var c0 = contactsEl[0];\n                    if (c0.TryGetProperty(\"profile\", out var profileEl) &&\n                        profileEl.ValueKind == JsonValueKind.Object &&\n                        profileEl.TryGetProperty(\"name\", out var nameEl) &&\n                        nameEl.ValueKind == JsonValueKind.String)\n                    {\n                        var n = nameEl.GetString();\n                        return string.IsNullOrWhiteSpace(n) ? null : n!.Trim();\n                    }\n                }\n                return null;\n            }\n\n            // messages[0].from is always present for interactive/button\n            if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                return;\n\n            var msg0 = msgs[0];\n            var fromRaw = msg0.GetProperty(\"from\").GetString() ?? \"\";\n            var fromE164 = Normalize(fromRaw);\n\n            // Resolve Business via metadata.display_phone_number (same as chat path)\n            var displayNumberRaw = value.GetProperty(\"metadata\").GetProperty(\"display_phone_number\").GetString() ?? \"\";\n            var displayNumber = Normalize(displayNumberRaw);\n\n            var business = await db.Businesses\n                .Include(b => b.WhatsAppSettings)\n                .Where(b => b.WhatsAppSettings != null && b.WhatsAppSettings.Any(s => s.WhatsAppBusinessNumber != null))\n                .ToListAsync(ct);\n\n            var biz = business.FirstOrDefault(b => b.WhatsAppSettings!.Any(s => Normalize(s.WhatsAppBusinessNumber!) == displayNumber));\n            if (biz == null)\n            {\n                logger.LogWarning(\"‚ùå Business not found for interactive webhook number: {Num}\", displayNumberRaw);\n                return;\n            }\n\n            // Upsert profile name if present\n            var profileName = TryGetProfileName(value);\n            if (!string.IsNullOrWhiteSpace(profileName))\n            {\n                try\n                {\n                    await contactProfileService.UpsertProfileNameAsync(biz.Id, fromE164, profileName!, ct);\n                }\n                catch (Exception ex)\n                {\n                    logger.LogWarning(ex, \"‚ö†Ô∏è Failed to upsert ProfileName on interactive webhook for {Phone}\", fromE164);\n                }\n            }\n\n            // ‚Ä¶ continue your existing interactive handling (routing to next step, etc.)\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/IStatusWebhookProcessor.cs",
      "sha256": "5e4ad8a6b9cfece35403204938588d1ef8db2031afbc328d880acb1ee2231a25",
      "language": "csharp",
      "size": 238,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface IStatusWebhookProcessor\n    {\n        Task ProcessStatusUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/ITemplateWebhookProcessor.cs",
      "sha256": "6f04b24d675a88073c59204ed241e4744205e80e8d488dd464550a6105c45b7a",
      "language": "csharp",
      "size": 242,
      "content": "using System.Text.Json;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public interface ITemplateWebhookProcessor\n    {\n        Task ProcessTemplateUpdateAsync(JsonElement payload);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/StatusWebhookProcessor.cs",
      "sha256": "8749f0f8cf17ab2fa69210d1844138a078fe8538d1e8062b0d2014146877dcc1",
      "language": "csharp",
      "size": 11778,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\n\n// üëá where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models;   // CampaignSendLog\nusing xbytechat.api.Features.MessageManagement.DTOs;    // MessageLog\nusing xbytechat.api.Features.Webhooks.Services.Resolvers;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    /// <summary>\n    /// Legacy status processor (back-compat).\n    /// - Extracts statuses from the payload\n    /// - Resolves CampaignSendLog via IMessageIdResolver when possible\n    /// - Updates CampaignSendLog / MessageLog idempotently\n    /// New provider-aware flow should go through the dispatcher -> WhatsAppWebhookService.\n    /// </summary>\n    public class StatusWebhookProcessor : IStatusWebhookProcessor\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<StatusWebhookProcessor> _logger;\n        private readonly IMessageIdResolver _messageIdResolver;\n\n        public StatusWebhookProcessor(\n            AppDbContext context,\n            ILogger<StatusWebhookProcessor> logger,\n            IMessageIdResolver messageIdResolver)\n        {\n            _context = context;\n            _logger = logger;\n            _messageIdResolver = messageIdResolver;\n        }\n\n        /// <summary>\n        /// Entry point from dispatcher (legacy path).\n        /// Normalizes Meta envelope to a \"value\" object, then processes.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload)\n        {\n            _logger.LogDebug(\"status_webhook_in (legacy) \\n{Payload}\", payload.ToString());\n\n            // 1) Envelope ‚Üí value\n            if (TryExtractValue(payload, out var value))\n            {\n                await ProcessAsync(value);\n                return;\n            }\n\n            // 2) Already value-like (adapter flattened)\n            if (payload.ValueKind == JsonValueKind.Object &&\n                (payload.TryGetProperty(\"statuses\", out _) || payload.TryGetProperty(\"messages\", out _)))\n            {\n                await ProcessAsync(payload);\n                return;\n            }\n\n            _logger.LogWarning(\"Unrecognized status payload shape (legacy path).\");\n        }\n\n        /// <summary>\n        /// Extract statuses from a Meta-like \"value\" object and update DB.\n        /// </summary>\n        public async Task ProcessAsync(JsonElement value)\n        {\n            if (!value.TryGetProperty(\"statuses\", out var statuses) || statuses.ValueKind != JsonValueKind.Array)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è 'statuses' array missing in webhook payload (legacy path).\");\n                return;\n            }\n\n            foreach (var status in statuses.EnumerateArray())\n            {\n                if (status.ValueKind != JsonValueKind.Object) continue;\n\n                // message id (WAMID)\n                var messageId = status.TryGetProperty(\"id\", out var idEl) && idEl.ValueKind == JsonValueKind.String\n                    ? idEl.GetString()\n                    : null;\n\n                // status text\n                var statusText = status.TryGetProperty(\"status\", out var stEl) && stEl.ValueKind == JsonValueKind.String\n                    ? stEl.GetString()\n                    : null;\n\n                if (string.IsNullOrWhiteSpace(messageId) || string.IsNullOrWhiteSpace(statusText))\n                {\n                    _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or status in webhook payload (legacy path).\");\n                    continue;\n                }\n\n                // timestamp (string or number)\n                DateTime? eventTime = null;\n                if (status.TryGetProperty(\"timestamp\", out var tsEl))\n                {\n                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var epochS))\n                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochS).UtcDateTime;\n                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var epochN))\n                        eventTime = DateTimeOffset.FromUnixTimeSeconds(epochN).UtcDateTime;\n                }\n\n                _logger.LogDebug(\"üïì Parsed timestamp: {Time} (raw kind={Kind})\",\n                    eventTime?.ToString(\"o\") ?? \"n/a\", status.TryGetProperty(\"timestamp\", out var tsDbg) ? tsDbg.ValueKind.ToString() : \"n/a\");\n\n                // ‚úÖ First try resolving a CampaignSendLog row via resolver\n                Guid? sendLogId = null;\n                try\n                {\n                    sendLogId = await _messageIdResolver.ResolveCampaignSendLogIdAsync(messageId);\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogWarning(ex, \"MessageId resolver failed for {MessageId}\", messageId);\n                }\n\n                if (sendLogId is Guid sid)\n                {\n                    var log = await _context.Set<CampaignSendLog>()\n                                            .FirstOrDefaultAsync(l => l.Id == sid);\n\n                    if (log != null)\n                    {\n                        bool changed = false;\n\n                        var newStatus = MapMetaStatus(statusText);\n                        if (!string.IsNullOrEmpty(newStatus) &&\n                            !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n                        {\n                            log.SendStatus = newStatus;\n                            changed = true;\n                        }\n\n                        if (statusText == \"sent\" && (log.SentAt == null || log.SentAt == default) && eventTime.HasValue)\n                        {\n                            log.SentAt = eventTime.Value;\n                            changed = true;\n                        }\n                        if (statusText == \"delivered\" && (log.DeliveredAt == null || log.DeliveredAt == default) && eventTime.HasValue)\n                        {\n                            log.DeliveredAt = eventTime.Value;\n                            changed = true;\n                        }\n                        if (statusText == \"read\" && (log.ReadAt == null || log.ReadAt == default) && eventTime.HasValue)\n                        {\n                            log.ReadAt = eventTime.Value;\n                            changed = true;\n                        }\n\n                        if (changed)\n                        {\n                            await _context.SaveChangesAsync();\n                            _logger.LogInformation(\"‚úÖ CampaignSendLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, newStatus ?? statusText);\n                        }\n                        else\n                        {\n                            _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n                        }\n\n                        continue; // done with this status item\n                    }\n                }\n\n                // üîÅ Fallback: update MessageLog when there‚Äôs no CampaignSendLog\n                var msg = await _context.Set<MessageLog>()\n                                        .FirstOrDefaultAsync(m => m.MessageId == messageId);\n\n                if (msg != null)\n                {\n                    bool changed = false;\n\n                    switch (statusText)\n                    {\n                        case \"sent\":\n                            if (!EqualsIgnoreCase(msg.Status, \"Sent\"))\n                            {\n                                msg.Status = \"Sent\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value;\n                                changed = true;\n                            }\n                            break;\n\n                        case \"delivered\":\n                            // no DeliveredAt column on MessageLog; just progression\n                            if (!EqualsIgnoreCase(msg.Status, \"Read\") &&\n                                !EqualsIgnoreCase(msg.Status, \"Delivered\"))\n                            {\n                                msg.Status = \"Delivered\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value; // ensure SentAt eventually set\n                                changed = true;\n                            }\n                            break;\n\n                        case \"read\":\n                            if (!EqualsIgnoreCase(msg.Status, \"Read\"))\n                            {\n                                msg.Status = \"Read\";\n                                changed = true;\n                            }\n                            if ((msg.SentAt == null || msg.SentAt == default) && eventTime.HasValue)\n                            {\n                                msg.SentAt = eventTime.Value;\n                                changed = true;\n                            }\n                            break;\n\n                        default:\n                            // leave as-is for unknown statuses\n                            break;\n                    }\n\n                    if (changed)\n                    {\n                        await _context.SaveChangesAsync();\n                        _logger.LogInformation(\"‚ÑπÔ∏è MessageLog updated (legacy) for MessageId: {MessageId} ‚Üí {Status}\", messageId, msg.Status);\n                    }\n                    else\n                    {\n                        _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId} (legacy)\", statusText, messageId);\n                    }\n                }\n                else\n                {\n                    // lower severity; common when a send failed before obtaining a message id\n                    _logger.LogInformation(\"‚ìò No matching CampaignSendLog/MessageLog for MessageId: {MessageId} (legacy)\", messageId);\n                }\n            }\n        }\n\n        // ----------------- helpers -----------------\n\n        private static bool TryExtractValue(JsonElement payload, out JsonElement value)\n        {\n            value = default;\n            if (payload.ValueKind != JsonValueKind.Object) return false;\n            if (!payload.TryGetProperty(\"entry\", out var entry) || entry.ValueKind != JsonValueKind.Array || entry.GetArrayLength() == 0) return false;\n\n            var e0 = entry[0];\n            if (!e0.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0) return false;\n\n            var c0 = changes[0];\n            if (!c0.TryGetProperty(\"value\", out var v) || v.ValueKind != JsonValueKind.Object) return false;\n\n            value = v;\n            return true;\n        }\n\n        private static string? MapMetaStatus(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => \"Sent\",\n                \"delivered\" => \"Delivered\",\n                \"read\" => \"Read\",\n                \"failed\" => \"Failed\",\n                \"deleted\" => \"Deleted\",\n                _ => null\n            };\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Processors/TemplateWebhookProcessor.cs",
      "sha256": "0dbe7873fcf7b84d3a4fb9d78bda6689d86cbfd4d9fd50ce1d98029aaaef0558",
      "language": "csharp",
      "size": 1391,
      "content": "using System;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Processors\n{\n    public class TemplateWebhookProcessor : ITemplateWebhookProcessor\n    {\n        private readonly ILogger<TemplateWebhookProcessor> _logger;\n\n        public TemplateWebhookProcessor(ILogger<TemplateWebhookProcessor> logger)\n        {\n            _logger = logger;\n        }\n\n        public async Task ProcessTemplateUpdateAsync(JsonElement payload)\n        {\n            try\n            {\n                var entry = payload.GetProperty(\"entry\")[0];\n                var changes = entry.GetProperty(\"changes\")[0];\n                var value = changes.GetProperty(\"value\");\n\n                var eventType = value.GetProperty(\"event\").GetString();\n                var templateId = value.TryGetProperty(\"message_template_id\", out var idProp)\n                                 ? idProp.GetString() : \"(unknown)\";\n\n                _logger.LogInformation($\"üßæ Template Event Received: {eventType} for ID: {templateId}\");\n\n                // üß† You can store in DB or show in admin logs in the future\n\n                await Task.CompletedTask;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Failed to process template webhook update.\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/IMessageIdResolver.cs",
      "sha256": "a9129664eb60ff771e1f4895a51f74dd7277f7693c9a9638cab9363dc4618baa",
      "language": "csharp",
      "size": 369,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public interface IMessageIdResolver\n    {\n        Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId);\n        Task<Guid?> ResolveMessageLogIdAsync(string messageId);\n        Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/Resolvers/MessageIdResolver.cs",
      "sha256": "34280daacb42fd65daf76845f254009aff42867432c235250272bb6fc6676084",
      "language": "csharp",
      "size": 1972,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api;\n\nnamespace xbytechat.api.Features.Webhooks.Services.Resolvers\n{\n    public class MessageIdResolver : IMessageIdResolver\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<MessageIdResolver> _logger;\n\n        public MessageIdResolver(AppDbContext context, ILogger<MessageIdResolver> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task<Guid?> ResolveCampaignSendLogIdAsync(string messageId)\n        {\n            var log = await _context.CampaignSendLogs\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è CampaignSendLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveMessageLogIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.Id;\n        }\n\n        public async Task<Guid?> ResolveBusinessIdByMessageIdAsync(string messageId)\n        {\n            var log = await _context.MessageLogs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(l => l.MessageId == messageId);\n\n            if (log == null)\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è MessageLog not found for MessageId: {MessageId}\", messageId);\n                return null;\n            }\n\n            return log.BusinessId;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WebhookQueueService.cs",
      "sha256": "5de062949cd3197e00bf3971292ea36c2014849de597b6cc077673c464a02286",
      "language": "csharp",
      "size": 1054,
      "content": "using System.Text.Json;\nusing System.Threading.Channels;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WebhookQueueService : IWebhookQueueService\n    {\n        private readonly Channel<JsonElement> _queue;\n\n        public WebhookQueueService()\n        {\n            var options = new BoundedChannelOptions(5000)\n            {\n                FullMode = BoundedChannelFullMode.Wait,\n                SingleReader = true,\n                SingleWriter = false\n            };\n\n            _queue = Channel.CreateBounded<JsonElement>(options);\n        }\n\n        public void Enqueue(JsonElement item)\n        {\n            if (!_queue.Writer.TryWrite(item))\n            {\n                throw new InvalidOperationException(\"‚ö†Ô∏è Webhook queue is full.\");\n            }\n        }\n\n        public async ValueTask<JsonElement> DequeueAsync(CancellationToken cancellationToken)\n        {\n            return await _queue.Reader.ReadAsync(cancellationToken);\n        }\n\n        public int GetQueueLength() => _queue.Reader.Count;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookDispatcher.cs",
      "sha256": "0499a17e151db24a7c3ab24209208db55a17bef3af451b922d10a722564624f4",
      "language": "csharp",
      "size": 14484,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.Webhooks.Directory;            // ‚úÖ provider directory\nusing xbytechat.api.Features.Webhooks.Pinnacle.Services.Adapters;\nusing xbytechat.api.Features.Webhooks.Services.Processors;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    /// <summary>\n    /// Central dispatcher for WhatsApp webhook events.\n    /// Routes payloads to the appropriate processor based on payload type.\n    /// </summary>\n    public class WhatsAppWebhookDispatcher : IWhatsAppWebhookDispatcher\n    {\n        private readonly IStatusWebhookProcessor _statusProcessor;           // legacy fallback (keep)\n        private readonly ITemplateWebhookProcessor _templateProcessor;       // template events path (unchanged)\n        private readonly IClickWebhookProcessor _clickProcessor;             // click/journey path (unchanged)\n        private readonly IInboundMessageProcessor _inboundMessageProcessor;  // inbound chat path (unchanged)\n        private readonly IWhatsAppWebhookService _webhookService;            // ‚úÖ for new unified status updater call\n        private readonly IProviderDirectory _directory;                      // ‚úÖ resolve BusinessId from provider hints\n        private readonly ILogger<WhatsAppWebhookDispatcher> _logger;\n        private readonly IPinnacleToMetaAdapter _pinnacleToMetaAdapter;\n        private readonly IBillingIngestService _billingIngest;\n        public WhatsAppWebhookDispatcher(\n            IStatusWebhookProcessor statusProcessor,\n            ITemplateWebhookProcessor templateProcessor,\n            ILogger<WhatsAppWebhookDispatcher> logger,\n            IClickWebhookProcessor clickProcessor,\n            IInboundMessageProcessor inboundMessageProcessor,\n            IWhatsAppWebhookService webhookService,     // ‚úÖ add\n            IProviderDirectory directory,\n            IPinnacleToMetaAdapter pinnacleToMetaAdapter,\n            IBillingIngestService billingIngest\n        // ‚úÖ add\n        )\n        {\n            _statusProcessor = statusProcessor;\n            _templateProcessor = templateProcessor;\n            _logger = logger;\n            _clickProcessor = clickProcessor;\n            _inboundMessageProcessor = inboundMessageProcessor;\n            _webhookService = webhookService;\n            _directory = directory;\n            _pinnacleToMetaAdapter = pinnacleToMetaAdapter;\n            _billingIngest = billingIngest;\n        }\n\n        public async Task DispatchAsync(JsonElement payload)\n        {\n            _logger.LogWarning(\"üì¶ Dispatcher Raw Payload:\\n{Payload}\", payload.ToString());\n\n            try\n            {\n                // 0) Detect provider & normalize to a Meta-like envelope for downstream processors\n                var provider = DetectProvider(payload); // \"meta\" | \"pinnacle\" | null\n\n                JsonElement envelope = provider == \"pinnacle\"\n                    ? _pinnacleToMetaAdapter.ToMetaEnvelope(payload)\n                    : payload;\n\n                if (!envelope.TryGetProperty(\"entry\", out var entries)) return;\n\n                foreach (var entry in entries.EnumerateArray())\n                {\n                    if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                    foreach (var change in changes.EnumerateArray())\n                    {\n                        if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                        // 1) STATUS UPDATES\n                        if (IsStatusPayload(envelope)) // üîÅ use envelope, not raw payload\n                        {\n                            Guid? businessId = null;\n                            try\n                            {\n                                var hints = ExtractNumberHints(envelope, provider); // üîÅ from envelope\n                                businessId = await _directory.ResolveBusinessIdAsync(\n                                    provider: provider,\n                                    phoneNumberId: hints.PhoneNumberId,\n                                    displayPhoneNumber: hints.DisplayPhoneNumber,\n                                    wabaId: hints.WabaId,\n                                    waId: hints.WaId\n                                );\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"ProviderDirectory lookup failed; will fallback to legacy status processor.\");\n                            }\n\n                            if (businessId is Guid bid && !string.IsNullOrWhiteSpace(provider))\n                            {\n                                _logger.LogInformation(\"üì¶ Routing to Unified Status Updater (provider={Provider}, businessId={BusinessId})\", provider, bid);\n                                // üîπ NEW: billing ingest (captures pricing/conversation updates that arrive in status webhooks)\n                                var providerCanonical = (provider ?? \"meta\").Equals(\"pinnacle\", StringComparison.OrdinalIgnoreCase)\n                                    ? \"PINNACLE\"\n                                    : \"META_CLOUD\";\n\n                                await _billingIngest.IngestFromWebhookAsync(bid, providerCanonical, envelope.ToString());\n\n\n                                await _webhookService.ProcessStatusUpdateAsync(bid, provider!, envelope); // üîÅ pass envelope\n\n                            }\n                            else\n                            {\n                                _logger.LogWarning(\"‚ö†Ô∏è Status routing fallback ‚Üí legacy processor (provider={Provider}, businessId={BusinessId})\", provider, businessId);\n                                await _statusProcessor.ProcessStatusUpdateAsync(envelope); // üîÅ pass envelope\n                            }\n                            continue;\n                        }\n\n                        // 2) TEMPLATE EVENTS (unchanged)\n                        if (value.TryGetProperty(\"event\", out var eventType)\n                            && eventType.GetString()?.StartsWith(\"template_\") == true)\n                        {\n                            _logger.LogInformation(\"üì¶ Routing to Template Processor\");\n                            await _templateProcessor.ProcessTemplateUpdateAsync(envelope); // üîÅ pass envelope\n                            continue;\n                        }\n\n                        // 3) MESSAGES (clicks + inbound)\n                        if (!value.TryGetProperty(\"messages\", out var msgs) || msgs.GetArrayLength() == 0)\n                        {\n                            _logger.LogDebug(\"‚ÑπÔ∏è No 'messages' array present.\");\n                            continue;\n                        }\n\n                        foreach (var m in msgs.EnumerateArray())\n                        {\n                            if (!m.TryGetProperty(\"type\", out var typeProp))\n                            {\n                                _logger.LogDebug(\"‚ÑπÔ∏è Message without 'type' field.\");\n                                continue;\n                            }\n\n                            var type = typeProp.GetString();\n\n                            // (A) Legacy quick-reply button ‚Üí CLICK\n                            if (type == \"button\")\n                            {\n                                _logger.LogInformation(\"üëâ Routing to Click Processor (legacy 'button')\");\n                                await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                continue;\n                            }\n\n                            // (B) Interactive (button_reply / list_reply) ‚Üí CLICK\n                            if (type == \"interactive\" && m.TryGetProperty(\"interactive\", out var interactive))\n                            {\n                                if (interactive.TryGetProperty(\"type\", out var interactiveType) &&\n                                    interactiveType.GetString() == \"button_reply\")\n                                {\n                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/button_reply)\");\n                                    await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                    continue;\n                                }\n\n                                if (interactive.TryGetProperty(\"list_reply\", out _))\n                                {\n                                    _logger.LogInformation(\"üëâ Routing to Click Processor (interactive/list_reply)\");\n                                    await _clickProcessor.ProcessClickAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                    continue;\n                                }\n                            }\n\n                            // (C) Inbound plain message types ‚Üí INBOUND\n                            if (type is \"text\" or \"image\" or \"audio\")\n                            {\n                                _logger.LogInformation(\"üí¨ Routing to InboundMessageProcessor (type: {Type})\", type);\n                                await _inboundMessageProcessor.ProcessChatAsync(change.GetProperty(\"value\")); // üîÅ from envelope\n                                continue;\n                            }\n\n                            _logger.LogDebug(\"‚ÑπÔ∏è Message type '{Type}' not handled by dispatcher.\", type);\n                        }\n                    }\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"‚ùå Dispatcher failed to process WhatsApp webhook.\");\n            }\n        }\n\n        private static bool IsStatusPayload(JsonElement root)\n        {\n            // Try Meta shape first: entry[].changes[].value.statuses\n            if (TryGetMetaValue(root, out var val) && val.Value.TryGetProperty(\"statuses\", out _))\n                return true;\n\n            // Try common Pinnacle shapes: \"status\" or event containing \"status\"\n            if (root.TryGetProperty(\"status\", out _)) return true;\n            if (root.TryGetProperty(\"event\", out var ev) &&\n                (ev.GetString()?.Contains(\"status\", StringComparison.OrdinalIgnoreCase) ?? false))\n                return true;\n\n            return false;\n        }\n\n        private static string? DetectProvider(JsonElement root)\n        {\n            // Heuristics by envelope\n            if (root.TryGetProperty(\"object\", out var obj) && obj.GetString() == \"whatsapp_business_account\")\n                return \"meta\";\n            if (root.TryGetProperty(\"entry\", out _))\n                return \"meta\";\n            if (root.TryGetProperty(\"event\", out _))\n                return \"pinnacle\";\n\n            return null;\n        }\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static NumberHints ExtractNumberHints(JsonElement root, string? provider)\n        {\n            var hints = new NumberHints();\n\n            if (string.Equals(provider, \"meta\", StringComparison.OrdinalIgnoreCase))\n            {\n                if (TryGetMetaValue(root, out var v))\n                {\n                    if (v.Value.TryGetProperty(\"metadata\", out var md))\n                    {\n                        if (md.TryGetProperty(\"phone_number_id\", out var pnid))\n                            hints.PhoneNumberId = pnid.GetString();\n\n                        if (md.TryGetProperty(\"display_phone_number\", out var disp))\n                            hints.DisplayPhoneNumber = NormalizePhone(disp.GetString());\n                    }\n\n                    if (v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                        statuses.ValueKind == JsonValueKind.Array && statuses.GetArrayLength() > 0)\n                    {\n                        var s0 = statuses[0];\n                        if (s0.TryGetProperty(\"recipient_id\", out var rid))\n                            hints.WaId = rid.GetString();\n                    }\n                }\n            }\n            else if (string.Equals(provider, \"pinnacle\", StringComparison.OrdinalIgnoreCase))\n            {\n                // Adjust to your Pinnacle adapter payload (post-adaptation).\n                // If you inject phone_number_id when adapting to Meta shape, this will pick it up:\n                if (root.TryGetProperty(\"phone_number_id\", out var pn))\n                    hints.PhoneNumberId = pn.GetString();\n\n                // Fallback to sender number fields:\n                if (root.TryGetProperty(\"from\", out var from))\n                    hints.DisplayPhoneNumber = NormalizePhone(from.GetString());\n                else if (root.TryGetProperty(\"msisdn\", out var msisdn))\n                    hints.DisplayPhoneNumber = NormalizePhone(msisdn.GetString());\n\n                if (root.TryGetProperty(\"wabaId\", out var waba))\n                    hints.WabaId = waba.GetString();\n            }\n\n            return hints;\n        }\n\n        private static string? NormalizePhone(string? v)\n        {\n            if (string.IsNullOrWhiteSpace(v)) return null;\n            var t = v.Trim();\n            var keepPlus = t.StartsWith(\"+\");\n            var digits = new string(t.Where(char.IsDigit).ToArray());\n            return keepPlus ? \"+\" + digits : digits;\n        }\n\n        private struct NumberHints\n        {\n            public string? PhoneNumberId { get; set; }\n            public string? DisplayPhoneNumber { get; set; }\n            public string? WabaId { get; set; }\n            public string? WaId { get; set; }\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Services/WhatsAppWebhookService.cs",
      "sha256": "c3bf201e03458a246ea22f55cefa2c6bd2abc9659838214b01fe321dbb0f854b",
      "language": "csharp",
      "size": 14925,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\nusing xbytechat.api;                                      // AppDbContext\nusing xbytechat.api.Features.CampaignTracking.Models;     // CampaignSendLog\nusing xbytechat.api.Features.Webhooks.Status;             // IMessageStatusUpdater, StatusEvent, MessageDeliveryState\n\nnamespace xbytechat.api.Features.Webhooks.Services\n{\n    public class WhatsAppWebhookService : IWhatsAppWebhookService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<WhatsAppWebhookService> _logger;\n        private readonly IMessageStatusUpdater _updater;\n\n        public WhatsAppWebhookService(\n            AppDbContext context,\n            ILogger<WhatsAppWebhookService> logger,\n            IMessageStatusUpdater updater)\n        {\n            _context = context;\n            _logger = logger;\n            _updater = updater;\n        }\n\n        /// <summary>\n        /// Legacy path: payload only (Meta-like).\n        /// We keep this for back-compat, but we *upgrade* behavior:\n        /// - For each status: find CampaignSendLog by MessageId\n        /// - If found ‚Üí get BusinessId and delegate to the unified updater\n        /// - If not found ‚Üí keep legacy log-only update (minimal)\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(JsonElement payload, CancellationToken ct = default)\n        {\n            _logger.LogInformation(\"üì¶ Processing Webhook Status (legacy):\\n{Pretty}\",\n                JsonSerializer.Serialize(payload, new JsonSerializerOptions { WriteIndented = true }));\n\n            if (!payload.TryGetProperty(\"entry\", out var entries))\n            {\n                _logger.LogWarning(\"‚ö†Ô∏è Payload missing 'entry' property.\");\n                return;\n            }\n\n            foreach (var entry in entries.EnumerateArray())\n            {\n                if (!entry.TryGetProperty(\"changes\", out var changes)) continue;\n\n                foreach (var change in changes.EnumerateArray())\n                {\n                    if (!change.TryGetProperty(\"value\", out var value)) continue;\n                    if (!value.TryGetProperty(\"statuses\", out var statuses)) continue;\n\n                    foreach (var status in statuses.EnumerateArray())\n                    {\n                        string? messageId = status.TryGetProperty(\"id\", out var idProp) ? idProp.GetString() : null;\n                        string? statusText = status.TryGetProperty(\"status\", out var statusProp) ? statusProp.GetString() : null;\n\n                        // timestamp may be string or number\n                        long ts = 0;\n                        if (status.TryGetProperty(\"timestamp\", out var tsProp))\n                        {\n                            if (tsProp.ValueKind == JsonValueKind.String && long.TryParse(tsProp.GetString(), out var parsedTs))\n                                ts = parsedTs;\n                            else if (tsProp.ValueKind == JsonValueKind.Number)\n                                ts = tsProp.GetInt64();\n                        }\n\n                        if (string.IsNullOrEmpty(messageId) || string.IsNullOrEmpty(statusText))\n                        {\n                            _logger.LogWarning(\"‚ö†Ô∏è Missing messageId or status in webhook payload.\");\n                            continue;\n                        }\n\n                        // Try to locate CampaignSendLog (gives us BusinessId)\n                        var sendLog = await _context.Set<CampaignSendLog>()\n                            .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);\n\n                        if (sendLog != null)\n                        {\n                            var ev = new StatusEvent\n                            {\n                                BusinessId = sendLog.BusinessId,\n                                Provider = \"meta\", // legacy path is Meta-shaped; adjust if you also send Pinnacle here\n                                ProviderMessageId = messageId,\n                                State = MapMetaState(statusText),\n                                OccurredAt = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts) : DateTimeOffset.UtcNow\n                            };\n\n                            await _updater.UpdateAsync(ev, ct);\n                            _logger.LogInformation(\"‚úÖ Unified update applied for MessageId {MessageId} (state={State})\", messageId, statusText);\n                        }\n                        else\n                        {\n                            // Fallback: minimal legacy update to CampaignSendLogs (kept from your original code)\n                            var time = ts > 0 ? DateTimeOffset.FromUnixTimeSeconds(ts).UtcDateTime : (DateTime?)null;\n\n                            var log = await _context.Set<CampaignSendLog>()\n                                .FirstOrDefaultAsync(l => l.MessageId == messageId, ct);\n\n                            if (log == null)\n                            {\n                                _logger.LogWarning(\"‚ö†Ô∏è No matching CampaignSendLog for MessageId: {MessageId}\", messageId);\n                                continue;\n                            }\n\n                            var newStatus = statusText switch\n                            {\n                                \"sent\" => \"Sent\",\n                                \"delivered\" => \"Delivered\",\n                                \"read\" => \"Read\",\n                                _ => null\n                            };\n\n                            bool isUpdated = false;\n\n                            if (!string.IsNullOrEmpty(newStatus) && !string.Equals(log.SendStatus, newStatus, StringComparison.Ordinal))\n                            {\n                                log.SendStatus = newStatus;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"delivered\" && log.DeliveredAt == null && time.HasValue)\n                            {\n                                log.DeliveredAt = time.Value;\n                                isUpdated = true;\n                            }\n\n                            if (statusText == \"read\" && log.ReadAt == null && time.HasValue)\n                            {\n                                log.ReadAt = time.Value;\n                                isUpdated = true;\n                            }\n\n                            if (isUpdated)\n                            {\n                                await _context.SaveChangesAsync(ct);\n                                _logger.LogInformation(\"‚úÖ Log updated for MessageId: {MessageId} ‚Üí {Status}\", messageId, newStatus);\n                            }\n                            else\n                            {\n                                _logger.LogInformation(\"üîÅ Duplicate status '{Status}' skipped for MessageId: {MessageId}\", statusText, messageId);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        /// <summary>\n        /// New provider-aware overload called by the dispatcher after it resolves BusinessId + Provider.\n        /// Always uses the unified updater.\n        /// </summary>\n        public async Task ProcessStatusUpdateAsync(Guid businessId, string provider, JsonElement payload, CancellationToken ct = default)\n        {\n            provider = (provider ?? \"\").Trim().ToLowerInvariant();\n\n            foreach (var ev in ParseStatusEvents(businessId, provider, payload))\n            {\n                await _updater.UpdateAsync(ev, ct);\n            }\n        }\n\n        // ---------------- Parsers (Meta + Pinnacle) ----------------\n\n        private static IEnumerable<StatusEvent> ParseStatusEvents(Guid businessId, string provider, JsonElement root)\n        {\n            if (provider == \"meta\" || provider == \"meta_cloud\" || provider == \"meta-cloud\")\n            {\n                if (TryGetMetaValue(root, out var v) &&\n                    v.Value.TryGetProperty(\"statuses\", out var statuses) &&\n                    statuses.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var s in statuses.EnumerateArray())\n                    {\n                        var stateStr = s.TryGetProperty(\"status\", out var st) ? st.GetString() : null;\n                        var state = MapMetaState(stateStr);\n\n                        var tsStr = s.TryGetProperty(\"timestamp\", out var tsv) ? tsv.ToString() : null;\n                        var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;\n\n                        var providerMsgId = s.TryGetProperty(\"id\", out var idv) ? idv.GetString() : null;\n                        var waId = s.TryGetProperty(\"recipient_id\", out var rid) ? rid.GetString() : null;\n\n                        string? errorCode = null, errorMsg = null;\n                        if (s.TryGetProperty(\"errors\", out var errs) && errs.ValueKind == JsonValueKind.Array && errs.GetArrayLength() > 0)\n                        {\n                            var e0 = errs[0];\n                            if (e0.TryGetProperty(\"code\", out var cv)) errorCode = cv.ToString();\n                            if (e0.TryGetProperty(\"message\", out var mv)) errorMsg = mv.GetString();\n                        }\n\n                        string? conversationId = null;\n                        if (s.TryGetProperty(\"conversation\", out var conv) && conv.TryGetProperty(\"id\", out var cid))\n                            conversationId = cid.GetString();\n\n                        yield return new StatusEvent\n                        {\n                            BusinessId = businessId,\n                            Provider = \"meta\",\n                            ProviderMessageId = providerMsgId ?? string.Empty,\n                            RecipientWaId = waId,\n                            State = state,\n                            OccurredAt = occurredAt,\n                            ErrorCode = errorCode,\n                            ErrorMessage = errorMsg,\n                            ConversationId = conversationId\n                        };\n                    }\n                }\n                yield break;\n            }\n\n            if (provider == \"pinnacle\")\n            {\n                // Support both object and array shapes\n                if (root.ValueKind == JsonValueKind.Object)\n                {\n                    foreach (var ev in ParsePinnacleObject(businessId, root))\n                        yield return ev;\n                }\n                else if (root.ValueKind == JsonValueKind.Array)\n                {\n                    foreach (var item in root.EnumerateArray())\n                        foreach (var ev in ParsePinnacleObject(businessId, item))\n                            yield return ev;\n                }\n                yield break;\n            }\n        }\n\n        private static IEnumerable<StatusEvent> ParsePinnacleObject(Guid businessId, JsonElement obj)\n        {\n            var providerMsgId = obj.TryGetProperty(\"message_id\", out var mid) ? mid.GetString()\n                              : obj.TryGetProperty(\"id\", out var idv) ? idv.GetString()\n                              : null;\n\n            var waId = obj.TryGetProperty(\"to\", out var to) ? to.GetString()\n                     : obj.TryGetProperty(\"recipient_id\", out var rid) ? rid.GetString()\n                     : null;\n\n            var stateStr = obj.TryGetProperty(\"status\", out var st) ? st.GetString()\n                         : obj.TryGetProperty(\"event\", out var ev) ? ev.GetString()\n                         : null;\n\n            var state = MapPinnacleState(stateStr);\n\n            var tsStr = obj.TryGetProperty(\"timestamp\", out var tsv) ? tsv.ToString() : null;\n            var occurredAt = TryParseUnix(tsStr) ?? DateTimeOffset.UtcNow;\n\n            string? errorCode = null, errorMsg = null;\n            if (obj.TryGetProperty(\"error\", out var err))\n            {\n                if (err.TryGetProperty(\"code\", out var cv)) errorCode = cv.ToString();\n                if (err.TryGetProperty(\"message\", out var mv)) errorMsg = mv.GetString();\n            }\n\n            yield return new StatusEvent\n            {\n                BusinessId = businessId,\n                Provider = \"pinnacle\",\n                ProviderMessageId = providerMsgId ?? string.Empty,\n                RecipientWaId = waId,\n                State = state,\n                OccurredAt = occurredAt,\n                ErrorCode = errorCode,\n                ErrorMessage = errorMsg\n            };\n        }\n\n        // ---------------- helpers ----------------\n\n        private static bool TryGetMetaValue(JsonElement root, out (JsonElement Value, JsonElement? Change, JsonElement? Entry) res)\n        {\n            res = default;\n            if (!root.TryGetProperty(\"entry\", out var entries) || entries.ValueKind != JsonValueKind.Array || entries.GetArrayLength() == 0)\n                return false;\n\n            var entry = entries[0];\n            if (!entry.TryGetProperty(\"changes\", out var changes) || changes.ValueKind != JsonValueKind.Array || changes.GetArrayLength() == 0)\n                return false;\n\n            var change = changes[0];\n            if (!change.TryGetProperty(\"value\", out var value))\n                return false;\n\n            res = (value, change, entry);\n            return true;\n        }\n\n        private static MessageDeliveryState MapMetaState(string? s) =>\n            (s ?? \"\").ToLowerInvariant() switch\n            {\n                \"sent\" => MessageDeliveryState.Sent,\n                \"delivered\" => MessageDeliveryState.Delivered,\n                \"read\" => MessageDeliveryState.Read,\n                \"failed\" => MessageDeliveryState.Failed,\n                \"deleted\" => MessageDeliveryState.Deleted,\n                _ => MessageDeliveryState.Sent\n            };\n\n        private static MessageDeliveryState MapPinnacleState(string? s)\n        {\n            var v = (s ?? \"\").ToLowerInvariant();\n            if (v.Contains(\"deliv\")) return MessageDeliveryState.Delivered;\n            if (v.Contains(\"read\")) return MessageDeliveryState.Read;\n            if (v.Contains(\"fail\") || v.Contains(\"error\")) return MessageDeliveryState.Failed;\n            if (v.Contains(\"sent\") || v.Contains(\"submit\")) return MessageDeliveryState.Sent;\n            if (v.Contains(\"delete\")) return MessageDeliveryState.Deleted;\n            return MessageDeliveryState.Sent;\n        }\n\n        private static DateTimeOffset? TryParseUnix(string? val)\n        {\n            if (string.IsNullOrWhiteSpace(val)) return null;\n            if (long.TryParse(val, out var s)) return DateTimeOffset.FromUnixTimeSeconds(s);\n            return null;\n        }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/IMessageStatusUpdater.cs",
      "sha256": "5dd38c83c682b97d35a29121860d3c8bf856c29c01a465ad32e18730fa62d04e",
      "language": "csharp",
      "size": 1246,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    public interface IMessageStatusUpdater\n    {\n        Task UpdateAsync(StatusEvent ev, CancellationToken ct = default);\n    }\n\n    public sealed class StatusEvent\n    {\n        public Guid BusinessId { get; init; }\n        public string Provider { get; init; } = \"\";          // \"meta\" | \"pinnacle\"\n\n        // Provider message id (Meta \"id\", Pinnacle equivalent) ‚Üí maps to MessageId in your DB\n        public string ProviderMessageId { get; init; } = \"\";\n\n        // Optional hints (not required in your current lookups)\n        public Guid? CampaignSendLogId { get; init; }\n        public string? RecipientWaId { get; init; }\n\n        public MessageDeliveryState State { get; init; }     // Sent/Delivered/Read/Failed/Deleted\n        public DateTimeOffset OccurredAt { get; init; }      // from provider timestamp when available\n\n        public string? ErrorCode { get; init; }\n        public string? ErrorMessage { get; init; }\n        public string? ConversationId { get; init; }\n    }\n\n    public enum MessageDeliveryState\n    {\n        Sent,\n        Delivered,\n        Read,\n        Failed,\n        Deleted\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusContracts.cs",
      "sha256": "37627bd0faaa1e9e438a5d7379dc5f5773a8f7553fe9e1b476e74ee20a66ce30",
      "language": "csharp",
      "size": 1443,
      "content": "namespace xbytechat.api.Features.Webhooks.Status\n{\n    public class MessageStatusContracts\n    {\n        public enum CanonicalMessageStatus\n        {\n            Unknown = 0,\n            Submitted,   // API accepted (optional)\n            Sent,        // provider accepted / sent\n            Delivered,\n            Read,\n            Failed\n        }\n        public sealed class UpdateMessageStatusRequest\n        {\n            public Guid BusinessId { get; set; }\n            public string Provider { get; set; } = \"\";              // \"meta_cloud\" | \"pinnacle\" | etc.\n            public string MessageId { get; set; } = \"\";             // provider message id (WAMID / id)\n            public string RawStatus { get; set; } = \"\";             // provider-specific (e.g., \"sent\", \"delivered\")\n            public DateTimeOffset? EventTime { get; set; }          // provider timestamp, if any\n\n            public string? RecipientNumber { get; set; }            // optional sanity context\n            public string? ErrorCode { get; set; }                  // optional error info\n            public string? ErrorMessage { get; set; }               // optional error info\n            public string? RawPayloadJson { get; set; }             // optional audit/debug\n        }\n\n        public interface IMessageStatusUpdater\n        {\n            Task<bool> UpdateAsync(UpdateMessageStatusRequest req, CancellationToken ct = default);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Webhooks/Status/MessageStatusUpdater.cs",
      "sha256": "55a15fa6bb101b8375418e125a8a48473612f420aa65d7a7dd20a2c7e174c1eb",
      "language": "csharp",
      "size": 21232,
      "content": "using System;\nusing System.Linq;\nusing System.Reflection;\nusing System.Text.Json;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\n\n// üëá make sure this is where your AppDbContext lives\nusing xbytechat.api;\n\nusing xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\nusing xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\nusing xbytechat.api.CRM.Models;                       // Contact (nav)\nusing xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n// üëá Billing ingest\nusing xbytechat_api.Features.Billing.Services;        // IBillingIngestService\n\nnamespace xbytechat.api.Features.Webhooks.Status\n{\n    /// <summary>\n    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n    /// Also forwards raw Meta webhook payloads to Billing ingest for pricing/billing capture.\n    /// </summary>\n    public class MessageStatusUpdater : IMessageStatusUpdater\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<MessageStatusUpdater> _log;\n        private readonly IBillingIngestService _billing;\n\n        public MessageStatusUpdater(AppDbContext db,\n                                    ILogger<MessageStatusUpdater> log,\n                                    IBillingIngestService billing)\n        {\n            _db = db;\n            _log = log;\n            _billing = billing;\n        }\n\n        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n        {\n            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n            {\n                _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n                return;\n            }\n\n            // 1) Pull candidates (scoped to business + WAMID)\n            var sendLogQ = _db.Set<CampaignSendLog>()\n                              .AsTracking()\n                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n            // NOTE: some rows set both MessageId and ProviderMessageId to the wamid; be flexible.\n            var msgLogQ = _db.Set<MessageLog>()\n                             .AsTracking()\n                             .Where(m => m.BusinessId == ev.BusinessId &&\n                                        (m.ProviderMessageId == ev.ProviderMessageId ||\n                                         m.MessageId == ev.ProviderMessageId));\n\n            // If caller passed a specific CampaignSendLogId, narrow further\n            if (ev.CampaignSendLogId is Guid sid)\n                sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n            // 2) Apply transition (idempotent)\n            var changed = ApplyTransition(sendLog, msgLog, ev);\n\n            // 3) Persist only if something actually changed\n            if (changed > 0)\n                await _db.SaveChangesAsync(ct);\n\n            // 4) Always forward Meta status webhook payloads to Billing ingest (for pricing events).\n            await TryForwardToBillingAsync(ev, ct);\n        }\n\n        /// <summary>Returns number of entities modified.</summary>\n        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n        {\n            int modified = 0;\n\n            // --- CampaignSendLog updates ---\n            if (sendLog != null)\n            {\n                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    sendLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n                        {\n                            sendLog.SendStatus = \"Sent\";\n                            modified++;\n                        }\n                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n                        {\n                            sendLog.SendStatus = \"Delivered\";\n                            modified++;\n                        }\n                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n                        {\n                            sendLog.SendStatus = \"Read\";\n                            modified++;\n                        }\n                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n                        {\n                            sendLog.SendStatus = \"Failed\";\n                            modified++;\n                        }\n                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            sendLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n                        {\n                            sendLog.SendStatus = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            // --- MessageLog updates ---\n            if (msgLog != null)\n            {\n                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n                {\n                    msgLog.MessageId = ev.ProviderMessageId;\n                    modified++;\n                }\n\n                switch (ev.State)\n                {\n                    case MessageDeliveryState.Sent:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n                        {\n                            msgLog.Status = \"Sent\";\n                            modified++;\n                        }\n                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n                        break;\n\n                    case MessageDeliveryState.Delivered:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n                        {\n                            msgLog.Status = \"Delivered\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Read:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n                        {\n                            msgLog.Status = \"Read\";\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Failed:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n                        {\n                            msgLog.Status = \"Failed\";\n                            modified++;\n                        }\n                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n                        {\n                            msgLog.ErrorMessage = ev.ErrorMessage;\n                            modified++;\n                        }\n                        break;\n\n                    case MessageDeliveryState.Deleted:\n                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n                        {\n                            msgLog.Status = \"Deleted\";\n                            modified++;\n                        }\n                        break;\n                }\n            }\n\n            if (sendLog == null && msgLog == null)\n            {\n                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n            }\n\n            return modified;\n        }\n\n        private static bool EqualsIgnoreCase(string? a, string? b) =>\n            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n\n        // ---------------- Billing forwarder ----------------\n\n        private async Task TryForwardToBillingAsync(StatusEvent ev, CancellationToken ct)\n        {\n            try\n            {\n                if (ev.BusinessId == Guid.Empty) return;\n\n                // Pull Provider (via reflection to avoid changing your StatusEvent contract)\n                var provider = GetStringProp(ev, \"Provider\")\n                               ?? GetStringProp(ev, \"ChannelProvider\")\n                               ?? GetStringProp(ev, \"SourceProvider\")\n                               ?? GetStringProp(ev, \"ProviderNormalized\");\n\n                // Try to get raw JSON payload from common property names\n                string? rawJson =\n                    GetStringProp(ev, \"RawPayloadJson\") ??\n                    GetStringProp(ev, \"PayloadJson\") ??\n                    TryGetJsonElementText(ev, \"Body\") ??\n                    TryGetJsonElementText(ev, \"RawBody\");\n\n                // If provider missing, use a lightweight sniff (Meta sends \"whatsapp_business_account\")\n                if (string.IsNullOrWhiteSpace(provider) && !string.IsNullOrWhiteSpace(rawJson) &&\n                    rawJson.IndexOf(\"\\\"whatsapp_business_account\\\"\", StringComparison.OrdinalIgnoreCase) >= 0)\n                {\n                    provider = \"META_CLOUD\";\n                }\n\n                // Normalize provider for billing\n                var normalized = NormalizeProvider(provider);\n                if (normalized != \"META_CLOUD\") return; // only forward Meta to billing ingest for now\n\n                if (string.IsNullOrWhiteSpace(rawJson))\n                {\n                    _log.LogDebug(\"Billing forward skipped: no raw payload JSON available on StatusEvent.\");\n                    return;\n                }\n\n                await _billing.IngestFromWebhookAsync(ev.BusinessId, normalized, rawJson);\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Billing ingest (status webhook) failed. businessId={BusinessId}\", ev.BusinessId);\n            }\n        }\n\n        private static string NormalizeProvider(string? provider)\n        {\n            if (string.IsNullOrWhiteSpace(provider)) return \"\";\n            var p = provider.Trim();\n            if (p.Equals(\"META_CLOUD\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            if (p.Equals(\"meta_cloud\", StringComparison.OrdinalIgnoreCase)) return \"META_CLOUD\";\n            return p; // other providers unchanged\n        }\n\n        private static string? GetStringProp(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            return val as string;\n        }\n\n        private static string? TryGetJsonElementText(object obj, string propName)\n        {\n            var pi = obj.GetType().GetProperty(propName, BindingFlags.Public | BindingFlags.Instance | BindingFlags.IgnoreCase);\n            if (pi == null) return null;\n            var val = pi.GetValue(obj);\n            if (val is JsonElement je) return je.GetRawText();\n            return null;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n\n//// üëá make sure this is where your AppDbContext lives\n//using xbytechat.api;\n\n//using xbytechat.api.Features.CampaignTracking.Models; // CampaignSendLog\n//using xbytechat.api.Features.CampaignModule.Models;   // Campaign (nav)\n//using xbytechat.api.CRM.Models;                       // Contact (nav)\n//using xbytechat.api.Features.MessageManagement.DTOs;  // MessageLog\n\n//namespace xbytechat.api.Features.Webhooks.Status\n//{\n//    /// <summary>\n//    /// Idempotent updater touching CampaignSendLogs and MessageLogs using your actual schema.\n//    /// </summary>\n//    public class MessageStatusUpdater : IMessageStatusUpdater\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<MessageStatusUpdater> _log;\n\n//        public MessageStatusUpdater(AppDbContext db, ILogger<MessageStatusUpdater> log)\n//        {\n//            _db = db;\n//            _log = log;\n//        }\n\n//        public async Task UpdateAsync(StatusEvent ev, CancellationToken ct = default)\n//        {\n//            // üîé Guard: we need Business + ProviderMessageId (WAMID) to reconcile reliably\n//            if (ev.BusinessId == Guid.Empty || string.IsNullOrWhiteSpace(ev.ProviderMessageId))\n//            {\n//                _log.LogWarning(\"Status update missing key fields (BusinessId or ProviderMessageId). Skip.\");\n//                return;\n//            }\n\n//            // 1) Pull candidates (scoped to business + WAMID)\n//            var sendLogQ = _db.Set<CampaignSendLog>()\n//                              .AsTracking()\n//                              .Where(s => s.BusinessId == ev.BusinessId && s.MessageId == ev.ProviderMessageId);\n\n//            var msgLogQ = _db.Set<MessageLog>()\n//                             .AsTracking()\n//                             .Where(m => m.BusinessId == ev.BusinessId && m.MessageId == ev.ProviderMessageId);\n\n//            // If caller passed a specific CampaignSendLogId, narrow further\n//            if (ev.CampaignSendLogId is Guid sid)\n//                sendLogQ = sendLogQ.Where(s => s.Id == sid);\n\n//            var sendLog = await sendLogQ.FirstOrDefaultAsync(ct);\n//            var msgLog = await msgLogQ.FirstOrDefaultAsync(ct);\n\n//            // 2) Apply transition (idempotent)\n//            var changed = ApplyTransition(sendLog, msgLog, ev);\n\n//            // 3) Persist only if something actually changed\n//            if (changed > 0)\n//                await _db.SaveChangesAsync(ct);\n//        }\n\n//        /// <summary>Returns number of entities modified.</summary>\n//        private int ApplyTransition(CampaignSendLog? sendLog, MessageLog? msgLog, StatusEvent ev)\n//        {\n//            int modified = 0;\n\n//            // --- CampaignSendLog updates ---\n//            if (sendLog != null)\n//            {\n//                if (!string.Equals(sendLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    sendLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Sent\"))\n//                        {\n//                            sendLog.SendStatus = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (sendLog.SentAt == null || sendLog.SentAt == default)\n//                            sendLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\") &&\n//                            !EqualsIgnoreCase(sendLog.SendStatus, \"Delivered\"))\n//                        {\n//                            sendLog.SendStatus = \"Delivered\";\n//                            modified++;\n//                        }\n//                        if (sendLog.DeliveredAt == null || sendLog.DeliveredAt == default)\n//                            sendLog.DeliveredAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Read\"))\n//                        {\n//                            sendLog.SendStatus = \"Read\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ReadAt == null || sendLog.ReadAt == default)\n//                            sendLog.ReadAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Failed\"))\n//                        {\n//                            sendLog.SendStatus = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (sendLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            sendLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(sendLog.SendStatus, \"Deleted\"))\n//                        {\n//                            sendLog.SendStatus = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            // --- MessageLog updates ---\n//            if (msgLog != null)\n//            {\n//                if (!string.Equals(msgLog.MessageId, ev.ProviderMessageId, StringComparison.Ordinal))\n//                {\n//                    msgLog.MessageId = ev.ProviderMessageId;\n//                    modified++;\n//                }\n\n//                switch (ev.State)\n//                {\n//                    case MessageDeliveryState.Sent:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Sent\"))\n//                        {\n//                            msgLog.Status = \"Sent\";\n//                            modified++;\n//                        }\n//                        if (msgLog.SentAt == null || msgLog.SentAt == default)\n//                            msgLog.SentAt = ev.OccurredAt.UtcDateTime;\n//                        break;\n\n//                    case MessageDeliveryState.Delivered:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\") &&\n//                            !EqualsIgnoreCase(msgLog.Status, \"Delivered\"))\n//                        {\n//                            msgLog.Status = \"Delivered\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Read:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Read\"))\n//                        {\n//                            msgLog.Status = \"Read\";\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Failed:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Failed\"))\n//                        {\n//                            msgLog.Status = \"Failed\";\n//                            modified++;\n//                        }\n//                        if (msgLog.ErrorMessage != ev.ErrorMessage)\n//                        {\n//                            msgLog.ErrorMessage = ev.ErrorMessage;\n//                            modified++;\n//                        }\n//                        break;\n\n//                    case MessageDeliveryState.Deleted:\n//                        if (!EqualsIgnoreCase(msgLog.Status, \"Deleted\"))\n//                        {\n//                            msgLog.Status = \"Deleted\";\n//                            modified++;\n//                        }\n//                        break;\n//                }\n//            }\n\n//            if (sendLog == null && msgLog == null)\n//            {\n//                _log.LogWarning(\"No matching rows for BusinessId={BusinessId}, MessageId={MessageId}, State={State}\",\n//                    ev.BusinessId, ev.ProviderMessageId, ev.State);\n//            }\n\n//            return modified;\n//        }\n\n//        private static bool EqualsIgnoreCase(string? a, string? b) =>\n//            string.Equals(a, b, StringComparison.OrdinalIgnoreCase);\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/Controllers/WhatsAppTemplateController.cs",
      "sha256": "7cee6e94d95a99b2c7b15eb9567b21bea75fb9efd058d6c2a00fba7585616dc8",
      "language": "csharp",
      "size": 2867,
      "content": "\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Configuration;\nusing System.Net.Http;\nusing System.Threading.Tasks;\nusing Newtonsoft.Json;\nusing System.Net.Http.Headers;\nusing Newtonsoft.Json.Linq;\n\nnamespace xbytechat.api.Features.WhatsAppIntegration.Controllers\n{\n    [ApiController]\n    [Route(\"api/whatsapp\")]\n    public class WhatsAppTemplateController : ControllerBase\n    {\n        private readonly IConfiguration _config;\n\n        public WhatsAppTemplateController(IConfiguration config)\n        {\n            _config = config;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetTemplates()\n        {\n            var wabaId = _config[\"WhatsApp:WABA_ID\"];\n            var apiToken = _config[\"WhatsApp:apiToken\"];\n            var url = $\"https://graph.facebook.com/v22.0/{wabaId}/message_templates\";\n\n            using var client = new HttpClient();\n            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", apiToken);\n\n            try\n            {\n                var response = await client.GetAsync(url);\n                var json = await response.Content.ReadAsStringAsync();\n\n                if (!response.IsSuccessStatusCode)\n                    return StatusCode((int)response.StatusCode, new { success = false, error = json });\n\n                var root = JsonConvert.DeserializeObject<JObject>(json);\n                var templatesRaw = root[\"data\"] as JArray;\n\n                if (templatesRaw == null)\n                    return BadRequest(new { success = false, error = \"Meta API did not return data array.\" });\n\n                var templates = new List<object>();\n\n                foreach (var tpl in templatesRaw)\n                {\n                    string name = tpl[\"name\"]?.ToString() ?? \"\";\n                    string language = tpl[\"language\"]?.ToString() ?? \"en_US\";\n\n                    string bodyText = \"\";\n                    var components = tpl[\"components\"] as JArray;\n\n                    if (components != null)\n                    {\n                        foreach (var comp in components)\n                        {\n                            if (comp[\"type\"]?.ToString() == \"BODY\")\n                            {\n                                bodyText = comp[\"text\"]?.ToString() ?? \"\";\n                                break;\n                            }\n                        }\n                    }\n\n                    templates.Add(new\n                    {\n                        name,\n                        language,\n                        body = bodyText\n                    });\n                }\n\n                return Ok(new { success = true, templates });\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, new { success = false, error = ex.Message });\n            }\n        }\n\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/WhatsAppIntegration/DTOs/WhatsAppTemplateDto.cs",
      "sha256": "66133a62d929f35f6f56d4d6c3c9a872e14788627c9645fa41aa6eee13290993",
      "language": "csharp",
      "size": 111,
      "content": "namespace xbytechat.api.Features.WhatsAppIntegration.DTOs\n{\n    public class WhatsAppTemplateDto\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Controllers/LeadTimelineController.cs",
      "sha256": "2bf2b77897c9f322069f976352984cc8a0a0d25514e1e411e2e2393e3ccba3f0",
      "language": "csharp",
      "size": 2028,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.xbTimeline.Services;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class LeadTimelineController : ControllerBase\n    {\n        private readonly ILeadTimelineService _timelineService;\n\n        public LeadTimelineController(ILeadTimelineService timelineService)\n        {\n            _timelineService = timelineService;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> AddTimelineEntry([FromBody] LeadTimelineDto dto)\n        {\n            try\n            {\n                if (!ModelState.IsValid)\n                    return BadRequest(ModelState);\n\n                var result = await _timelineService.AddTimelineEntryAsync(dto);\n\n                Log.Information(\"‚úÖ Timeline entry created for ContactId: {ContactId}\", dto.ContactId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to add timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw;\n            }\n        }\n\n        [HttpGet(\"contact/{contactId}\")]\n        public async Task<IActionResult> GetTimeline(Guid contactId)\n        {\n            try\n            {\n                var timeline = await _timelineService.GetTimelineByContactIdAsync(contactId);\n\n                Log.Information(\"üìÑ Retrieved {Count} entries for ContactId: {ContactId}\", timeline.Count, contactId);\n\n                return Ok(timeline);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to get timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll()\n        {\n            var timelines = await _timelineService.GetAllTimelinesAsync();\n            return Ok(timelines);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CampaignTimelineLogDto.cs",
      "sha256": "b279e39522b2d36effd77fe29c36653ca83b93c6cc9a1281d1ed6b3e596b96e3",
      "language": "csharp",
      "size": 361,
      "content": "public class CampaignTimelineLogDto\n{\n    public Guid ContactId { get; set; }\n    public Guid BusinessId { get; set; }   // ‚úÖ Needed for timeline insertion\n    public Guid CampaignId { get; set; }\n    public string CampaignName { get; set; } = string.Empty; // ‚úÖ Safe default to avoid null issues\n    public DateTime? Timestamp { get; set; } // optional\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/CRMTimelineLogDto.cs",
      "sha256": "e6ce11c00e1130226359d24f7c9da23fe4fc68c6e725c5a449ed10a345378269",
      "language": "csharp",
      "size": 693,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class CRMTimelineLogDto\n    {\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public string EventType { get; set; }  // üß© Example: \"NoteAdded\", \"ReminderSet\", \"TagApplied\"\n        public string Description { get; set; }\n        public Guid? ReferenceId { get; set; }  // üÜî Related NoteId, ReminderId, TagId (optional)\n        public string CreatedBy { get; set; }\n        public string? Category { get; set; } = \"CRM\";  // üìÇ Default category: CRM\n        public DateTime? Timestamp { get; set; }  // ‚è∞ Custom time if needed (else CreatedAt = now)\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/DTOs/LeadTimelineDto.cs",
      "sha256": "b4692f6cebba16abcb7dc7450172517334a4832fce8e02d3c4273da2d001f2c8",
      "language": "csharp",
      "size": 687,
      "content": "using System;\n\nnamespace xbytechat.api.Features.xbTimelines.DTOs\n{\n    public class LeadTimelineDto\n    {\n        public Guid ContactId { get; set; }\n        public string ContactName { get; set; } \n        public string ContactNumber { get; set; } \n        public string EventType { get; set; }\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }\n        public bool IsSystemGenerated { get; set; } = false;\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Mappers/LeadTimelineMapper.cs",
      "sha256": "de301765ab3465a422c99453aab98cf7b40ec5177358642af08c2d5ec36ead4a",
      "language": "csharp",
      "size": 1837,
      "content": "using xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Mappers\n{\n    public static class LeadTimelineMapper\n    {\n        public static LeadTimelineDto ToDto(Models.LeadTimeline entry)\n        {\n            if (entry == null) return null;\n\n            return new LeadTimelineDto\n            {\n                ContactId = entry.ContactId,\n                ContactName = entry.Contact?.Name,                // ‚úÖ Enriched from navigation\n                ContactNumber = entry.Contact?.PhoneNumber,       // ‚úÖ Enriched from navigation\n                EventType = entry.EventType,\n                Description = entry.Description,\n                Data = entry.Data,\n                ReferenceId = entry.ReferenceId,\n                IsSystemGenerated = entry.IsSystemGenerated,\n                CreatedBy = entry.CreatedBy,\n                Source = entry.Source,\n                Category = entry.Category,\n                // ‚úÖ CreatedAt is intentionally excluded from DTO\n            };\n        }\n\n        // Optional for create/update, include only necessary fields\n        public static Models.LeadTimeline ToModel(LeadTimelineDto dto)\n        {\n            if (dto == null) return null;\n\n            return new Models.LeadTimeline\n            {\n                ContactId = dto.ContactId,\n                EventType = dto.EventType,\n                Description = dto.Description,\n                Data = dto.Data,\n                ReferenceId = dto.ReferenceId,\n                IsSystemGenerated = dto.IsSystemGenerated,\n                CreatedBy = dto.CreatedBy,\n                Source = dto.Source,\n                Category = dto.Category,\n                CreatedAt = DateTime.UtcNow // ‚úÖ Always use UTC when creating\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Models/LeadTimeline.cs",
      "sha256": "deaadfd25e7f565dc0456a66a61612baa9aea7a7dc297feca882d2108906413f",
      "language": "csharp",
      "size": 1195,
      "content": "using xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Models\n{\n    public class LeadTimeline\n    {\n        public int Id { get; set; }\n        public Guid ContactId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }  // optional\n\n        public Contact Contact { get; set; } // üÜï Navigation property\n\n        public string EventType { get; set; }\n\n        public string Description { get; set; }\n        public string? Data { get; set; }\n        public Guid? ReferenceId { get; set; }           // ‚úÖ New\n        public bool IsSystemGenerated { get; set; } = false;  // ‚úÖ New\n        public string CreatedBy { get; set; }\n        public string? Source { get; set; }\n        public string? Category { get; set; }\n        public DateTime CreatedAt { get; set; }\n\n        public string? CTAType { get; set; } // e.g., \"BuyNow\", \"PriceCheck\", \"ConfirmReminder\"\n        public string? CTASourceType { get; set; } // e.g., \"catalog\", \"campaign\", \"reminder\"\n        public Guid? CTASourceId { get; set; } // ID of the source object (productId, reminderId)\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ILeadTimelineService.cs",
      "sha256": "4bff375276ef500fcbd0288211c9a8438d983b063537b2995a6fc98a8eba1148",
      "language": "csharp",
      "size": 709,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Catalog.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public interface ILeadTimelineService\n    {\n        Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto);\n        Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId);\n        Task<List<LeadTimelineDto>> GetAllTimelinesAsync();\n        Task AddFromCatalogClickAsync(CatalogClickLog log);\n        Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/ITimelineService.cs",
      "sha256": "3e8a236b7ce0a2af07bc27014910b7fbd77a83c78e8ceebe38c99bab96d183e4",
      "language": "csharp",
      "size": 448,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public interface ITimelineService\n    {\n        // Already existing methods...\n\n        // üÜï CRM related methods\n        Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto);\n        Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto);\n        Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/LeadTimelineService.cs",
      "sha256": "cf0715e549aeb3e6288ceb6cb82177dea0441d9953e64e6aca44f13ed2a19083",
      "language": "csharp",
      "size": 7579,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.xbTimelines.Models;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.Catalog.Models;\nusing static xbytechat.api.Features.BusinessModule.Models.Business;\nusing System.Text.Json;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.PlanManagement.Models;\n\n\nnamespace xbytechat.api.Features.xbTimeline.Services\n{\n    public class LeadTimelineService : ILeadTimelineService\n    {\n        private readonly AppDbContext _context;\n       \n\n        public LeadTimelineService(AppDbContext context )\n        {\n            _context = context;\n        \n        }\n\n        public async Task<LeadTimeline> AddTimelineEntryAsync(LeadTimelineDto dto)\n        {\n            try\n            {\n                var entry = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    EventType = dto.EventType,\n                    Description = dto.Description,\n                    Data = dto.Data,\n                    ReferenceId = dto.ReferenceId,\n                    IsSystemGenerated = dto.IsSystemGenerated,\n                    CreatedBy = dto.CreatedBy,\n                    Source = dto.Source,\n                    Category = dto.Category,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(entry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"‚úÖ Timeline entry added for ContactId: {ContactId}\", dto.ContactId);\n\n                return entry;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error adding timeline entry for ContactId: {ContactId}\", dto.ContactId);\n                throw; // Let global middleware handle this\n            }\n        }\n\n        public async Task<List<LeadTimeline>> GetTimelineByContactIdAsync(Guid contactId)\n        {\n            try\n            {\n                var results = await _context.LeadTimelines\n                    .Where(x => x.ContactId == contactId)\n                    .OrderByDescending(x => x.CreatedAt)\n                    .ToListAsync();\n\n                Log.Information(\"üìÑ Fetched {Count} timeline entries for ContactId: {ContactId}\", results.Count, contactId);\n\n                return results;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch timeline for ContactId: {ContactId}\", contactId);\n                throw;\n            }\n        }\n\n        public async Task<List<LeadTimelineDto>> GetAllTimelinesAsync()\n        {\n            try\n            {\n                var entries = await _context.LeadTimelines\n                    .Include(t => t.Contact) // for Contact Name/Phone\n                    .OrderByDescending(e => e.CreatedAt)\n                    .ToListAsync();\n\n                var dtoList = entries.Select(entry => new LeadTimelineDto\n                {\n                    ContactId = entry.ContactId,\n                    EventType = entry.EventType,\n                    Description = entry.Description,\n                    Data = entry.Data,\n                    ReferenceId = entry.ReferenceId,\n                    CreatedAt = entry.CreatedAt,\n                    CreatedBy = entry.CreatedBy,\n                    Source = entry.Source,\n                    Category = entry.Category,\n                    IsSystemGenerated = entry.IsSystemGenerated,\n                    ContactName = entry.Contact?.Name,\n                    ContactNumber = entry.Contact?.PhoneNumber\n                }).ToList();\n\n                Log.Information(\"üìÑ Loaded {Count} total timeline entries\", dtoList.Count);\n                return dtoList;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Failed to fetch all timeline entries\");\n                throw;\n            }\n        }\n        public async Task AddFromCatalogClickAsync(CatalogClickLog log)\n        {\n            if (log == null)\n            {\n                Log.Warning(\"CatalogClickLog is null. Skipping timeline creation.\");\n                return;\n            }\n\n            try\n            {\n                var business = await _context.Businesses\n                    .AsNoTracking()\n                    .FirstOrDefaultAsync(b => b.Id == log.BusinessId);\n\n                if (business == null)\n                {\n                    Log.Warning(\"Business not found for ID: {BusinessId}. Skipping timeline creation.\", log.BusinessId);\n                    return;\n                }\n\n                // if (business.Plan == PlanType.Advanced)\n                if (business?.BusinessPlanInfo?.Plan == PlanType.Advanced)\n                {\n                    Log.Information(\"Timeline skipped for Basic Plan - BusinessId: {BusinessId}\", business.Id);\n                    return;\n                }\n\n\n                var description = $\"{log.ProductBrowsed} | {log.CTAJourney}\";\n\n                var timelineEntry = new LeadTimeline\n                {\n                    BusinessId = log.BusinessId,\n                    ContactId = log.ContactId ?? Guid.Empty,\n                    EventType = \"CatalogCTA\",\n                    Description = description,\n                    Data = JsonSerializer.Serialize(log),\n                    ReferenceId = null,\n                    CreatedBy = \"system\",\n                    IsSystemGenerated = true,\n                    Source = \"Catalog\",\n                    Category = log.CategoryBrowsed,\n                    CreatedAt = DateTime.UtcNow\n                };\n\n                _context.LeadTimelines.Add(timelineEntry);\n                await _context.SaveChangesAsync();\n\n                Log.Information(\"üìà Timeline entry created from CatalogClick for UserId: {UserId}\", log.UserId);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"‚ùå Error creating timeline entry from CatalogClick for UserId: {UserId}\", log.UserId);\n                // Safe swallow\n            }\n        }\n\n        public async Task<ResponseResult> LogCampaignSendAsync(CampaignTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"CampaignSend\",\n                    Description = $\"Campaign '{dto.CampaignName}' was sent.\", // ‚úÖ Timeline me readable text\n                    ReferenceId = dto.CampaignId, // ‚úÖ Linking to campaign record\n                    IsSystemGenerated = false,    // ‚úÖ Default (campaign sending is manual action)\n                    CreatedBy = \"system\",         // ‚úÖ Or actual user email if needed later\n                    Source = \"CampaignModule\",    // ‚úÖ Source field for clarity\n                    Category = \"Messaging\",       // ‚úÖ Logical grouping\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow // ‚úÖ Use given Timestamp or fallback to now\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n\n                return ResponseResult.SuccessInfo(\"‚úÖ Campaign send event logged into timeline.\");\n            }\n            catch (Exception ex)\n            {\n                return ResponseResult.ErrorInfo(\"‚ùå Failed to log campaign send event: \" + ex.Message);\n            }\n        }\n\n\n    }\n\n\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/xbTimelines/Services/TimelineService.cs",
      "sha256": "34982b110dddb7a0afcac7582aa0c8dfc2d85810317956df389aaf17bd1a0a1f",
      "language": "csharp",
      "size": 3341,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.xbTimelines.DTOs;\nusing xbytechat.api.Features.xbTimelines.Models;\n\nnamespace xbytechat.api.Features.xbTimelines.Services\n{\n    public class TimelineService : ITimelineService\n    {\n        private readonly AppDbContext _context;\n\n        public TimelineService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // üß© Log Note Added into Timeline\n        public async Task<bool> LogNoteAddedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"NoteAdded\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // ‚è∞ Log Reminder Set into Timeline\n        public async Task<bool> LogReminderSetAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"ReminderSet\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        // üè∑Ô∏è Log Tag Applied into Timeline\n        public async Task<bool> LogTagAppliedAsync(CRMTimelineLogDto dto)\n        {\n            try\n            {\n                var timeline = new LeadTimeline\n                {\n                    ContactId = dto.ContactId,\n                    BusinessId = dto.BusinessId,\n                    EventType = \"TagApplied\",\n                    Description = dto.Description,\n                    ReferenceId = dto.ReferenceId,\n                    CreatedBy = dto.CreatedBy,\n                    Source = \"CRM\",\n                    Category = dto.Category ?? \"CRM\",\n                    CreatedAt = dto.Timestamp ?? DateTime.UtcNow,\n                    IsSystemGenerated = false\n                };\n\n                _context.LeadTimelines.Add(timeline);\n                await _context.SaveChangesAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n    }\n}\n"
    }
  ]
}
