{
  "name": "xbytechat-api/Features",
  "part": 1,
  "of": 4,
  "generatedAt": "2025-10-02 10:25:32 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/AccessControl/Attributes/HasPermissionAttribute.cs",
      "sha256": "4c0b87bd0b181823afbcc065a45376dc4c185ec94ae738d09d28afeee757d71d",
      "language": "csharp",
      "size": 3182,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.AspNetCore.Mvc.Filters;\nusing Microsoft.Extensions.DependencyInjection;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Services;\n\nnamespace xbytechat.api.Features.AccessControl.Attributes\n{\n    public class HasPermissionAttribute : Attribute, IAsyncAuthorizationFilter\n    {\n        private readonly string _permissionCode;\n\n        public HasPermissionAttribute(string permissionCode) => _permissionCode = permissionCode;\n\n        public async Task OnAuthorizationAsync(AuthorizationFilterContext context)\n        {\n            var user = context.HttpContext.User;\n            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n            if (string.IsNullOrWhiteSpace(planIdClaim) || !Guid.TryParse(planIdClaim, out var planId))\n            {\n                context.Result = new ForbidResult();\n                return;\n            }\n\n            var permissionService = context.HttpContext.RequestServices\n                .GetRequiredService<IPermissionCacheService>();\n\n            var permissions = await permissionService.GetPlanPermissionsAsync(planId);\n\n            var hasPermission = permissions.Any(p =>\n                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n            if (!hasPermission)\n                context.Result = new ForbidResult();\n        }\n    }\n}\n\n\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.AspNetCore.Mvc.Filters;\n//using Microsoft.Extensions.DependencyInjection;\n//using System;\n//using System.Linq;\n//using xbytechat.api.Features.AccessControl.Services;\n\n//namespace xbytechat.api.Features.AccessControl.Attributes\n//{\n//    public class HasPermissionAttribute : Attribute, IAuthorizationFilter\n//    {\n//        private readonly string _permissionCode;\n\n//        public HasPermissionAttribute(string permissionCode)\n//        {\n//            _permissionCode = permissionCode;\n//        }\n\n//        public void OnAuthorization(AuthorizationFilterContext context)\n//        {\n//            var user = context.HttpContext.User;\n//            var planIdClaim = user.FindFirst(\"plan_id\")?.Value;\n\n//            if (string.IsNullOrEmpty(planIdClaim))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            if (!Guid.TryParse(planIdClaim, out var planId))\n//            {\n//                context.Result = new ForbidResult();\n//                return;\n//            }\n\n//            var permissionService = context.HttpContext.RequestServices\n//                .GetRequiredService<IPermissionCacheService>();\n\n//            // Get permissions for this plan from cache\n//            var permissions = permissionService.GetPlanPermissionsAsync(planId).Result;\n\n//            // Check if any permission matches the requested code\n//            bool hasPermission = permissions.Any(p =>\n//                string.Equals(p.Code, _permissionCode, StringComparison.OrdinalIgnoreCase));\n\n//            if (!hasPermission)\n//            {\n//                context.Result = new ForbidResult();\n//            }\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PermissionController.cs",
      "sha256": "4e0bbb5ef2b9078ac41349c7c36d74c2d0e9211af908bc1adaef72f85e811e6d",
      "language": "csharp",
      "size": 917,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing System.Security;\nusing xbytechat.api.CRM.Services;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n\n    [ApiController]\n    [Route(\"api/permission\")]\n    [Authorize]\n    public class PermissionController : Controller\n    {\n\n        private readonly IPermissionService _permissionService;\n        public PermissionController(IPermissionService permissionService)\n        {\n            _permissionService = permissionService;    \n        }\n        [HttpGet(\"Grouped\")]\n        public async Task<IActionResult> GetGroupedPermissions()\n        {\n            var grouped = await _permissionService.GetGroupedPermissionsAsync();\n            return Ok(ResponseResult.SuccessInfo(\"Permissions grouped by category\", grouped));\n        }\n\n       \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Controllers/PlanController.cs",
      "sha256": "0cd255134e9dc41e6389e01e51036572a7010a710fd0752df31649ec7533438b",
      "language": "csharp",
      "size": 7083,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Services;\nusing xbytechat.api.Helpers; // ✅ For ResponseResult\n\nnamespace xbytechat.api.Features.AccessControl.Controllers\n{\n    [Route(\"api/[controller]\")]\n    [ApiController]\n    [Authorize]\n    public class PlanController : ControllerBase\n    {\n        private readonly IPlanService _planService;\n        private readonly IPermissionCacheService _permissionCacheService;\n        private readonly ILogger<PlanController> _logger;\n        public PlanController(IPlanService planService, IPermissionCacheService permissionCacheService, ILogger<PlanController> logger)\n        {\n            _planService = planService;\n            _permissionCacheService = permissionCacheService;\n            _logger = logger;\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetPlans()\n        {\n            try\n            {\n                var plans = await _planService.GetAllPlansAsync();\n                return Ok(plans); // Return plain array\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load plans\");\n                return BadRequest(new { message = \"Failed to load plans\", error = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{planId}/permissions\")]\n        public async Task<IActionResult> GetPlanPermissions(Guid planId)\n        {\n            try\n            {\n               // var permissions = await _planService.GetPermissionsForPlanAsync(planId);\n                var permissions = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n\n                return Ok(permissions);\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to load permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to load permissions\", error = ex.Message });\n            }\n        }\n\n        [HttpPost(\"{planId}/permissions\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlanPermissions(Guid planId, [FromBody] Guid[] permissionIds)\n        {\n            try\n            {\n                await _planService.UpdatePlanPermissionsAsync(planId, permissionIds.ToList());\n                // ✅ Clear cache after update\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Permissions updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update permissions for plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update permissions\", error = ex.Message });\n            }\n        }\n\n        [HttpPost(\"Create\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> CreatePlan([FromBody] CreatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var newPlanId = await _planService.CreatePlanAsync(dto);\n                return Ok(new { id = newPlanId, message = \"Plan created successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to create plan {PlanName}\", dto.Name);\n                return BadRequest(new { message = \"Failed to create plan\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> UpdatePlan(Guid planId, [FromBody] UpdatePlanDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Code) || string.IsNullOrWhiteSpace(dto.Name))\n                return BadRequest(new { message = \"Code and Name are required\" });\n\n            try\n            {\n                var updated = await _planService.UpdatePlanAsync(planId, dto);\n                if (!updated)\n                    return NotFound(new { message = \"Plan not found\" });\n\n                return Ok(new { message = \"Plan updated successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to update plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to update plan\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{planId}\")]\n        [Authorize(Roles = \"superadmin,partneradmin,admin\")]\n        public async Task<IActionResult> DeletePlan(Guid planId)\n        {\n            try\n            {\n                var deleted = await _planService.DeletePlanAsync(planId);\n                if (!deleted)\n                    return NotFound(new { message = \"Plan not found or already inactive\" });\n                // ✅ Clear cache when plan is deleted\n                _permissionCacheService.ClearPlanPermissionsCache(planId);\n                return Ok(new { message = \"Plan deleted successfully\" });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Failed to delete plan {PlanId}\", planId);\n                return BadRequest(new { message = \"Failed to delete plan\", error = ex.Message });\n            }\n        }\n      \n        [HttpGet(\"me/permissions\")]\n        public async Task<IActionResult> GetMyPlanPermissions(CancellationToken ct)\n        {\n            var role = User.FindFirst(\"role\")?.Value ?? string.Empty;\n\n            // Admin-like roles don't need a plan\n            if (role is \"superadmin\" or \"admin\" or \"partner\" or \"reseller\")\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = new[] { \"*\" }\n                });\n\n            var planIdStr = User.FindFirst(\"plan_id\")?.Value;\n            if (!Guid.TryParse(planIdStr, out var planId))\n                return Ok(new\n                {\n                    planId = (Guid?)null,\n                    plan = (PlanDto?)null,\n                    permissions = Array.Empty<string>()\n                });\n\n            // permissions (cached)\n            var permissionEntities = await _permissionCacheService.GetPlanPermissionsAsync(planId);\n            var codes = permissionEntities\n                .Where(p => p.IsActive)\n                .Select(p => p.Code)\n                .Distinct()\n                .ToList();\n\n            // ✅ Fetch the plan once and return it as PlanDto\n            var planDto = await _planService.GetByIdAsync(planId, ct);\n\n            return Ok(new\n            {\n                planId,\n                plan = planDto,     // PlanDto or null\n                permissions = codes\n            });\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/CreatePlanDto.cs",
      "sha256": "15d5b4b092dc0019db6a3e33fc6ea49a5bd2e02c9c4fabde02403dc9c32feb90",
      "language": "csharp",
      "size": 320,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class CreatePlanDto\n    {\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\"\n        public string Name { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/GroupedPermissionDto.cs",
      "sha256": "d31e43145b8ed5908bd705af1dc96740d163615a183c30dc69b6d72097d37a76",
      "language": "csharp",
      "size": 255,
      "content": "using xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class GroupedPermissionDto\n    {\n        public string Group { get; set; }\n        public List<Permission> Features { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PermissionDto.cs",
      "sha256": "46bfdeaa2a7dfa7bdaa56ed6c991868bae5fcc8ffb88cff1cc82d329e51eb92f",
      "language": "csharp",
      "size": 353,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PermissionDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string? Group { get; set; }\n        public string? Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/PlanDto.cs",
      "sha256": "87bcc89fbc963d131fcc246a1bde5d2d1a9198a61fac73a55b6b985644c8ee89",
      "language": "csharp",
      "size": 303,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class PlanDto\n    {\n        public Guid Id { get; set; }\n        public string Code { get; set; }\n        public string Name { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/RoleDto.cs",
      "sha256": "890bec8d90e7068a2c8e49c4249b761506cdb9c26b2fd5a470bf14c6013954cf",
      "language": "csharp",
      "size": 479,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs;\n\n// DTO: Role details used across layers\npublic class RoleDto\n{\n    /// <summary>Unique identifier of the role.</summary>\n    public Guid Id { get; set; }\n\n   \n    public string Role { get; set; } = default!;\n\n   \n    public string Code { get; set; } = default!;\n\n   \n    public string? Description { get; set; }\n\n    \n    public bool IsActive { get; set; }\n\n       public RoleDto() { }\n\n    // Convenience constructor\n    \n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanDto.cs",
      "sha256": "e4a09d8fd1c1ff0cb720be4ff2ba80df60e06fc54795e1e2a23fd06b16bf8956",
      "language": "csharp",
      "size": 273,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanDto\n    {\n        public string Name { get; set; }\n        public string Code { get; set; }\n        public string Description { get; set; }\n        public bool IsActive { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdatePlanPermissionsRequest.cs",
      "sha256": "b62abd8813b7a4d3812bc8260d06a3770d0a34c9141d845d60ff86cf904a3378",
      "language": "csharp",
      "size": 168,
      "content": "namespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdatePlanPermissionsRequest\n    {\n        public List<Guid> PermissionIds { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/DTOs/UpdateRolePermissionsDto.cs",
      "sha256": "e00530db11a422793d96b8905211218a03a8e810c601034c76b75fbba37d40db",
      "language": "csharp",
      "size": 291,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AccessControl.DTOs\n{\n    public class UpdateRolePermissionsDto\n    {\n        [Required]\n        public List<Guid> PermissionIds { get; set; } = new();\n        public bool ReplaceAll { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Permission.cs",
      "sha256": "22c58f1f832014c6129b075f027045a186874bc7c20d0f312befe1d658bb0ab4",
      "language": "csharp",
      "size": 832,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Permission\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // Unique key like \"ViewDashboard\"\n\n        public string Name { get; set; } // Friendly name like \"View Dashboard\"\n\n        public string? Group { get; set; } // Optional grouping, e.g., \"CRM\", \"Catalog\", \"Admin\"\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n\n        public ICollection<UserPermission> UserPermissions { get; set; }\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Plan.cs",
      "sha256": "1682d96ed57c73cf2dce0b4b7194becc04837f998e9f0718b14e8a2b5ff8c5a6",
      "language": "csharp",
      "size": 704,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.BusinessModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Plan\n    {\n        public Guid Id { get; set; }\n\n        public string Code { get; set; } // e.g. \"FREE\", \"SMART\", \"ADVANCED\"\n        public string Name { get; set; } // Friendly display name\n\n        public string? Description { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<PlanPermission> PlanPermissions { get; set; }\n        public ICollection<Business> Businesses { get; set; } = new List<Business>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/PlanPermission.cs",
      "sha256": "e6e65f0ae33c19e9d2585d73812bcf99ed207d52ac6d804a3c2bf86b3152eca7",
      "language": "csharp",
      "size": 525,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class PlanPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid PlanId { get; set; }\n        public Plan Plan { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin email or ID\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/Role.cs",
      "sha256": "4c2e237e65d702febee355976cfc64209fd4cf2d98f87e7ef6de4b199dd048a4",
      "language": "csharp",
      "size": 760,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class Role\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; } // e.g. SuperAdmin, PartnerAdmin, BusinessAdmin, Staff, etc.\n\n        public string? Description { get; set; }\n\n        public bool IsSystemDefined { get; set; } = false; // true for SuperAdmin, PartnerAdmin\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public ICollection<RolePermission> RolePermissions { get; set; }\n        public ICollection<User> Users { get; set; } // 🧩 One-to-many relation: Role → Users\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/RolePermission.cs",
      "sha256": "d9b31669bec3fbda1b95c89def9a6cc641e0dd21f5e38583b8dae4c0239b9a8a",
      "language": "csharp",
      "size": 619,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class RolePermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid RoleId { get; set; }\n        public Role Role { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin user email or ID\n\n        public bool IsActive { get; set; } = true; // ✅ Add this line\n        public bool IsRevoked { get; set; } = false; // ✅ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Models/UserPermission.cs",
      "sha256": "6b85321ec68fced21477222e85ac56594106c4654b5d99061c42bc1c46d876aa",
      "language": "csharp",
      "size": 677,
      "content": "using System;\nusing xbytechat.api.AuthModule.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Models\n{\n    public class UserPermission\n    {\n        public Guid Id { get; set; }\n\n        public Guid UserId { get; set; }\n        public User User { get; set; }\n\n        public Guid PermissionId { get; set; }\n        public Permission Permission { get; set; }\n\n        public bool IsGranted { get; set; } = true; // ✅ true = allow, false = explicitly deny\n\n        public DateTime AssignedAt { get; set; } = DateTime.UtcNow;\n        public string? AssignedBy { get; set; } // Admin or system\n\n        public bool IsRevoked { get; set; } = false; // ✅ Required\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/PermissionConstants.cs",
      "sha256": "47104d91bf08a96917121e247b83aac03fe402f24bb851d3fa4b1b9ee5375469",
      "language": "csharp",
      "size": 1126,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class PermissionConstants\n    {\n        public static class Dashboard\n        {\n            public const string View = \"dashboard.view\";\n        }\n\n        public static class Campaigns\n        {\n            public const string View = \"campaign.view\";\n            public const string Create = \"campaign.create\";\n            public const string Delete = \"campaign.delete\";\n        }\n\n        public static class Products\n        {\n            public const string View = \"product.view\";\n            public const string Create = \"product.create\";\n            public const string Delete = \"product.delete\";\n        }\n\n        public static class CRM\n        {\n            public const string ContactsView = \"contacts.view\";\n            public const string TagsEdit = \"tags.edit\";\n        }\n\n        public static class Admin\n        {\n            public const string BusinessApprove = \"admin.business.approve\";\n            public const string ViewLogs = \"admin.logs.view\";\n        }\n\n        // 🆕 Add more modules and permissions here as needed\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Seeder/RolePermissionMapping.cs",
      "sha256": "47f001a1b2d6404c28e73be68faf79485c10c1c0a7dab0a5346cc06fff4f049a",
      "language": "csharp",
      "size": 1302,
      "content": "namespace xbytechat.api.Features.AccessControl.Seeder\n{\n    public static class RolePermissionMapping\n    {\n        public static readonly Dictionary<string, List<string>> RolePermissions = new()\n        {\n            [\"admin\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.Campaigns.Create,\n                PermissionConstants.Campaigns.Delete,\n                PermissionConstants.Products.View,\n                PermissionConstants.Products.Create,\n                PermissionConstants.Products.Delete,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.CRM.TagsEdit,\n                PermissionConstants.Admin.BusinessApprove,\n                PermissionConstants.Admin.ViewLogs\n            },\n\n            [\"business\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.Campaigns.View,\n                PermissionConstants.CRM.ContactsView,\n                PermissionConstants.Products.View\n            },\n\n            [\"staff\"] = new()\n            {\n                PermissionConstants.Dashboard.View,\n                PermissionConstants.CRM.ContactsView\n            }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/AccessControlService.cs",
      "sha256": "7715aa1fb932cf63407c3a5e5502b6c3f751e331055be04257cfd120a8671fcb",
      "language": "csharp",
      "size": 7685,
      "content": "//using Microsoft.EntityFrameworkCore;\n//using System.Collections.Generic;\n//using System.Security.Claims;\n//using System.Threading.Tasks;\n\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public class AccessControlService : IAccessControlService\n//    {\n//        private readonly AppDbContext _context;\n\n//        public AccessControlService(AppDbContext context)\n//        {\n//            _context = context;\n//        }\n\n//        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n//        {\n//            return await _context.Permissions\n//                .AsNoTracking()\n//                .Where(p => p.IsActive)\n//                .ToListAsync();\n//        }\n//        //public async Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId)\n//        //{\n//        //    // First, check if the user has direct permissions\n//        //    var userPermissions = await _context.UserPermissions\n//        //        .Where(up => up.UserId == userId && up.IsGranted && !up.IsRevoked)\n//        //        .Select(up => up.Permission)\n//        //        .Where(p => p.IsActive)\n//        //        .ToListAsync();\n\n//        //    // If no direct permissions, fall back to role permissions\n//        //    if (!userPermissions.Any())\n//        //    {\n//        //        userPermissions = await _context.RolePermissions\n//        //            .Where(rp => rp.Role.Users.Any(u => u.Id == userId) && rp.IsActive && !rp.IsRevoked)\n//        //            .Select(rp => rp.Permission)\n//        //            .Where(p => p.IsActive)\n//        //            .ToListAsync();\n//        //    }\n\n//        //    return userPermissions;\n//        //}\n       \n        \n       \n//    }\n//}\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Repositories.Interfaces;\nusing System.Linq.Expressions;\n\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class AccessControlService : IAccessControlService\n    {\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<RolePermission> _rolePermissionRepo;\n        private readonly IGenericRepository<UserPermission> _userPermissionRepo;\n        private readonly IGenericRepository<Permission> _permissionRepo;\n        private readonly AppDbContext _context;\n        public AccessControlService(\n            IGenericRepository<User> userRepo,\n            IGenericRepository<RolePermission> rolePermissionRepo,\n            IGenericRepository<UserPermission> userPermissionRepo,\n            IGenericRepository<Permission> permissionRepo, AppDbContext context\n        )\n        {\n            _userRepo = userRepo;\n            _rolePermissionRepo = rolePermissionRepo;\n            _userPermissionRepo = userPermissionRepo;\n            _permissionRepo = permissionRepo;\n            _context = context;\n        }\n\n        /// <summary>\n        /// ✅ Fetch all permissions (Role-based + User-specific) for a given user\n        /// </summary>\n        //public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        //{\n        //    var user = await _userRepo.FindByIdAsync(userId);\n        //    if (user == null || user.RoleId == null)\n        //        return new List<string>();\n\n        //    // 🔐 Get Role-based permissions\n        //    var rolePerms = await _rolePermissionRepo\n        //        .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n        //    // 🔐 Get User-specific extra permissions\n        //    var userPerms = await _userPermissionRepo\n        //        .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n        //    // 🧠 Merge permission IDs\n        //    var permissionIds = rolePerms.Select(r => r.PermissionId)\n        //        .Union(userPerms.Select(u => u.PermissionId))\n        //        .Distinct()\n        //        .ToList();\n\n        //    // 🎯 Get full permission names from Permission table\n        //    var allPerms = await _permissionRepo\n        //        .WhereAsync(p => permissionIds.Contains(p.Id));\n\n        //    return allPerms.Select(p => p.Code).Distinct().ToList(); // Use Code (standard)\n        //}\n\n        public async Task<IEnumerable<Permission>> GetAllPermissionsAsync()\n        {\n            return await _permissionRepo.WhereAsync(p => p.IsActive);\n        }\n\n\n        public async Task<List<string>> GetPermissionsAsync(Guid userId)\n        {\n            var user = await _userRepo.FindByIdAsync(userId);\n\n            if (user == null || user.RoleId == null)\n                return new List<string>();\n\n            // 🚀 Bypass: SuperAdmin always gets full access\n            if (user.Role != null && user.Role.Name.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n            {\n                var allPerms = await _permissionRepo.GetAllAsync();\n                return allPerms.Select(p => p.Code).Distinct().ToList();\n            }\n\n            // 🔐 Get Role-based permissions\n            var rolePerms = await _rolePermissionRepo\n                .WhereAsync(rp => rp.RoleId == user.RoleId && !rp.IsRevoked);\n\n            // 🔐 Get User-specific extra permissions\n            var userPerms = await _userPermissionRepo\n                .WhereAsync(up => up.UserId == userId && !up.IsRevoked);\n\n            // 🧠 Merge permission IDs\n            var permissionIds = rolePerms.Select(r => r.PermissionId)\n                .Union(userPerms.Select(u => u.PermissionId))\n                .Distinct()\n                .ToList();\n\n            // 🎯 Get full permission names from Permission table\n            var allAllowedPerms = await _permissionRepo\n                .WhereAsync(p => permissionIds.Contains(p.Id));\n\n            return allAllowedPerms.Select(p => p.Code).Distinct().ToList();\n        }\n\n        public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        {\n            // 🚀 Bypass: SuperAdmin always passes\n            //var roleClaim = user.Claims.FirstOrDefault(c => c.Type == ClaimTypes.Role)?.Value;\n            var roleClaim = user.Claims.FirstOrDefault(c =>\n                c.Type == ClaimTypes.Role || c.Type.Equals(\"role\", StringComparison.OrdinalIgnoreCase)\n            )?.Value;\n\n            if (!string.IsNullOrEmpty(roleClaim) && roleClaim.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase))\n                return true;\n\n            var perms = user.Claims\n                .Where(c => c.Type == \"permissions\")\n                .Select(c => c.Value)\n                .ToList();\n\n            return perms.Contains(requiredPermission);\n        }\n\n        /// <summary>\n        /// ✅ Runtime permission checker (for controller/middleware)\n        /// </summary>\n        //public bool HasPermission(ClaimsPrincipal user, string requiredPermission)\n        //{\n        //    var perms = user.Claims\n        //        .Where(c => c.Type == \"permissions\")\n        //        .Select(c => c.Value)\n        //        .ToList();\n\n        //    return perms.Contains(requiredPermission);\n        //}\n\n        public async Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId)\n        {\n            if (!planId.HasValue)\n                return new List<string>();\n\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId.Value && pp.IsActive)\n                .Select(pp => pp.Permission.Code)\n                .ToListAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IAccessControlService.cs",
      "sha256": "a7175ca2ec5d8ac4aae9b09095d675ab36d2c52dd6a62b3d23c6b6990de055e2",
      "language": "csharp",
      "size": 853,
      "content": "//using System.Collections.Generic;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.AccessControl.Models;\n\n//namespace xbytechat.api.Features.AccessControl.Services\n//{\n//    public interface IAccessControlService\n//    {\n//        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n//        Task<IEnumerable<Permission>> GetPermissionsAsync(Guid userId);\n\n//    }\n//}\n\n\nusing System.Security.Claims;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IAccessControlService\n    {\n        Task<List<string>> GetPermissionsAsync(Guid userId);\n        bool HasPermission(ClaimsPrincipal user, string permission);\n        Task<IEnumerable<Permission>> GetAllPermissionsAsync();\n        Task<List<string>> GetPermissionsByPlanIdAsync(Guid? planId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/IPlanService.cs",
      "sha256": "7e943cbf0f9f97ecaac03b05ae94b28c8cf649813e1c6d4dd1e7246b3bdc0cf1",
      "language": "csharp",
      "size": 952,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPlanService\n    {\n        Task<IEnumerable<PlanDto>> GetAllPlansAsync();\n        Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId);\n       // Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n        Task<Guid> CreatePlanAsync(CreatePlanDto dto);\n        Task<bool> DeletePlanAsync(Guid planId);\n        Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto);\n\n        // New methods for permissions\n        Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId);\n        Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds);\n\n        Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default);\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PermissionCacheService.cs",
      "sha256": "c268071425295dc74c3f7323b4ebcbc3f413d9eaea473b6b55ada75cc0117ea9",
      "language": "csharp",
      "size": 1696,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Caching.Memory;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public interface IPermissionCacheService\n    {\n        Task<List<Permission>> GetPlanPermissionsAsync(Guid planId);\n        void ClearPlanPermissionsCache(Guid planId);\n    }\n\n    public class PermissionCacheService : IPermissionCacheService\n    {\n        private readonly AppDbContext _context;\n        private readonly IMemoryCache _cache;\n        private const string CacheKeyPrefix = \"plan_permissions_\";\n\n        public PermissionCacheService(AppDbContext context, IMemoryCache cache)\n        {\n            _context = context;\n            _cache = cache;\n        }\n\n        public async Task<List<Permission>> GetPlanPermissionsAsync(Guid planId)\n        {\n            var cacheKey = $\"{CacheKeyPrefix}{planId}\";\n\n            // Try to get from cache\n            if (_cache.TryGetValue(cacheKey, out List<Permission> cachedPermissions))\n                return cachedPermissions;\n\n            // Fetch from DB\n            var permissions = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => pp.Permission)\n                .ToListAsync();\n\n            // Store in cache\n            _cache.Set(cacheKey, permissions, TimeSpan.FromHours(1));\n\n            return permissions;\n        }\n\n        public void ClearPlanPermissionsCache(Guid planId)\n        {\n            _cache.Remove($\"{CacheKeyPrefix}{planId}\");\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AccessControl/Services/PlanService.cs",
      "sha256": "1b989e01aca4efc37b99ca089369e468ba7ba452768d72b3b85ea7bae8769f9b",
      "language": "csharp",
      "size": 9530,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AccessControl.DTOs;\nusing xbytechat.api.Features.AccessControl.Models;\n\nnamespace xbytechat.api.Features.AccessControl.Services\n{\n    public class PlanService : IPlanService\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<PlanService> _logger;\n        private readonly IPermissionCacheService _permissionCacheService;\n\n        public PlanService(AppDbContext context, ILogger<PlanService> logger, IPermissionCacheService permissionCacheService)\n        {\n            _context = context;\n            _logger = logger;\n            _permissionCacheService = permissionCacheService;\n        }\n\n        //public async Task<IEnumerable<Plan>> GetAllPlansAsync()\n        //{\n        //    _logger.LogInformation(\"Fetching all active plans...\");\n        //    try\n        //    {\n        //        return await _context.Plans\n        //            .AsNoTracking()\n        //            .Include(p => p.PlanPermissions)\n        //            .Where(p => p.IsActive)\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching plans.\");\n        //        throw;\n        //    }\n        //}\n        public async Task<IEnumerable<PlanDto>> GetAllPlansAsync()\n        {\n            return await _context.Plans\n                .Where(p => p.IsActive)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<IEnumerable<PermissionDto>> GetPermissionsForPlanAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description,\n                    IsActive = pp.Permission.IsActive\n                })\n                .ToListAsync();\n        }\n        public async Task<PlanDto?> GetByIdAsync(Guid planId, CancellationToken ct = default)\n        {\n            return await _context.Plans\n                .AsNoTracking()\n                .Where(p => p.Id == planId)\n                .Select(p => new PlanDto\n                {\n                    Id = p.Id,\n                    Code = p.Code,\n                    Name = p.Name,\n                    Description = p.Description,\n                    IsActive = p.IsActive\n                })\n                .FirstOrDefaultAsync(ct);\n        }\n\n        //public async Task<IEnumerable<Permission>> GetPermissionsForPlanAsync(Guid planId)\n        //{\n        //    _logger.LogInformation(\"Fetching permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        return await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId && pp.IsActive)\n        //            .Include(pp => pp.Permission)\n        //            .Select(pp => pp.Permission)\n        //            .AsNoTracking()\n        //            .ToListAsync();\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error fetching permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        //public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        //{\n        //    _logger.LogInformation(\"Updating permissions for plan {PlanId}\", planId);\n        //    try\n        //    {\n        //        // Remove all existing permissions for the plan\n        //        var existing = await _context.PlanPermissions\n        //            .Where(pp => pp.PlanId == planId)\n        //            .ToListAsync();\n\n        //        _context.PlanPermissions.RemoveRange(existing);\n\n        //        // Add new permissions\n        //        var newPlanPermissions = permissionIds.Select(pid => new PlanPermission\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            PlanId = planId,\n        //            PermissionId = pid,\n        //            IsActive = true,\n        //            AssignedAt = DateTime.UtcNow,\n        //            AssignedBy = \"System\"\n        //        });\n\n        //        await _context.PlanPermissions.AddRangeAsync(newPlanPermissions);\n        //        await _context.SaveChangesAsync();\n        //        _logger.LogInformation(\"Permissions updated for plan {PlanId}\", planId);\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        _logger.LogError(ex, \"Error updating permissions for plan {PlanId}\", planId);\n        //        throw;\n        //    }\n        //}\n\n        public async Task<Guid> CreatePlanAsync(CreatePlanDto dto)\n        {\n            _logger.LogInformation(\"Creating new plan: {PlanName}\", dto.Name);\n            try\n            {\n                var plan = new Plan\n                {\n                    Id = Guid.NewGuid(),\n                    Code = dto.Code,\n                    Name = dto.Name,\n                    Description = dto.Description,\n                    IsActive = dto.IsActive\n                };\n\n                _context.Plans.Add(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan created with ID: {PlanId}\", plan.Id);\n                return plan.Id;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error creating plan {PlanName}\", dto.Name);\n                throw;\n            }\n        }\n\n        public async Task<bool> DeletePlanAsync(Guid planId)\n        {\n            _logger.LogInformation(\"Deleting (soft) plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null || !plan.IsActive)\n                {\n                    _logger.LogWarning(\"Plan not found or already inactive: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.IsActive = false;\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} soft deleted.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error deleting plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task<bool> UpdatePlanAsync(Guid planId, UpdatePlanDto dto)\n        {\n            _logger.LogInformation(\"Updating plan {PlanId}\", planId);\n            try\n            {\n                var plan = await _context.Plans.FirstOrDefaultAsync(p => p.Id == planId);\n                if (plan == null)\n                {\n                    _logger.LogWarning(\"Plan not found: {PlanId}\", planId);\n                    return false;\n                }\n\n                plan.Code = dto.Code;\n                plan.Name = dto.Name;\n                plan.Description = dto.Description;\n                plan.IsActive = dto.IsActive;\n\n                _context.Plans.Update(plan);\n                await _context.SaveChangesAsync();\n\n                _logger.LogInformation(\"Plan {PlanId} updated successfully.\", planId);\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"Error updating plan {PlanId}\", planId);\n                throw;\n            }\n        }\n\n        public async Task UpdatePlanPermissionsAsync(Guid planId, List<Guid> permissionIds)\n        {\n            // Remove old mappings\n            var existing = await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId)\n                .ToListAsync();\n            _context.PlanPermissions.RemoveRange(existing);\n\n            // Add new mappings\n            var newMappings = permissionIds.Select(pid => new PlanPermission\n            {\n                PlanId = planId,\n                PermissionId = pid,\n                AssignedAt = DateTime.UtcNow,\n                AssignedBy = \"system\" // replace with logged-in admin\n            });\n\n            await _context.PlanPermissions.AddRangeAsync(newMappings);\n            await _context.SaveChangesAsync();\n            //// Clear cache\n            _permissionCacheService.ClearPlanPermissionsCache(planId);\n        }\n        public async Task<List<PermissionDto>> GetPlanPermissionsAsync(Guid planId)\n        {\n            return await _context.PlanPermissions\n                .Where(pp => pp.PlanId == planId && pp.IsActive)\n                .Select(pp => new PermissionDto\n                {\n                    Id = pp.Permission.Id,\n                    Code = pp.Permission.Code,\n                    Name = pp.Permission.Name,\n                    Group = pp.Permission.Group,\n                    Description = pp.Permission.Description\n                })\n                .ToListAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceController.cs",
      "sha256": "36755710674031902cf3133a3308170d732b23a2eb5cc6c6dcba17589b8fec7e",
      "language": "csharp",
      "size": 2865,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences\")]\n    [Authorize]\n    public class AudienceController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly IAudienceService _svc;\n\n        public AudienceController(AppDbContext db, IAudienceService svc)\n        { _db = db; _svc = svc; }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] AudienceCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            if (string.IsNullOrWhiteSpace(dto?.Name))\n                return BadRequest(new { success = false, message = \"Name is required\" });\n\n            var id = await _svc.CreateAsync(businessId, dto!, userName);\n            return Ok(new { success = true, id });\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> List()\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var items = await _svc.ListAsync(businessId);\n            return Ok(new { success = true, items });\n        }\n\n        [HttpPost(\"{audienceId:guid}/assign\")]\n        public async Task<IActionResult> Assign(Guid audienceId, [FromBody] AudienceAssignDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var ok = await _svc.AssignAsync(businessId, audienceId, dto ?? new AudienceAssignDto(), userName);\n            return Ok(new { success = ok });\n        }\n\n        [HttpGet(\"{audienceId:guid}/members\")]\n        public async Task<IActionResult> Members(Guid audienceId, [FromQuery] int page = 1, [FromQuery] int pageSize = 50)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Audiences.AnyAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n            if (!exists) return NotFound(new { success = false, message = \"Audience not found\" });\n\n            var rows = await _svc.GetMembersAsync(businessId, audienceId, page, pageSize);\n            return Ok(new { success = true, items = rows, page, pageSize });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Controllers/AudienceImportController.cs",
      "sha256": "3b83d236a62b4def34dc67cda4f095665cdc144985151dd97565eb8de142268d",
      "language": "csharp",
      "size": 1639,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Audiences.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.Audiences.Controllers\n{\n    [ApiController]\n    [Route(\"api/audiences/import\")]\n    [Authorize]\n    public class AudienceImportController : ControllerBase\n    {\n        private readonly IAudienceImportService _svc;\n\n        public AudienceImportController(IAudienceImportService svc)\n        {\n            _svc = svc;\n        }\n\n        //[HttpPost(\"csv\")]\n        //[RequestSizeLimit(64_000_000)] // 64 MB\n        //public async Task<IActionResult> ImportCsv([FromForm] IFormFile file)\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    if (businessId == Guid.Empty) return Unauthorized();\n\n        //    if (file == null || file.Length == 0)\n        //        return BadRequest(new { success = false, message = \"CSV file is required\" });\n\n        //    try\n        //    {\n        //        await using var stream = file.OpenReadStream();\n        //        var resp = await _svc.ImportCsvAsync(businessId, stream, file.FileName, HttpContext.RequestAborted);\n\n        //        return Ok(new { success = true, data = resp });\n        //    }\n        //    catch (Exception ex)\n        //    {\n        //        Log.Error(ex, \"❌ CSV import failed | biz={Biz}\", businessId);\n        //        return StatusCode(500, new { success = false, message = \"CSV import failed\" });\n        //    }\n        //}\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/AudienceDtos.cs",
      "sha256": "36380702ffe3286aab70c4f45799ef8fc330b26eb9eae08190a307598ade1aa7",
      "language": "csharp",
      "size": 1198,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class AudienceCreateDto\n    {\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n    }\n\n    public class AudienceSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = \"\";\n        public string? Description { get; set; }\n        public int MemberCount { get; set; }\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceMemberDto\n    {\n        public Guid Id { get; set; }\n        public Guid? ContactId { get; set; }   // optional link to CRM contact\n        public string? Name { get; set; }\n        public string? PhoneNumber { get; set; }\n        public string? Email { get; set; }\n        public string? VariablesJson { get; set; } // if your model stores row-level vars\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class AudienceAssignDto\n    {\n        public List<Guid> ContactIds { get; set; } = new(); // optional: assign CRM contacts\n        public Guid? CsvBatchId { get; set; }               // optional: attach CSV batch to audience\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/DTOs/CsvImportDtos.cs",
      "sha256": "c93d41ac64223fad52cd0ce3cb909af0347cac1e44b642fcdc9139c013b1ba73",
      "language": "csharp",
      "size": 342,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Audiences.DTOs\n{\n    public class CsvImportResponseDto\n    {\n        public Guid BatchId { get; set; }\n        public int RowCount { get; set; }\n        public List<string> Columns { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceImportService.cs",
      "sha256": "d7d97123d74025c2ac1e15973dd9e31f977706e2312d898a3af8a8374cc9af38",
      "language": "csharp",
      "size": 4327,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public class AudienceImportService : IAudienceImportService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceImportService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty)\n                throw new UnauthorizedAccessException(\"Invalid business id.\");\n\n            if (csvStream == null || !csvStream.CanRead)\n                throw new ArgumentException(\"CSV stream is not readable.\");\n\n            using var reader = new StreamReader(csvStream);\n\n            // --- header row ---\n            var headerLine = await reader.ReadLineAsync();\n            if (string.IsNullOrWhiteSpace(headerLine))\n                throw new InvalidOperationException(\"Empty CSV.\");\n\n            var headers = headerLine.Split(',')\n                                    .Select(h => (h ?? string.Empty).Trim())\n                                    .Where(h => !string.IsNullOrWhiteSpace(h))\n                                    .ToList();\n\n            if (headers.Count == 0)\n                throw new InvalidOperationException(\"No columns.\");\n\n            var batchId = Guid.NewGuid();\n            var now = DateTime.UtcNow;\n\n            // Pre-create batch\n            _db.CsvBatches.Add(new Features.CampaignModule.Models.CsvBatch\n            {\n                Id = batchId,\n                BusinessId = businessId,\n                FileName = fileName,\n                // ✅ match your model: CsvBatch.HeadersJson\n                HeadersJson = Newtonsoft.Json.JsonConvert.SerializeObject(headers),\n                RowCount = 0,\n                CreatedAt = now\n            });\n\n            var rowsBuffer = new List<Features.CampaignModule.Models.CsvRow>(capacity: 1024);\n            var total = 0;\n\n            // naive CSV parse (comma-only, no quoting in v1)\n            while (!reader.EndOfStream)\n            {\n                var line = await reader.ReadLineAsync();\n                if (string.IsNullOrWhiteSpace(line)) continue;\n\n                var cells = line.Split(',');\n                var dict = new Dictionary<string, string?>();\n                for (int i = 0; i < headers.Count; i++)\n                {\n                    var v = (i < cells.Length ? cells[i] : null)?.Trim();\n                    dict[headers[i]] = v;\n                }\n\n                rowsBuffer.Add(new Features.CampaignModule.Models.CsvRow\n                {\n                    Id = Guid.NewGuid(),\n                    BatchId = batchId,\n                    // 🔁 If your property is not RowJson, change this to the correct one (e.g., DataJson)\n                    RowJson = Newtonsoft.Json.JsonConvert.SerializeObject(dict),\n                    CreatedAt = DateTime.UtcNow\n                });\n\n                total++;\n\n                // chunked insert every 1k for memory safety\n                if (rowsBuffer.Count >= 1000)\n                {\n                    await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n                    await _db.SaveChangesAsync(ct);\n                    rowsBuffer.Clear();\n                }\n            }\n\n            if (rowsBuffer.Count > 0)\n            {\n                await _db.CsvRows.AddRangeAsync(rowsBuffer, ct);\n            }\n\n            // update batch row count\n            var batchRow = await _db.CsvBatches.FirstAsync(b => b.Id == batchId, ct);\n            batchRow.RowCount = total;\n\n            await _db.SaveChangesAsync(ct);\n\n            Log.Information(\"📥 CSV imported | biz={Biz} batch={Batch} rows={Rows} file={File}\",\n                businessId, batchId, total, fileName);\n\n            return new CsvImportResponseDto\n            {\n                BatchId = batchId,\n                RowCount = total,\n                Columns = headers,\n                CreatedAt = now\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/AudienceService.cs",
      "sha256": "cac7c8cbf5cafd4dfa16dff784e3dea70ab732453c3976417aa3b812face67a0",
      "language": "csharp",
      "size": 7432,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Audiences.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceService\n    {\n        Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy);\n        Task<List<AudienceSummaryDto>> ListAsync(Guid businessId);\n        Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy);\n        Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50);\n    }\n\n    public class AudienceService : IAudienceService\n    {\n        private readonly AppDbContext _db;\n\n        public AudienceService(AppDbContext db) { _db = db; }\n\n        public async Task<Guid> CreateAsync(Guid businessId, AudienceCreateDto dto, string createdBy)\n        {\n            var id = Guid.NewGuid();\n            try\n            {\n                var now = DateTime.UtcNow;\n                Guid? createdByUserId = null;\n                if (Guid.TryParse(createdBy, out var parsed)) createdByUserId = parsed;\n\n                var model = new Audience\n                {\n                    Id = id,\n                    BusinessId = businessId,\n                    Name = dto?.Name?.Trim() ?? \"Untitled Audience\",\n                    Description = dto?.Description,\n                    CsvBatchId = null,\n                    IsDeleted = false,\n                    CreatedByUserId = createdByUserId,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                };\n\n                _db.Set<Audience>().Add(model);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"✅ Audience created | biz={Biz} id={Id} name={Name}\", businessId, id, model.Name);\n                return id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Failed creating audience | biz={Biz}\", businessId);\n                throw;\n            }\n        }\n\n        public async Task<List<AudienceSummaryDto>> ListAsync(Guid businessId)\n        {\n            var audiences = _db.Set<Audience>()\n                .AsNoTracking()\n                .Where(a => a.BusinessId == businessId && !a.IsDeleted);\n\n            var members = _db.Set<AudienceMember>();\n\n            var items = await audiences\n                .OrderByDescending(a => a.CreatedAt)\n                .Select(a => new AudienceSummaryDto\n                {\n                    Id = a.Id,\n                    Name = a.Name,\n                    Description = a.Description,\n                    MemberCount = members.Count(m => m.BusinessId == businessId && m.AudienceId == a.Id && !m.IsDeleted),\n                    CreatedAt = a.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        public async Task<bool> AssignAsync(Guid businessId, Guid audienceId, AudienceAssignDto dto, string createdBy)\n        {\n            var audience = await _db.Set<Audience>()\n                .FirstOrDefaultAsync(a => a.Id == audienceId && a.BusinessId == businessId && !a.IsDeleted);\n\n            if (audience == null) return false;\n\n            var now = DateTime.UtcNow;\n\n            // 1) Assign CRM contacts (if provided)\n            if (dto?.ContactIds != null && dto.ContactIds.Count > 0)\n            {\n                var contacts = await _db.Set<Contact>()\n                    .Where(c => c.BusinessId == businessId && dto.ContactIds.Contains(c.Id))\n                    .Select(c => new { c.Id, c.Name, c.PhoneNumber, c.Email })\n                    .ToListAsync();\n\n                var newMembers = contacts.Select(c =>\n                {\n                    var phoneRaw = (c.PhoneNumber ?? \"\").Trim();\n                    var phoneE164 = ToE164OrNull(phoneRaw);\n\n                    return new AudienceMember\n                    {\n                        Id = Guid.NewGuid(),\n                        AudienceId = audienceId,\n                        BusinessId = businessId,\n                        ContactId = c.Id,\n                        Name = c.Name,\n                        Email = string.IsNullOrWhiteSpace(c.Email) ? null : c.Email,\n                        PhoneRaw = phoneRaw,\n                        PhoneE164 = phoneE164,\n                        AttributesJson = null,            // keep as null unless you want to pack extra vars\n                        IsTransientContact = false,\n                        IsDeleted = false,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                });\n\n                await _db.Set<AudienceMember>().AddRangeAsync(newMembers);\n            }\n\n            // 2) Optionally link a CSV batch\n            if (dto?.CsvBatchId.HasValue == true && dto.CsvBatchId.Value != Guid.Empty)\n            {\n                var batch = await _db.Set<CsvBatch>()\n                    .FirstOrDefaultAsync(b => b.Id == dto.CsvBatchId.Value && b.BusinessId == businessId);\n\n                if (batch != null)\n                {\n                    audience.CsvBatchId = batch.Id;\n                }\n            }\n\n            audience.UpdatedAt = now;\n\n            await _db.SaveChangesAsync();\n\n            Log.Information(\"👥 Audience assigned | biz={Biz} audience={AudienceId} contacts={Contacts} batch={Batch}\",\n                businessId, audienceId, dto?.ContactIds?.Count ?? 0, dto?.CsvBatchId);\n\n            return true;\n        }\n\n        public async Task<List<AudienceMemberDto>> GetMembersAsync(Guid businessId, Guid audienceId, int page = 1, int pageSize = 50)\n        {\n            page = Math.Max(1, page);\n            pageSize = Clamp(pageSize, 10, 200);\n\n            var q = _db.Set<AudienceMember>()\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.AudienceId == audienceId && !m.IsDeleted)\n                .OrderByDescending(m => m.CreatedAt);\n\n            var items = await q\n                .Skip((page - 1) * pageSize)\n                .Take(pageSize)\n                .Select(m => new AudienceMemberDto\n                {\n                    Id = m.Id,\n                    ContactId = m.ContactId,\n                    Name = m.Name,\n                    PhoneNumber = string.IsNullOrWhiteSpace(m.PhoneE164) ? m.PhoneRaw : m.PhoneE164,\n                    Email = m.Email,\n                    VariablesJson = m.AttributesJson,\n                    CreatedAt = m.CreatedAt\n                })\n                .ToListAsync();\n\n            return items;\n        }\n\n        // ---- helpers ----\n\n        private static int Clamp(int value, int min, int max)\n        {\n            if (value < min) return min;\n            if (value > max) return max;\n            return value;\n        }\n\n        private static string? ToE164OrNull(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var digits = new string(raw.Where(char.IsDigit).ToArray());\n            if (string.IsNullOrEmpty(digits)) return null;\n\n            // naive normalization: ensure leading +\n            if (raw.Trim().StartsWith(\"+\")) return \"+\" + digits;\n            return \"+\" + digits;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/CampaignVariableMapService.cs",
      "sha256": "fde5d702d281a92a4bbe0caa800ed3ab47c52fb28be71324666f3a9c7f34c3c7",
      "language": "csharp",
      "size": 6105,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignVariableMapService\n    {\n        Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy);\n        Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId);\n    }\n\n    public class CampaignVariableMapService : ICampaignVariableMapService\n    {\n        private readonly AppDbContext _db;\n\n        public CampaignVariableMapService(AppDbContext db) { _db = db; }\n\n        public async Task<bool> SaveAsync(Guid businessId, CampaignVariableMapDto dto, string updatedBy)\n        {\n            try\n            {\n                if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n                if (dto == null) throw new ArgumentNullException(nameof(dto));\n                if (dto.CampaignId == Guid.Empty) throw new ArgumentException(\"CampaignId is required.\", nameof(dto));\n\n                // Ensure campaign ownership\n                var owns = await _db.Campaigns\n                    .AsNoTracking()\n                    .AnyAsync(c => c.Id == dto.CampaignId && c.BusinessId == businessId);\n                if (!owns) return false;\n\n                // Load existing rows for this campaign\n                var existing = await _db.CampaignVariableMaps\n                    .Where(m => m.BusinessId == businessId && m.CampaignId == dto.CampaignId)\n                    .ToListAsync();\n\n                // Normalize incoming:\n                // - tolerate null Items\n                // - default Component → \"BODY\" if missing\n                // - trim strings\n                // - keep last occurrence per (Component, Index)\n                var incoming = (dto.Items?.AsEnumerable() ?? Enumerable.Empty<CampaignVariableMapItemDto>())\n                    .Where(i => i != null && i.Index >= 1)\n                    .Select(i => new\n                    {\n                        Component = string.IsNullOrWhiteSpace(i.Component) ? \"BODY\" : i.Component!.Trim(),\n                        i.Index,\n                        SourceType = string.IsNullOrWhiteSpace(i.SourceType) ? \"Static\" : i.SourceType!.Trim(),\n                        SourceKey = string.IsNullOrWhiteSpace(i.SourceKey) ? null : i.SourceKey!.Trim(),\n                        StaticValue = i.StaticValue,\n                        Expression = i.Expression,\n                        DefaultValue = i.DefaultValue,\n                        i.IsRequired\n                    })\n                    .GroupBy(x => new { x.Component, x.Index })\n                    .Select(g => g.Last())\n                    .ToList();\n\n                var incomingKeySet = incoming\n                    .Select(i => (i.Component, i.Index))\n                    .ToHashSet();\n\n                // Upsert each incoming row\n                foreach (var item in incoming)\n                {\n                    var row = existing.FirstOrDefault(x => x.Component == item.Component && x.Index == item.Index);\n                    if (row == null)\n                    {\n                        row = new CampaignVariableMap\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            CampaignId = dto.CampaignId,\n                            Component = item.Component,\n                            Index = item.Index\n                        };\n                        _db.CampaignVariableMaps.Add(row);\n                        existing.Add(row); // keep local cache in sync in case of duplicates\n                    }\n\n                    row.SourceType = item.SourceType;\n                    row.SourceKey = item.SourceKey;\n                    row.StaticValue = item.StaticValue;\n                    row.Expression = item.Expression;\n                    row.DefaultValue = item.DefaultValue;\n                    row.IsRequired = item.IsRequired;\n                }\n\n                // Remove deleted mappings (anything not present in incoming)\n                var toRemove = existing.Where(x => !incomingKeySet.Contains((x.Component, x.Index))).ToList();\n                if (toRemove.Count > 0)\n                    _db.CampaignVariableMaps.RemoveRange(toRemove);\n\n                await _db.SaveChangesAsync();\n\n                var upserted = incoming.Count;\n                var removed = toRemove.Count;\n\n                Log.Information(\"✅ Variable map saved | biz={Biz} campaign={Campaign} upserted={Up} removed={Rm}\",\n                    businessId, dto.CampaignId, upserted, removed);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Failed saving campaign variable map | biz={Biz} campaign={Campaign}\", businessId, dto?.CampaignId);\n                throw;\n            }\n        }\n        public async Task<CampaignVariableMapDto?> GetAsync(Guid businessId, Guid campaignId)\n        {\n            var rows = await _db.CampaignVariableMaps\n                .AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.CampaignId == campaignId)\n                .OrderBy(m => m.Component).ThenBy(m => m.Index)\n                .ToListAsync();\n\n            var items = rows.Select(r => new CampaignVariableMapItemDto\n            {\n                Component = r.Component,\n                Index = r.Index,\n                SourceType = r.SourceType,\n                SourceKey = r.SourceKey,\n                StaticValue = r.StaticValue,\n                Expression = r.Expression,\n                DefaultValue = r.DefaultValue,\n                IsRequired = r.IsRequired\n            }).ToList();\n\n            return new CampaignVariableMapDto\n            {\n                CampaignId = campaignId,\n                Items = items\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Audiences/Services/IAudienceImportService.cs",
      "sha256": "80df51144eb035b0134e49bbdb7de6c48754a7800e72ee354b158ddf5401a202",
      "language": "csharp",
      "size": 586,
      "content": "using System;\nusing System.IO;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Audiences.DTOs;\n\nnamespace xbytechat.api.Features.Audiences.Services\n{\n    public interface IAudienceImportService\n    {\n        /// <summary>\n        /// Parses a CSV stream (first row = headers), creates a CsvBatch and CsvRows, and returns batch summary.\n        /// </summary>\n        Task<CsvImportResponseDto> ImportCsvAsync(\n            Guid businessId,\n            Stream csvStream,\n            string fileName,\n            CancellationToken ct = default);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/DTOs/CreateAuditLogDto.cs",
      "sha256": "845322cca23fe6666ea3c5947bf45d55d34363c27d5bacec30375a04b24a73ef",
      "language": "csharp",
      "size": 471,
      "content": "namespace xbytechat.api.Features.AuditTrail.DTOs;\n\npublic class CreateAuditLogDto\n{\n    public string ActionType { get; set; }\n    public string Module { get; set; }\n    public string? RecordId { get; set; }\n\n    public string? OldValues { get; set; }\n    public string? NewValues { get; set; }\n    public string? Description { get; set; }\n\n    public string? IPAddress { get; set; }\n    public string? UserAgent { get; set; }\n    public string? Location { get; set; }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Models/AuditLog.cs",
      "sha256": "91e4760f6e10564db50d99acec9f1c83de5fd0b8ca2e0d3bc5874d645ac93a45",
      "language": "csharp",
      "size": 1034,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AuditTrail.Models\n{\n    public class AuditLog\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        // 📍 Business Context (Multi-Tenant)\n        public Guid BusinessId { get; set; }\n\n        // 🙋 Who performed the action\n        public Guid PerformedByUserId { get; set; }\n        public string? PerformedByUserName { get; set; } // Optional for display\n        public string? RoleAtTime { get; set; } // admin / business / agent\n\n        // 🔍 Action Details\n        public string ActionType { get; set; } = \"\"; // e.g., campaign.created, user.login\n        public string? Description { get; set; } // Free text for summary or custom note\n\n        // 🌐 Optional: Technical metadata\n        public string? IPAddress { get; set; }\n        public string? UserAgent { get; set; }\n        public string? Location { get; set; } // Optional for geo-capture later\n\n        // 🕒 Timestamp\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/AuditLogService.cs",
      "sha256": "6b18d820c4191681a1bf26d6672f189bce0cadcfba3c8beb9e29dbed4ad4fdd9",
      "language": "csharp",
      "size": 536,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Repositories;\nusing xbytechat.api.Repositories.Interfaces;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public class AuditLogService : IAuditLogService\n    {\n        private readonly IGenericRepository<AuditLog> _repo;\n\n        public AuditLogService(IGenericRepository<AuditLog> repo)\n        {\n            _repo = repo;\n        }\n\n        public async Task SaveLogAsync(AuditLog log)\n        {\n            await _repo.AddAsync(log);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AuditTrail/Services/IAuditLogService.cs",
      "sha256": "65d811af2c7dc349002b7b1a340a765025625f9fe31c241dccc8f3eaeab15330",
      "language": "csharp",
      "size": 197,
      "content": "using xbytechat.api.Features.AuditTrail.Models;\n\nnamespace xbytechat.api.Features.AuditTrail.Services\n{\n    public interface IAuditLogService\n    {\n        Task SaveLogAsync(AuditLog log);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/ChoiceConfig.cs",
      "sha256": "0d09e0bc40325856d625ab31e93694e661b6df532e5de78f2a55254783e40c1c",
      "language": "csharp",
      "size": 354,
      "content": "namespace xbytechat.api.Features.Automation.Config\n{\n    public class ChoiceConfig\n    {\n        public List<ChoiceCondition> Conditions { get; set; } = new();\n        public string FallbackNodeId { get; set; }\n    }\n\n    public class ChoiceCondition\n    {\n        public string Match { get; set; }\n        public string NextNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/MessageConfig.cs",
      "sha256": "564fbd35e79d9ef3f8b48ed54e15d55a9d0226b7d6ea72315d81b562a7a4ecae",
      "language": "csharp",
      "size": 225,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Future: Add support for media, buttons, templates\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/TagNodeConfig.cs",
      "sha256": "81144c1418ba70285c6af13bf7aee6346f8f6674416ffc9ab79614bceb3be4d0",
      "language": "csharp",
      "size": 197,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Config/WaitConfig.cs",
      "sha256": "d13667732f9e18370123b10c2881aa385e8d11a33bc01acaf0f7eb96f4903bd6",
      "language": "csharp",
      "size": 170,
      "content": "namespace xbytechat.api.Features.Automation.Models.Configs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 2; // Default wait time\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Controllers/AutomationController.cs",
      "sha256": "3a2f3e472a351808592f6357f3e907d20c118e1e0f86f035a76e49697013e4ff",
      "language": "csharp",
      "size": 2144,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.Automation.DTOs;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Features.Automation.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Automation.Controllers\n{\n    [ApiController]\n    [Route(\"api/automation\")]\n    [Authorize]\n    public class AutomationController : ControllerBase\n    {\n        private readonly IAutomationFlowRepository _automationRepository;\n        private readonly IAutomationRunner _automationRunner;\n        private readonly IContactService _contactService;\n\n        public AutomationController(\n            IAutomationFlowRepository automationRepository,\n            IAutomationRunner automationRunner,\n            IContactService contactService)\n        {\n            _automationRepository = automationRepository;\n            _automationRunner = automationRunner;\n            _contactService = contactService;\n        }\n\n        [HttpPost(\"trigger\")]\n        public async Task<IActionResult> TriggerByKeyword([FromBody] AutomationTriggerRequest request)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (string.IsNullOrWhiteSpace(request.Keyword) || string.IsNullOrWhiteSpace(request.Phone))\n                return BadRequest(\"Keyword and phone are required.\");\n\n            var flow = await _automationRepository.GetFlowByKeywordAsync(businessId, request.Keyword);\n            if (flow == null || !flow.IsActive)\n                return NotFound(\"⚠️ No matching active automation flow found.\");\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, request.Phone);\n\n            var result = await _automationRunner.RunFlowAsync(\n                flow,\n                businessId,\n                contact.Id,\n                request.Phone,\n                request.SourceChannel ?? \"manual\",\n                request.IndustryTag ?? \"manual\"\n            );\n\n            return Ok(result);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationEdgeDto.cs",
      "sha256": "d9093a43a35fa0c12238f7c78daec3980190c4160320cfe73c6b93ff2d41c5ce",
      "language": "csharp",
      "size": 450,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    /// <summary>\n    /// Represents a connection (edge) between two automation nodes.\n    /// </summary>\n    public class AutomationEdgeDto\n    {\n        public Guid SourceNodeId { get; set; }\n\n        public Guid TargetNodeId { get; set; }\n\n        public string? Condition { get; set; }  // Optional: for future conditional routing (e.g., \"if clicked\", \"if not responded\")\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/AutomationTriggerRequest.cs",
      "sha256": "aeca572a0bab580b70dddd50cb6f4e1b282f17508311aaeb9beaefef34d8fa46",
      "language": "csharp",
      "size": 296,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class AutomationTriggerRequest\n    {\n        public string Keyword { get; set; }\n\n        public string Phone { get; set; }\n\n        public string? SourceChannel { get; set; }\n\n        public string? IndustryTag { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/MessageNodeConfig.cs",
      "sha256": "8fdadb2bb6457b35ed85d89655b1f6d1d9bc5028a0ec212d9dd7eaa70b1a8e0d",
      "language": "csharp",
      "size": 218,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class MessageNodeConfig\n    {\n        public string Text { get; set; } = string.Empty;\n\n        // Optional: Later you can add buttons, media, etc.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/TagNodeConfig.cs",
      "sha256": "2feaf9902643a6bb0e59b019cfca34a41ada3abf9f66afffcac065c6bb545b6c",
      "language": "csharp",
      "size": 199,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.DTOs\n{\n    public class TagNodeConfig\n    {\n        public List<Guid> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/DTOs/WaitNodeConfig.cs",
      "sha256": "f520007158ae72db229b2a23f437666e64d34fcc96cdd728ad57a4320f152b75",
      "language": "csharp",
      "size": 143,
      "content": "namespace xbytechat.api.Features.Automation.DTOs\n{\n    public class WaitNodeConfig\n    {\n        public int Seconds { get; set; } = 3;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlow.cs",
      "sha256": "7dd5063615cfa824960a08fdd88d9fdf500a3c0461151b27e09fcaa7d97b45fe",
      "language": "csharp",
      "size": 803,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents a saved automation flow with nodes and edges.\n    /// </summary>\n    public class AutomationFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string Name { get; set; } = string.Empty;\n\n        public string TriggerKeyword { get; set; } = string.Empty; // ✅ Better naming\n\n        public string NodesJson { get; set; } = \"[]\";\n\n        public string EdgesJson { get; set; } = \"[]\";\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowEdge.cs",
      "sha256": "ad1f63ff8580807f996a658e2a95652c94370929e8dd75eac9f1fdc98c398105",
      "language": "csharp",
      "size": 280,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowEdge\n    {\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string? Condition { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowNode.cs",
      "sha256": "c18876f0d4c8fdf851da8df67ddff902fee66217b804a6765a9b533f8402e76d",
      "language": "csharp",
      "size": 354,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowNode\n    {\n        public string Id { get; set; } = Guid.NewGuid().ToString(\"N\");\n        public string Label { get; set; } = string.Empty;\n        public NodeTypeEnum NodeType { get; set; }\n        public string ConfigJson { get; set; } = \"{}\";\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/AutomationFlowRunResult.cs",
      "sha256": "61407553e4f66fbfdc8c0a51868372170e58411cd6c74e857e8e9cab13e27b6b",
      "language": "csharp",
      "size": 403,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    public class AutomationFlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } = null;\n\n        public string? Notes { get; set; }  // Optional: track execution info (e.g., exit reason)\n\n        public DateTime ExecutedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowExecutionContext.cs",
      "sha256": "aef2132567e314889ae4d98f06dd96c43873ab3513b6c02cd8553346e3e7ff57",
      "language": "csharp",
      "size": 523,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Context required to run an automation flow.\n    /// </summary>\n    public class FlowExecutionContext\n    {\n        public AutomationFlow Flow { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public Guid ContactId { get; set; }\n\n        public string ContactPhone { get; set; }\n\n        public string SourceChannel { get; set; } = \"manual\";\n\n        public string IndustryTag { get; set; } = \"manual\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/FlowRunResult.cs",
      "sha256": "64baa95c50dc4528fa36e8ad36a12ac82a0528c8c640797d16b58e17455d6125",
      "language": "csharp",
      "size": 345,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Automation.Models\n{\n    /// <summary>\n    /// Represents the result of running an automation flow.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n        public Guid? HandoffNodeId { get; set; } // If agent handoff requested\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeConfigs.cs",
      "sha256": "0e8b3fb72dd676ec59568e34b569e1302a621a35a6efca4553736f89b15b21c4",
      "language": "csharp",
      "size": 167,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/NodeTypeEnum.cs",
      "sha256": "ac2b60c1ffd633136ef56df710b0cf7f141496e92e30cd1c4bd42f201f4d85d3",
      "language": "csharp",
      "size": 223,
      "content": "namespace xbytechat.api.Features.Automation.Models\n{\n    public enum NodeTypeEnum\n    {\n        Message,\n        Wait,\n        Tag,\n        AgentHandoff,\n        Choice,\n        Condition,\n        Loop,\n        End\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/TagNodeConfig.cs",
      "sha256": "9cec10f188aea021e4b186075bf0f84e18cb4071046ade7098c2658d077559f5",
      "language": "csharp",
      "size": 201,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Models/WaitConfig.cs",
      "sha256": "641533b56ae811de7505263f827bc5f89cc405f67645b053fd06737f1e5fa621",
      "language": "csharp",
      "size": 153,
      "content": "namespace xbytechat.api.Features.Automation.Models.NodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; } = 1;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/AutomationFlowRepository.cs",
      "sha256": "0e6a38673480db7c067e41901c2725f6c93683975ffaacfdcefb67bcfe90820e",
      "language": "csharp",
      "size": 3297,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public class AutomationFlowRepository : IAutomationFlowRepository\n    {\n        private readonly AppDbContext _db;\n\n        public AutomationFlowRepository(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                    f.BusinessId == businessId &&\n                    f.TriggerKeyword.ToLower() == keyword.ToLower() &&\n                    f.IsActive);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId)\n        {\n            return await _db.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderBy(f => f.Name)\n                .ToListAsync();\n        }\n\n        public async Task<AutomationFlow> CreateAsync(AutomationFlow flow)\n        {\n            flow.Id = Guid.NewGuid();\n            flow.CreatedAt = DateTime.UtcNow;\n            flow.IsActive = true;\n\n            _db.AutomationFlows.Add(flow);\n            await _db.SaveChangesAsync();\n            return flow;\n        }\n\n        public async Task<AutomationFlow> UpdateAsync(AutomationFlow flow)\n        {\n            var existing = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flow.Id && f.BusinessId == flow.BusinessId && f.IsActive);\n\n            if (existing == null)\n                throw new KeyNotFoundException(\"Automation flow not found.\");\n\n            existing.Name = flow.Name;\n            existing.TriggerKeyword = flow.TriggerKeyword;\n            existing.NodesJson = flow.NodesJson;\n            existing.EdgesJson = flow.EdgesJson;\n            existing.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(existing);\n            await _db.SaveChangesAsync();\n\n            return existing;\n        }\n\n        public async Task<bool> DeleteAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _db.AutomationFlows\n                .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId && f.IsActive);\n\n            if (flow == null)\n                return false;\n\n            flow.IsActive = false;\n            flow.UpdatedAt = DateTime.UtcNow;\n\n            _db.AutomationFlows.Update(flow);\n            await _db.SaveChangesAsync();\n            return true;\n        }\n        public async Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _db.AutomationFlows\n                .FirstOrDefaultAsync(f =>\n                f.BusinessId == businessId &&\n                EF.Functions.ILike(f.TriggerKeyword, keyword) &&\n                f.IsActive);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Repositories/IAutomationFlowRepository.cs",
      "sha256": "3c0e87413a797f0b2cb7de16b419204f9f84555fd58a4435ca5bffc5f570b2fe",
      "language": "csharp",
      "size": 1022,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Repositories\n{\n    public interface IAutomationFlowRepository\n    {\n        // 🔍 Get flow by unique FlowId + BusinessId (strict filtering)\n        Task<AutomationFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n\n        // 🔍 Get flow by keyword for auto-trigger\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // 📋 List all flows for business\n        Task<IEnumerable<AutomationFlow>> GetAllByBusinessAsync(Guid businessId);\n\n        // ➕ Create flow\n        Task<AutomationFlow> CreateAsync(AutomationFlow flow);\n\n        // ✏️ Update flow\n        Task<AutomationFlow> UpdateAsync(AutomationFlow flow);\n\n        // ❌ Delete flow\n        Task<bool> DeleteAsync(Guid flowId, Guid businessId);\n        Task<AutomationFlow?> GetByKeywordAsync(Guid businessId, string keyword);\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationRunner.cs",
      "sha256": "3f1cb7807540e05fcd7092da474d3784a3f5c6065fd4c98ca22abc2753b97765",
      "language": "csharp",
      "size": 12633,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Microsoft.EntityFrameworkCore;\nusing Newtonsoft.Json;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Models.Configs;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.Automation.Config;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationRunner : IAutomationRunner\n    {\n        private readonly IMessageEngineService _messageService;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationRunner> _logger;\n        private readonly AppDbContext _appDbContext;\n        public AutomationRunner(\n            IMessageEngineService messageService,\n            IContactService contactService,\n            ILogger<AutomationRunner> logger, AppDbContext appDbContext)\n        {\n            _messageService = messageService;\n            _contactService = contactService;\n            _logger = logger;\n            _appDbContext = appDbContext;\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string contactPhone,\n            string sourceChannel,\n            string industryTag)\n        {\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var result = new AutomationFlowRunResult();\n            var currentNode = nodes.FirstOrDefault(); // Start from first node\n\n            if (currentNode == null)\n            {\n                _logger.LogWarning(\"🚫 Flow has no start node.\");\n                result.NeedsAgent = true;\n                result.Notes = \"No start node found.\";\n                return result;\n            }\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"➡️ Running node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        _logger.LogInformation(\"📤 Sending message: {Text}\", msgCfg.Text);\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"⏳ Waiting {Seconds}s\", waitCfg.Seconds);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        _logger.LogInformation(\"🏷️ Assigning tags: {Tags}\", string.Join(\", \", tagCfg.Tags));\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.AgentHandoff:\n                        result.NeedsAgent = true;\n                        if (Guid.TryParse(currentNode.Id, out var parsedId))\n                        {\n                            result.HandoffNodeId = parsedId;\n                        }\n                        else\n                        {\n                            _logger.LogWarning(\"⚠️ Invalid node ID format for AgentHandoff node: {Id}\", currentNode.Id);\n                            result.HandoffNodeId = null;\n                        }\n                        result.Notes = \"Flow routed to human agent.\";\n                        return result;\n\n                    case NodeTypeEnum.End:\n                        _logger.LogInformation(\"✅ End node reached.\");\n                        currentNode = null;\n                        continue;\n\n                    case NodeTypeEnum.Choice:\n                        _logger.LogInformation(\"🧠 Reached Choice node. Saving session state to wait for user input...\");\n\n                        var session = await _appDbContext.ChatSessionStates.FirstOrDefaultAsync(s =>\n                            s.BusinessId == businessId && s.ContactId == contactId);\n\n                        if (session == null)\n                        {\n                            session = new ChatSessionState\n                            {\n                                Id = Guid.NewGuid(),\n                                BusinessId = businessId,\n                                ContactId = contactId\n                            };\n                            _appDbContext.ChatSessionStates.Add(session);\n                        }\n\n                        session.Mode = \"awaiting_choice\";\n                        session.UpdatedBy = currentNode.Id.ToString();\n                        session.LastUpdatedAt = DateTime.UtcNow;\n\n                        await _appDbContext.SaveChangesAsync();\n\n                        result.Notes = \"Choice node reached. Flow paused.\";\n                        return result;\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            result.Notes = \"Flow completed.\";\n            return result;\n        }\n        public async Task<AutomationFlowRunResult> ResumeFlowAsync(\n           Guid businessId,\n           Guid contactId,\n           string contactPhone,\n           string incomingMessage)\n        {\n            var session = await _appDbContext.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (session == null || session.Mode != \"awaiting_choice\")\n            {\n                _logger.LogWarning(\"❌ No active automation session found or mode not awaiting_choice.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active automation session.\" };\n            }\n\n            var flow = await _appDbContext.AutomationFlows\n                .Where(f => f.BusinessId == businessId && f.IsActive)\n                .OrderByDescending(f => f.UpdatedAt)\n                .FirstOrDefaultAsync();\n\n            if (flow == null)\n            {\n                _logger.LogWarning(\"❌ No active automation flow found for business.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"No active flow found.\" };\n            }\n\n            var nodes = JsonConvert.DeserializeObject<List<AutomationFlowNode>>(flow.NodesJson);\n            var edges = JsonConvert.DeserializeObject<List<AutomationFlowEdge>>(flow.EdgesJson);\n\n            var choiceNode = nodes.FirstOrDefault(n => n.Id == session.UpdatedBy && n.NodeType == NodeTypeEnum.Choice);\n            if (choiceNode == null)\n            {\n                _logger.LogWarning(\"❌ Stored session node not found or not a Choice node.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice node in session.\" };\n            }\n\n            var cfg = JsonConvert.DeserializeObject<ChoiceConfig>(choiceNode.ConfigJson);\n            if (cfg?.Conditions == null)\n            {\n                _logger.LogWarning(\"❌ Choice config is null or empty.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Invalid Choice config.\" };\n            }\n\n            var match = cfg.Conditions.FirstOrDefault(c =>\n                string.Equals(c.Match.Trim(), incomingMessage.Trim(), StringComparison.OrdinalIgnoreCase));\n\n            string nextNodeId = match?.NextNodeId ?? cfg.FallbackNodeId;\n            if (match == null)\n            {\n                _logger.LogWarning(\"🔁 No matching condition found. Using fallback: {Fallback}\", nextNodeId);\n            }\n\n            var nextNode = nodes.FirstOrDefault(n => n.Id == nextNodeId);\n            if (nextNode == null)\n            {\n                _logger.LogWarning(\"❌ Next node after choice not found.\");\n                return new AutomationFlowRunResult { NeedsAgent = true, Notes = \"Next node not found.\" };\n            }\n\n            // ✅ Clear session after resume\n            _appDbContext.ChatSessionStates.Remove(session);\n            await _appDbContext.SaveChangesAsync();\n\n            // ✅ Resume from the matched node using shared loop\n            return await ExecuteNodeLoopAsync(flow, nextNode, nodes, edges, businessId, contactId, contactPhone);\n        }\n\n\n        private async Task<AutomationFlowRunResult> ExecuteNodeLoopAsync(\n    AutomationFlow flow,\n    AutomationFlowNode startNode,\n    List<AutomationFlowNode> nodes,\n    List<AutomationFlowEdge> edges,\n    Guid businessId,\n    Guid contactId,\n    string contactPhone)\n        {\n            var result = new AutomationFlowRunResult();\n            var currentNode = startNode;\n\n            while (currentNode != null)\n            {\n                _logger.LogInformation(\"➡️ Executing node: {NodeType} | {NodeId}\", currentNode.NodeType, currentNode.Id);\n\n                switch (currentNode.NodeType)\n                {\n                    case NodeTypeEnum.Message:\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        var msgDto = new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            RecipientNumber = contactPhone,\n                            TextContent = msgCfg.Text,\n                            Source = \"automation\"\n                        };\n                        await _messageService.SendAutomationReply(msgDto);\n                        break;\n\n                    case NodeTypeEnum.Tag:\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        await _contactService.AssignTagsAsync(businessId, contactPhone, tagCfg.Tags);\n                        break;\n\n                    case NodeTypeEnum.Wait:\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        await Task.Delay(waitCfg.Seconds * 1000);\n                        break;\n\n                    case NodeTypeEnum.End:\n                        return new AutomationFlowRunResult { Notes = \"✅ Flow ended.\" };\n\n                    case NodeTypeEnum.AgentHandoff:\n                        return new AutomationFlowRunResult\n                        {\n                            NeedsAgent = true,\n                            Notes = \"Routed to human agent.\"\n                        };\n\n                    case NodeTypeEnum.Choice:\n                        var session = new ChatSessionState\n                        {\n                            Id = Guid.NewGuid(),\n                            BusinessId = businessId,\n                            ContactId = contactId,\n                            Mode = \"awaiting_choice\",\n                            UpdatedBy = currentNode.Id.ToString(),\n                            LastUpdatedAt = DateTime.UtcNow\n                        };\n                        _appDbContext.ChatSessionStates.Add(session);\n                        await _appDbContext.SaveChangesAsync();\n\n                        return new AutomationFlowRunResult { Notes = \"Paused at Choice node.\" };\n                }\n\n                var edge = edges.FirstOrDefault(e => e.SourceNodeId == currentNode.Id);\n                currentNode = edge == null ? null : nodes.FirstOrDefault(n => n.Id == edge.TargetNodeId);\n            }\n\n            return new AutomationFlowRunResult { Notes = \"Flow completed.\" };\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/AutomationService.cs",
      "sha256": "c42e37b6d7f110e3f94e15cae67213a79f8219feb763ecb1ba4ca86c636e423c",
      "language": "csharp",
      "size": 5101,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.Automation.Models;\nusing xbytechat.api.Features.Automation.Repositories;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public class AutomationService : IAutomationService\n    {\n        private readonly IAutomationFlowRepository _flowRepository;\n        private readonly IAutomationRunner _runner;\n        private readonly IContactService _contactService;\n        private readonly ILogger<AutomationService> _logger;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public AutomationService(\n            IAutomationFlowRepository flowRepository,\n            IAutomationRunner runner,\n            IContactService contactService,\n            ILogger<AutomationService> logger,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _flowRepository = flowRepository;\n            _runner = runner;\n            _contactService = contactService;\n            _logger = logger;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.GetByIdAsync(flowId, businessId);\n        }\n\n        public async Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword)\n        {\n            return await _flowRepository.GetByKeywordAsync(businessId, keyword);\n        }\n\n        public async Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag)\n        {\n            return await _runner.RunFlowAsync(flow, businessId, contactId, phone, sourceChannel, industryTag);\n        }\n\n        public async Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId)\n        {\n            return await _flowRepository.GetAllByBusinessAsync(businessId);\n        }\n\n        public async Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow)\n        {\n            flow.BusinessId = businessId;\n            return await _flowRepository.CreateAsync(flow);\n        }\n\n        public async Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId)\n        {\n            return await _flowRepository.DeleteAsync(flowId, businessId);\n        }\n\n        public async Task RunByKeywordAsync(string messageText, string phoneNumber, string sourceChannel = \"whatsapp\")\n        {\n            var businessId = _httpContextAccessor.HttpContext?.User?.GetBusinessId()\n                ?? throw new UnauthorizedAccessException(\"BusinessId could not be resolved from context.\");\n\n            var flow = await _flowRepository.GetByKeywordAsync(businessId, messageText);\n            if (flow == null)\n            {\n                _logger.LogInformation(\"No matching automation flow for keyword: {Keyword}\", messageText);\n                return;\n            }\n\n            var contact = await _contactService.FindOrCreateAsync(businessId, phoneNumber);\n            await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag: \"default\");\n        }\n\n        public async Task<bool> TryRunFlowByKeywordAsync(\n         Guid businessId,\n         string messageText,\n         string userPhone,\n         string sourceChannel,\n         string industryTag)\n        {\n            try\n            {\n                // 🔍 Normalize keyword\n                var normalizedKeyword = messageText.Trim().ToLower();\n\n                // ✅ Fetch flow by trigger keyword\n                var flow = await _flowRepository.GetByKeywordAsync(businessId, normalizedKeyword);\n                if (flow == null)\n                {\n                    _logger.LogInformation(\"TryRun: No matching automation flow found for keyword: '{Keyword}'\", normalizedKeyword);\n                    return false;\n                }\n\n                // 👤 Ensure contact exists\n                var contact = await _contactService.FindOrCreateAsync(businessId, userPhone);\n                if (contact == null)\n                {\n                    _logger.LogWarning(\"❌ TryRun: Failed to resolve or create contact for phone: {Phone}\", userPhone);\n                    return false;\n                }\n\n                // ▶️ Run automation flow\n                _logger.LogInformation(\"🚀 Running flow '{FlowName}' for keyword '{Keyword}'\", flow.Name, normalizedKeyword);\n                await _runner.RunFlowAsync(flow, businessId, contact.Id, contact.PhoneNumber, sourceChannel, industryTag);\n\n                return true;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ TryRun: Exception while executing flow for keyword '{Keyword}'\", messageText);\n                return false;\n            }\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationRunner.cs",
      "sha256": "0aa081c7006bb76ff84c8cee9da21e51a021a69c4e0b6d191ffdc1356b5e4001",
      "language": "csharp",
      "size": 453,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationRunner\n    {\n        Task<AutomationFlowRunResult> RunFlowAsync(\n             AutomationFlow flow,\n             Guid businessId,\n             Guid contactId,\n             string contactPhone,\n             string sourceChannel,\n             string industryTag\n );\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/Automation/Services/IAutomationService.cs",
      "sha256": "fd32d83e0e970571048b14fb8805162a0b1139c917ed0bf99ad84b4a244ce609",
      "language": "csharp",
      "size": 1688,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Automation.Models;\n\nnamespace xbytechat.api.Features.Automation.Services\n{\n    public interface IAutomationService\n    {\n        // 📌 Get flow by FlowId (for admin UI or debugging)\n        Task<AutomationFlow?> GetFlowByIdAsync(Guid flowId, Guid businessId);\n\n        // 📌 Get flow by keyword match (used for auto-triggering)\n        Task<AutomationFlow?> GetFlowByKeywordAsync(Guid businessId, string keyword);\n\n        // 🛠️ Execute a flow with contact and channel info\n        Task<AutomationFlowRunResult> RunFlowAsync(\n            AutomationFlow flow,\n            Guid businessId,\n            Guid contactId,\n            string phone,\n            string sourceChannel,\n            string industryTag\n        );\n\n        // 📋 List all flows (for admin or dashboard)\n        Task<IEnumerable<AutomationFlow>> GetAllFlowsAsync(Guid businessId);\n\n        // ➕ Create new flow\n        Task<AutomationFlow> CreateFlowAsync(Guid businessId, AutomationFlow flow);\n\n        // ❌ Delete existing flow\n        Task<bool> DeleteFlowAsync(Guid flowId, Guid businessId);\n\n        // ⚡ Runtime entry point – called when a message arrives\n        Task RunByKeywordAsync(\n            string messageText,\n            string phoneNumber,\n            string sourceChannel = \"whatsapp\"\n        );\n\n        // ✅ Returns true if flow matched and executed\n        Task<bool> TryRunFlowByKeywordAsync(\n            Guid businessId,\n            string messageText,\n            string userPhone,\n            string sourceChannel,\n            string industryTag\n        );\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyController.cs",
      "sha256": "c575c41a8f3145df1332211adef4017099c86609c2981442039fcfbd0823a6de",
      "language": "csharp",
      "size": 2591,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class AutoReplyController : ControllerBase\n    {\n        private readonly IAutoReplyService _service;\n\n        public AutoReplyController(IAutoReplyService service)\n        {\n            _service = service;\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> CreateRule([FromBody] AutoReplyRuleDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var result = await _service.CreateRuleAsync(businessId, dto);\n            return Ok(result);\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> GetAllRules()\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var rules = await _service.GetAllRulesAsync(businessId);\n            return Ok(rules);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetRuleById(Guid id)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var rule = await _service.GetRuleByIdAsync(id, businessId);\n            return rule == null ? NotFound() : Ok(rule);\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateRule(Guid id, [FromBody] AutoReplyRuleDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            dto.Id = id;\n            var success = await _service.UpdateRuleAsync(businessId, dto);\n            return success ? NoContent() : NotFound();\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteRule(Guid id)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var success = await _service.DeleteRuleAsync(id, businessId);\n            return success ? NoContent() : NotFound();\n        }\n\n        // Optional — for debugging match logic (not exposed in prod)\n        [HttpGet(\"match\")]\n        public async Task<IActionResult> MatchByKeyword([FromQuery] string message)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var matchedRule = await _service.MatchRuleByKeywordAsync(businessId, message);\n            return matchedRule == null ? NotFound(\"No match found.\") : Ok(matchedRule);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyFlowsController.cs",
      "sha256": "442d35032e1265a4ba687db6033f7cd70d21c92e30f63d3122e43e50540bb763",
      "language": "csharp",
      "size": 3075,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    [Authorize]\n    public class AutoReplyFlowsController : ControllerBase\n    {\n        private readonly IAutoReplyFlowService _service;\n\n        public AutoReplyFlowsController(IAutoReplyFlowService service)\n        {\n            _service = service;\n        }\n\n        // [HttpPost(\"save\")]\n        //public async Task<IActionResult> SaveFlow([FromBody] SaveFlowDto dto)\n        //{\n        //    var id = await _service.SaveFlowAsync(dto);\n        //    return Ok(new { id });\n        //}\n        [HttpPost(\"save\")]\n        public async Task<IActionResult> SaveFlow([FromBody] SaveFlowDto dto)\n        {\n            Guid businessId;\n            try { businessId = User.GetBusinessId(); }\n            catch (UnauthorizedAccessException) { return Unauthorized(\"Missing or invalid business ID\"); }\n\n            var id = await _service.SaveFlowAsync(dto, businessId);\n            return Ok(new { id });\n        }\n\n        [HttpGet(\"business/{businessId}\")]\n        public async Task<IActionResult> GetFlowsByBusiness(Guid businessId)\n        {\n            var flows = await _service.GetFlowsByBusinessIdAsync(businessId);\n            return Ok(flows);\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetFlowById(Guid id)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n            var flow = await _service.GetFlowByIdAsync(id, businessId);\n            return flow == null ? NotFound() : Ok(flow);\n        }\n        [HttpGet(\"business/{businessId}/count\")]\n        public async Task<IActionResult> GetFlowCount(Guid businessId)\n        {\n            var count = await _service.GetFlowCountForBusinessAsync(businessId);\n            return Ok(count);\n        }\n        [HttpPut(\"{id}/rename\")]\n        public async Task<IActionResult> RenameFlow(Guid id, [FromBody] RenameFlowDto dto)\n        {\n            var result = await _service.RenameFlowAsync(id, dto.NewName);\n            if (!result) return NotFound();\n            return Ok();\n        }\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteFlow(Guid id)\n        {\n            Guid businessId;\n            try\n            {\n                businessId = User.GetBusinessId(); // ✅ Clean and secure\n            }\n            catch (UnauthorizedAccessException)\n            {\n                return Unauthorized(\"Missing or invalid business ID\");\n            }\n\n            var success = await _service.DeleteFlowAsync(id, businessId);\n            if (!success)\n                return NotFound(\"Flow not found or not owned by your business\");\n\n            return Ok(new { message = \"Flow deleted successfully\" });\n        }\n\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/AutoReplyRuntimeController.cs",
      "sha256": "a8f103874213b2129c6d59932b03582a9f21206d073f756ca97bfe08e0015e85",
      "language": "csharp",
      "size": 3135,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Controllers\n{\n    [ApiController]\n    [Route(\"api/auto-reply-runtime\")]\n    [Authorize]\n    public class AutoReplyRuntimeController : ControllerBase\n    {\n        private readonly IAutoReplyRuntimeService _runtimeService;\n        private readonly ILogger<AutoReplyRuntimeController> _logger;\n\n        public AutoReplyRuntimeController(\n            IAutoReplyRuntimeService runtimeService,\n            ILogger<AutoReplyRuntimeController> logger)\n        {\n            _runtimeService = runtimeService;\n            _logger = logger;\n        }\n\n        // 🔁 Runtime button reply based on keyword (used in message click)\n        [HttpPost(\"button-click\")]\n        public async Task<IActionResult> HandleButtonClick([FromBody] AutoReplyButtonClickDto dto)\n        {\n            var businessId = ClaimsBusinessDetails.GetBusinessId(User);\n\n            _logger.LogInformation(\"🔘 Button clicked: BusinessId={BusinessId}, Phone={Phone}, Button={ButtonText}, RefMsg={RefMessageId}\",\n                businessId, dto.Phone, dto.ButtonText, dto.RefMessageId?.ToString() ?? \"null\");\n\n            await _runtimeService.TryRunAutoReplyFlowByButtonAsync(\n                businessId,\n                dto.Phone,\n                dto.ButtonText,\n                dto.RefMessageId\n            );\n\n            return Ok(new { success = true });\n        }\n\n        // 🧪 Manual test (canvas-based flow trigger)\n        [HttpPost(\"flow-by-button\")]\n        public async Task<IActionResult> TriggerFlowByButton([FromBody] AutoReplyButtonClickDto dto)\n        {\n            if (string.IsNullOrWhiteSpace(dto.Phone) || string.IsNullOrWhiteSpace(dto.ButtonText))\n                return BadRequest(\"Phone and ButtonText are required.\");\n\n            try\n            {\n                _logger.LogInformation(\"🚀 Triggering flow from button: FlowId={FlowId}, BusinessId={BusinessId}, ContactId={ContactId}, Phone={Phone}, ButtonText={ButtonText}\",\n                    dto.FlowId, dto.BusinessId, dto.ContactId, dto.Phone, dto.ButtonText);\n\n                await _runtimeService.RunFlowFromButtonAsync(\n                    dto.FlowId,\n                    dto.BusinessId,\n                    dto.ContactId,\n                    dto.Phone,\n                    dto.ButtonText.Trim()\n                );\n\n                return Ok(new\n                {\n                    success = true,\n                    flowId = dto.FlowId,\n                    contactId = dto.ContactId,\n                    triggeredAt = DateTime.UtcNow\n                });\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to trigger flow from button click: FlowId={FlowId}, Phone={Phone}, Button={ButtonText}\",\n                    dto.FlowId, dto.Phone, dto.ButtonText);\n\n                return StatusCode(500, \"Internal server error\");\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Controllers/TemplatesController.cs",
      "sha256": "555d0e0c3deaa65e82290ddcf55e06bb4fa67bbcf43e5b9d56ea5109f7c236b8",
      "language": "csharp",
      "size": 995,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.TemplateMessages.DTOs;\n\nnamespace xbytechat.api.Features.TemplateMessages.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class TemplatesController : ControllerBase\n    {\n        private static readonly List<TemplateDto> MockTemplates = new()\n        {\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Welcome Template\",\n                Placeholders = 2\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Offer Reminder\",\n                Placeholders = 1\n            },\n            new TemplateDto\n            {\n                Id = Guid.NewGuid(),\n                Name = \"Follow Up\",\n                Placeholders = 3\n            }\n        };\n\n        [HttpGet]\n        public ActionResult<List<TemplateDto>> GetAll()\n        {\n            return Ok(MockTemplates);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyButtonClickDto.cs",
      "sha256": "c33e345f9a02ff4d627ba42ba92505f5819a034035b07bde678784a244b9d6ac",
      "language": "csharp",
      "size": 412,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class AutoReplyButtonClickDto\n    {\n        public Guid FlowId { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n        public string ButtonText { get; set; } = string.Empty;\n        public Guid? RefMessageId { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyLogDto.cs",
      "sha256": "4674e27873c9ca6a52ab8c85ac1fb97864c6a1e653138b78096a19b3b230124e",
      "language": "csharp",
      "size": 596,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class AutoReplyLogDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string TriggerType { get; set; } = \"rule\"; // or \"flow\"\n        public string TriggerKeyword { get; set; } = string.Empty;\n        public string ReplyContent { get; set; } = string.Empty;\n\n        public DateTime TriggeredAt { get; set; }\n\n        public string? FlowName { get; set; }\n\n        public Guid? MessageLogId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/AutoReplyRuleDto.cs",
      "sha256": "47945e41d0ce9fc41bf7949aea8b58a0caf3bb5083fae0bc6d4815ea846d23ab",
      "language": "csharp",
      "size": 783,
      "content": "using System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    /// <summary>\n    /// DTO used to create or retrieve AutoReplyRule.\n    /// </summary>\n    public class AutoReplyRuleDto\n    {\n        public Guid? Id { get; set; } // Nullable to allow re-use for Create and Update\n        public string TriggerKeyword { get; set; } = string.Empty;\n        public string ReplyMessage { get; set; } = string.Empty;\n        public string? MediaUrl { get; set; } // Optional media\n        public int Priority { get; set; } = 0; // Lower = higher priority\n        public bool IsActive { get; set; } = true;\n\n        // Audit Fields (optional for now, useful for admin UI)\n        public DateTime? CreatedAt { get; set; }\n        public DateTime? UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ButtonChoiceNodeConfig.cs",
      "sha256": "a573ed18c3b3cce438f3f126b958408f9c6245ac01be98c3db1d0c4a92adbb18",
      "language": "csharp",
      "size": 577,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ButtonChoiceNodeConfig\n    {\n        public string PromptText { get; set; } = \"Please choose an option:\";\n\n        public List<ButtonOption> Options { get; set; } = new();\n    }\n\n    public class ButtonOption\n    {\n        public string Label { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n\n        // Optional metadata to control button behavior\n        public string? NextStepHint { get; set; } // Can guide user or be used for logging\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ConditionNodeConfig.cs",
      "sha256": "836736c40f25f700d3a84836ee147930568713f5f623bcdc1569b42ff5b4432e",
      "language": "csharp",
      "size": 306,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ConditionNodeConfig\n    {\n    \n        public string InputKey { get; set; } = \"buttonText\";\n\n        public Dictionary<string, string> PathMap { get; set; } = new();\n       \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/DecisionNodeConfig.cs",
      "sha256": "5575668b5865a5bb2847165208e60278c44386e8f710abb968606e22bb52fe70",
      "language": "csharp",
      "size": 418,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class DecisionNodeConfig\n    {\n        public string ConditionType { get; set; } = \"keyword\"; // or \"tag\", \"time\", \"plan\", etc.\n        public string Parameter { get; set; } = string.Empty;   // e.g. \"yes\", \"vip\", \"evening\"\n        public string SourceChannel { get; set; } = \"whatsapp\"; // Optional for multi-channel control\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormInputNodeConfig.cs",
      "sha256": "34b1ef9a54bc19dbb2163a80371edaf8d5bf75420e9924e90e82762fa4831216",
      "language": "csharp",
      "size": 596,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormInputNodeConfig\n    {\n        public string QuestionText { get; set; } = \"Please enter your response:\";\n\n        public string FieldKey { get; set; } = \"customer_name\";\n        // Used for storing user response under a label\n\n        public string? ValidationRegex { get; set; }\n        // Optional, e.g., @\"^[0-9]{10}$\" for phone numbers\n\n        public string? PlaceholderHint { get; set; }\n        // e.g., \"Full Name\", \"10-digit Phone\"\n\n        public bool IsRequired { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/FormNodeConfig.cs",
      "sha256": "f839475742eb0fc23ab0c6e58e1f23a0583e4b649301ac588feb0808dd1c243d",
      "language": "csharp",
      "size": 818,
      "content": "using System.Collections.Generic;\nnamespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class FormNodeConfig\n    {\n        public string Title { get; set; } = \"Please fill out this form\";\n\n        public List<FormFieldConfig> Fields { get; set; } = new();\n\n        public bool SaveToContact { get; set; } = true; // Whether to update contact info\n\n        public string? SubmitMessage { get; set; } = \"Thanks for submitting!\";\n    }\n\n    public class FormFieldConfig\n    {\n        public string Key { get; set; } = string.Empty;      // contactName, email, phone\n        public string Label { get; set; } = string.Empty;    // \"Your Name\"\n        public string Type { get; set; } = \"text\";           // text, number, email, etc.\n        public bool Required { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/ForwardToAgentNodeConfig.cs",
      "sha256": "486eab52256f3ee2bfea5f06ada3bf8fade4f055f1012e4a1291ac0e61c9f35c",
      "language": "csharp",
      "size": 268,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class ForwardToAgentNodeConfig\n    {\n        public string? NoteToAgent { get; set; } // Optional instruction for agent\n        public bool MarkAsUrgent { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeIconMap.cs",
      "sha256": "e56ce9b9bdedf03682aaa6c56815fb85dd510ecd2ec1e4c82f53c0fa5c8f9401",
      "language": "csharp",
      "size": 591,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeIconMap\n    {\n        public static readonly Dictionary<string, string> IconMap = new()\n        {\n            { NodeTypeEnum.Message, \"🗨️\" },\n            { NodeTypeEnum.Template, \"📄\" },\n            { NodeTypeEnum.Tag, \"🏷️\" },\n            { NodeTypeEnum.Wait, \"⏱️\" },\n            { NodeTypeEnum.ButtonChoice, \"🔘\" },\n            { NodeTypeEnum.Branch, \"🌿\" },\n            { NodeTypeEnum.AgentHandoff, \"👨‍💼\" },\n            { NodeTypeEnum.End, \"⛔\" }\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/FlowNodeConfigs/NodeTypeEnum.cs",
      "sha256": "d21739b3b7651f2a026a4e412de76d45fe215ae50907b0c7ee025bee0c1ed189",
      "language": "csharp",
      "size": 572,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs.FlowNodeConfigs\n{\n    public class NodeTypeEnum\n    {\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Tag = \"tag\";\n        public const string Wait = \"wait\";\n        public const string ButtonChoice = \"button_choice\";\n        public const string Branch = \"branch\";\n        public const string End = \"end\"; // Optional: Used for flow exit\n        public const string AgentHandoff = \"agent_handoff\"; // Optional: Transfer to human\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/RenameFlowDto.cs",
      "sha256": "c2ad4577f121df77190a9463e0eb6528c20054bd0901e7bc9a355aedfb53031c",
      "language": "csharp",
      "size": 146,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.DTOs\n{\n    public class RenameFlowDto\n    {\n        public string NewName { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/SaveFlowDto.cs",
      "sha256": "b4b9d49533bad3114236c255a28ecc08bc82a01f1141b981146f320c76cc39f4",
      "language": "csharp",
      "size": 2315,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n{\n    public class SaveFlowDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public string Name { get; set; }\n        public string? TriggerKeyword { get; set; }\n        public List<NodeDto> Nodes { get; set; } = new();\n        public List<EdgeDto> Edges { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n\n        public string? IndustryTag { get; set; }     // e.g. \"restaurant\", \"clinic\", etc.\n        public string? UseCase { get; set; }         // e.g. \"Order Flow\", \"Appointment Flow\"\n        public bool IsDefaultTemplate { get; set; } = false; // Flag for prebuilt templates\n\n    }\n\n    public class NodeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public AutoPositionDto Position { get; set; } = new();\n        public NodeDataDto Data { get; set; } = new();\n    }\n\n    public class AutoPositionDto\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n    public class NodeDataDto\n    {\n        public string Label { get; set; } = string.Empty;\n        public object Config { get; set; } = new { };\n    }\n\n    public class EdgeDto\n    {\n        public string Id { get; set; } = string.Empty;\n        public string Source { get; set; } = string.Empty;\n        public string Target { get; set; } = string.Empty;\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n        public string SourceHandle { get; set; } = string.Empty;\n        public string TargetHandle { get; set; } = string.Empty;\n    }\n}\n\n\n//using System;\n\n//namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs\n//{\n//    public class SaveFlowDto\n//    {\n//        public Guid Id { get; set; }\n//        public Guid BusinessId { get; set; }\n//        public string Name { get; set; } = string.Empty;\n//        public List<Dictionary<string, object>> Nodes { get; set; }\n\n//        public List<Dictionary<string, object>> Edges { get; set; }\n//        public DateTime CreatedAt { get; set; }\n//        public string? TriggerKeyword { get; set; }\n\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/DTOs/TemplateDto.cs",
      "sha256": "42ae32842447bb89f8178a8bae3c490d1fe646b526c27cbe72571e23536f7116",
      "language": "csharp",
      "size": 240,
      "content": "namespace xbytechat.api.Features.TemplateMessages.DTOs\n{\n    public class TemplateDto\n    {\n        public Guid Id { get; set; }\n        public string Name { get; set; } = string.Empty;\n        public int Placeholders { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/AutoReplyEdgeDto.cs",
      "sha256": "5cbac1daff177794f7ae69aabf6b323f279f0b7132dc060e462a91226849f868",
      "language": "csharp",
      "size": 264,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class AutoReplyEdgeDto\n    {\n        public string Id { get; set; }\n        public string SourceNodeId { get; set; }\n        public string TargetNodeId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/MessageConfig.cs",
      "sha256": "6e7673134b9b3fabb432529dd4b510007ff1d934f016b3a2d831a4503d01c2c7",
      "language": "csharp",
      "size": 201,
      "content": "// MessageConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class MessageConfig\n    {\n        public string Text { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/RuntimeConfigs.cs",
      "sha256": "280793d810ae7ce0f016f2671b3627cd52a4029b6ea574d0fee20e0c0e11e5ae",
      "language": "csharp",
      "size": 125,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class RuntimeConfigs\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TagNodeConfig.cs",
      "sha256": "d9fade9fca5845b7cb33279a01288a4dd94a90aaaed58d384a778209656b5ead",
      "language": "csharp",
      "size": 197,
      "content": "// TagConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TagNodeConfig\n    {\n        public List<string> Tags { get; set; } = new();\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/TemplateConfig.cs",
      "sha256": "5c7ea8f78b131705f6bccf1ced0e21a754dadf67bbd6420696995f565c07767a",
      "language": "csharp",
      "size": 682,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class TemplateConfig\n    {\n        public string TemplateName { get; set; } = string.Empty;\n        public List<string> Placeholders { get; set; } = new();\n        public string? Language { get; set; } = \"en_US\";\n        public string? ImageUrl { get; set; }\n        public List<TemplateButtonDto>? MultiButtons { get; set; } = new();\n    }\n\n    public class TemplateButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string ButtonType { get; set; } = \"url\"; // or \"quick_reply\"\n        public string TargetUrl { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/DTOs/FlowNodeConfigs/WaitConfig.cs",
      "sha256": "afe336952d0d4959422bbbc499884b286291888fcbd64dd068f26013160261c6",
      "language": "csharp",
      "size": 179,
      "content": "// WaitConfig.cs\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs\n{\n    public class WaitConfig\n    {\n        public int Seconds { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Flows/Enum/NodeTypes.cs",
      "sha256": "94b210bd5bbbbce823c3a1beb8172eddf708305bfbb8b897d1e3c7ef10097b36",
      "language": "csharp",
      "size": 538,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Flows.Enum\n{\n    public class NodeTypes\n    {\n        public const string Start = \"start\";\n        public const string Message = \"message\";\n        public const string Template = \"template\";\n        public const string Wait = \"wait\";\n        public const string Tag = \"tag\";\n        public const string Agent = \"agent\";\n        public const string Condition = \"condition\"; // Coming soon\n        public const string Form = \"form\";           // For “Ask Name”, “Ask Email”\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlow.cs",
      "sha256": "2825905f983da1290a44badeda57c8ff26c8920d7fa13e7ebd85dd0da2e0aaca",
      "language": "csharp",
      "size": 1021,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Models\n{\n    public class AutoReplyFlow\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public string Name { get; set; } = string.Empty;\n\n        [Required]\n        public string NodesJson { get; set; } = string.Empty;\n\n        [Required]\n        public string EdgesJson { get; set; } = string.Empty;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? TriggerKeyword { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public string? IndustryTag { get; set; }    // e.g., \"restaurant\", \"clinic\", \"education\"\n        public string? UseCase { get; set; }        // e.g., \"Order Flow\", \"Booking Flow\"\n        public bool IsDefaultTemplate { get; set; } = false; // Flag to indicate system-provided template\n        public string? Keyword { get; set; }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowEdge.cs",
      "sha256": "7996bdb8fa1917943e90dad9ad4225984a34b6342eb153028849b30ca63abd7f",
      "language": "csharp",
      "size": 763,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowEdge\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        public string SourceNodeId { get; set; } = string.Empty;\n        public string TargetNodeId { get; set; } = string.Empty;\n    \n        public string? SourceHandle { get; set; }\n        public string? TargetHandle { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyFlowNode.cs",
      "sha256": "88a50d45fe3b72f6c3bc0593104b7ee549180c842628cb3d9048c5227a025871",
      "language": "csharp",
      "size": 1013,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyFlowNode\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow Flow { get; set; }\n\n        // 🔄 Use a constrained string or enum (recommended for future)\n        [Required]\n        public string NodeType { get; set; } = string.Empty;\n\n        public string Label { get; set; } = string.Empty;\n\n        public string? NodeName { get; set; } // 🆕 Optional internal label for debugging\n\n        [Required]\n        public string ConfigJson { get; set; } = string.Empty;\n\n        public Position Position { get; set; } = new();\n\n        public int Order { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyLog.cs",
      "sha256": "d2949264f0ac5b81395d2dee6578df20759d95d300da30d5f0f9003e0ed1c5eb",
      "language": "csharp",
      "size": 915,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    [Table(\"AutoReplyLogs\")]\n    public class AutoReplyLog\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string TriggerKeyword { get; set; } = string.Empty; // e.g., \"hi\", \"price\"\n        public string TriggerType { get; set; } = string.Empty;     // \"flow\" or \"rule\"\n\n        public string ReplyContent { get; set; } = string.Empty;    // Plaintext summary of what was sent\n        public string? FlowName { get; set; }                       // Nullable if rule-based\n\n        public Guid? MessageLogId { get; set; }                     // Optional link to MessageLog\n        public DateTime TriggeredAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/AutoReplyRule.cs",
      "sha256": "c3049863f7add2dfd09dd962dbdbc904585fa5db4e12ac189193077bfee08a78",
      "language": "csharp",
      "size": 1137,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class AutoReplyRule\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        public Guid BusinessId { get; set; }\n\n        public string TriggerKeyword { get; set; } = string.Empty;\n\n        public string ReplyMessage { get; set; } = string.Empty;\n\n        public string? MediaUrl { get; set; }\n\n        public int Priority { get; set; }\n\n        public bool IsActive { get; set; } = true;\n\n        public DateTime CreatedAt { get; set; }\n\n        public DateTime? UpdatedAt { get; set; }\n\n        public string? FlowName { get; set; }\n\n        // ✅ NEW: Link to the flow\n        public Guid? FlowId { get; set; }\n\n        [ForeignKey(\"FlowId\")]\n        public AutoReplyFlow? Flow { get; set; }\n\n        public string? IndustryTag { get; set; } // e.g., \"restaurant\", \"clinic\", \"real_estate\"\n        public string? SourceChannel { get; set; } // e.g., \"whatsapp\", \"instagram\"\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowExecutionContext.cs",
      "sha256": "0d3e6415c151099db94a6f0f6dc8f695fd31492808dc09079919950efedf0776",
      "language": "csharp",
      "size": 494,
      "content": "using xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class FlowExecutionContext\n    {\n        public AutoReplyFlow Flow { get; set; } = null!;\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n        public string ContactPhone { get; set; } = null!;\n        public string SourceChannel { get; set; } = \"whatsapp\";\n        public string IndustryTag { get; set; } = \"\";\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowNode.cs",
      "sha256": "8991ad6277d58a2785f6a93fd8b8ca815af4ce80351d38f30aaf47890909471f",
      "language": "csharp",
      "size": 318,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class FlowNode\n    {\n        public string Id { get; set; }\n        public string Type { get; set; }\n        public Position Position { get; set; }\n        public Dictionary<string, object> Data { get; set; }  // This should capture config\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/FlowRunResult.cs",
      "sha256": "67982580319a635214c13b2ec05cc279d9afc21fdeb1224248a8060036e27f5c",
      "language": "csharp",
      "size": 463,
      "content": "// File: Features/AutoReplyBuilder/Models/FlowRunResult.cs\n\nusing System;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    /// <summary>\n    /// Encapsulates the result of running a visual flow, including agent handoff status.\n    /// </summary>\n    public class FlowRunResult\n    {\n        public bool NeedsAgent { get; set; } = false;\n\n\n        public Guid? HandoffNodeId { get; set; }\n\n        public string? ContextJson { get; set; }\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Models/Position.cs",
      "sha256": "0c352c43f4dfcebdc462622ca0acdcd8c1eaafa07a91a70804793d8c76724201",
      "language": "csharp",
      "size": 176,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Models\n{\n    public class Position\n    {\n        public double X { get; set; }\n        public double Y { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyFlowRepository.cs",
      "sha256": "d919b1d695c3c29ccc653b806d4884197b3d52fb9eb5f86c0f32f893eb198671",
      "language": "csharp",
      "size": 4350,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\npublic class AutoReplyFlowRepository : IAutoReplyFlowRepository\n{\n    private readonly AppDbContext _context;\n    private readonly ILogger<AutoReplyFlowRepository> _logger;\n\n    public AutoReplyFlowRepository(AppDbContext context, ILogger<AutoReplyFlowRepository> logger)\n    {\n        _context = context;\n        _logger = logger;\n    }\n\n    public async Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow)\n    {\n        _context.AutoReplyFlows.Add(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"❌ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return flow;\n    }\n\n    public async Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges)\n    {\n        _context.AutoReplyFlowNodes.AddRange(nodes);\n        _context.AutoReplyFlowEdges.AddRange(edges);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"❌ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n    }\n\n    public async Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId)\n            .OrderByDescending(f => f.CreatedAt)\n            .ToListAsync();\n    }\n\n    public async Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId)\n    {\n        return await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == flowId && f.BusinessId == businessId);\n    }\n\n    public async Task<int> GetFlowCountAsync(Guid businessId)\n    {\n        return await _context.AutoReplyFlows.CountAsync(f => f.BusinessId == businessId);\n    }\n\n    public async Task<bool> RenameFlowAsync(Guid id, string newName)\n    {\n        var flow = await _context.AutoReplyFlows.FindAsync(id);\n        if (flow == null) return false;\n\n        flow.Name = newName;\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"❌ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n\n    public async Task<bool> DeleteFlowAsync(Guid id, Guid businessId)\n    {\n        var flow = await _context.AutoReplyFlows\n            .FirstOrDefaultAsync(f => f.Id == id && f.BusinessId == businessId);\n\n        if (flow == null) return false;\n\n        _context.AutoReplyFlows.Remove(flow);\n        try\n        {\n            await _context.SaveChangesAsync();\n        }\n        catch (DbUpdateException ex)\n        {\n            _logger.LogError(ex, \"❌ Save failed: {0}\", ex.InnerException?.Message);\n            throw;\n        }\n\n        return true;\n    }\n    public async Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n    public async Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword)\n    {\n        return await _context.AutoReplyFlows\n            .Where(f => f.BusinessId == businessId && f.IsActive && f.TriggerKeyword == keyword)\n            .OrderByDescending(f => f.CreatedAt)\n            .FirstOrDefaultAsync();\n    }\n    public async Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowNodes\n            .Where(n => n.FlowId == flowId)\n            .ToListAsync();\n    }\n\n    public async Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId)\n    {\n        return await _context.AutoReplyFlowEdges\n            .Where(e => e.FlowId == flowId)\n            .ToListAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyLogRepository.cs",
      "sha256": "4a8777aecfb95fef141063dfa3475992a3848fdd582209819e66ab552d045f71",
      "language": "csharp",
      "size": 1569,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Models;\nusing xbytechat.api.Shared;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class AutoReplyLogRepository : IAutoReplyLogRepository\n    {\n        private readonly AppDbContext _context;\n        private readonly ILogger<AutoReplyLogRepository> _logger;\n\n        public AutoReplyLogRepository(AppDbContext context, ILogger<AutoReplyLogRepository> logger)\n        {\n            _context = context;\n            _logger = logger;\n        }\n\n        public async Task SaveAsync(AutoReplyLogDto dto)\n        {\n            try\n            {\n                var log = new AutoReplyLog\n                {\n                    Id = dto.Id,\n                    BusinessId = dto.BusinessId,\n                    ContactId = dto.ContactId,\n                    TriggerKeyword = dto.TriggerKeyword,\n                    TriggerType = dto.TriggerType,\n                    ReplyContent = dto.ReplyContent,\n                    TriggeredAt = dto.TriggeredAt,\n                    FlowName = dto.FlowName,\n                    MessageLogId = dto.MessageLogId\n                };\n\n                _context.AutoReplyLogs.Add(log);\n                await _context.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to save AutoReplyLog\");\n                throw;\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/AutoReplyRepository.cs",
      "sha256": "6339294423a06a5ebeacfa42db916a0e6fcac770f4082cb3db53569c2dd80483",
      "language": "csharp",
      "size": 4077,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class AutoReplyRepository : IAutoReplyRepository\n    {\n        private readonly AppDbContext _dbContext;\n\n        public AutoReplyRepository(AppDbContext dbContext)\n        {\n            _dbContext = dbContext;\n        }\n\n        public async Task<AutoReplyRule> AddAsync(AutoReplyRule rule)\n        {\n            _dbContext.AutoReplyRules.Add(rule);\n            await _dbContext.SaveChangesAsync();\n            return rule;\n        }\n\n        public async Task<IEnumerable<AutoReplyRule>> GetAllByBusinessIdAsync(Guid businessId)\n        {\n            return await _dbContext.AutoReplyRules\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.Priority)\n                .ToListAsync();\n        }\n\n        public async Task<AutoReplyRule?> GetByIdAsync(Guid ruleId, Guid businessId)\n        {\n            return await _dbContext.AutoReplyRules\n                .FirstOrDefaultAsync(r => r.Id == ruleId && r.BusinessId == businessId);\n        }\n\n        public async Task<bool> UpdateAsync(AutoReplyRule rule)\n        {\n            _dbContext.AutoReplyRules.Update(rule);\n            return await _dbContext.SaveChangesAsync() > 0;\n        }\n\n        public async Task<bool> DeleteAsync(Guid ruleId, Guid businessId)\n        {\n            var rule = await GetByIdAsync(ruleId, businessId);\n            if (rule == null) return false;\n\n            _dbContext.AutoReplyRules.Remove(rule);\n            return await _dbContext.SaveChangesAsync() > 0;\n        }\n\n        public async Task<AutoReplyRule?> MatchByKeywordAsync(Guid businessId, string incomingMessage)\n        {\n            return await _dbContext.AutoReplyRules\n                .Where(r => r.BusinessId == businessId && r.IsActive)\n                .OrderBy(r => r.Priority)\n                .FirstOrDefaultAsync(r => incomingMessage.Contains(r.TriggerKeyword));\n        }\n\n        public async Task<bool> LinkFlowToRuleAsync(Guid businessId, string keyword, Guid flowId, string? flowName)\n        {\n            var rule = await _dbContext.AutoReplyRules\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.TriggerKeyword.ToLower() == keyword.ToLower());\n\n            if (rule == null) return false;\n\n            rule.FlowId = flowId;\n            rule.FlowName = flowName ?? \"\";\n            rule.UpdatedAt = DateTime.UtcNow;\n\n            await _dbContext.SaveChangesAsync();\n            return true;\n        }\n        public async Task<AutoReplyRule> UpsertRuleLinkedToFlowAsync(Guid businessId, string keyword, Guid flowId, string? flowName)\n        {\n            // Ensure keyword is normalized\n            var normalizedKeyword = keyword.ToLower().Trim();\n\n            var rule = await _dbContext.AutoReplyRules\n                .FirstOrDefaultAsync(r => r.BusinessId == businessId && r.TriggerKeyword.ToLower() == normalizedKeyword);\n\n            if (rule != null)\n            {\n                // Update existing rule\n                rule.FlowId = flowId;\n                rule.FlowName = flowName ?? \"\";\n                rule.UpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                // Create new rule\n                rule = new AutoReplyRule\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    TriggerKeyword = normalizedKeyword,\n                    FlowId = flowId,\n                    FlowName = flowName ?? \"\",\n                    CreatedAt = DateTime.UtcNow,\n                    IsActive = true,\n                    Priority = 1,\n                    ReplyMessage = \"\" // Fallback (optional)\n                };\n\n                _dbContext.AutoReplyRules.Add(rule);\n            }\n\n            await _dbContext.SaveChangesAsync();\n            return rule;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/FlowRepository.cs",
      "sha256": "215b4fc5005e126adf33375390d0ac254a146dbdae11aa8c98eb52aa9054551b",
      "language": "csharp",
      "size": 111,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class FlowRepository\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyFlowRepository.cs",
      "sha256": "f78ae431c2892c49cc0844c2f19e5df301598c964326722b3ca52aec7e9ba61d",
      "language": "csharp",
      "size": 1161,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories\n{\n    public interface IAutoReplyFlowRepository\n    {\n        Task<AutoReplyFlow> SaveAsync(AutoReplyFlow flow);\n        Task<AutoReplyFlow?> GetByIdAsync(Guid flowId, Guid businessId);\n        Task<List<AutoReplyFlow>> GetAllByBusinessIdAsync(Guid businessId);\n        Task<int> GetFlowCountAsync(Guid businessId);\n        Task<bool> RenameFlowAsync(Guid id, string newName);\n        Task<bool> DeleteFlowAsync(Guid id, Guid businessId);\n        Task SaveNodesAndEdgesAsync(IEnumerable<AutoReplyFlowNode> nodes, IEnumerable<AutoReplyFlowEdge> edges);\n        Task<List<AutoReplyFlowNode>> GetNodesByFlowIdAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetEdgesByFlowIdAsync(Guid flowId);\n        Task<AutoReplyFlow?> FindFlowByKeywordAsync(Guid businessId, string keyword);\n        Task<List<AutoReplyFlowNode>> GetStructuredNodesAsync(Guid flowId);\n        Task<List<AutoReplyFlowEdge>> GetStructuredEdgesAsync(Guid flowId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyLogRepository.cs",
      "sha256": "49f1ecf8c4ab7bb6a0122d7d98e22eb4cb6e2b4b522c99c3963ca64d57889264",
      "language": "csharp",
      "size": 255,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public interface IAutoReplyLogRepository\n    {\n        Task SaveAsync(AutoReplyLogDto logDto);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IAutoReplyRepository.cs",
      "sha256": "136fdda2ad552eadc942d50774dc0ba7cf0796c507e703b6aa20f4fd64fd40d5",
      "language": "csharp",
      "size": 939,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public interface IAutoReplyRepository\n    {\n        Task<AutoReplyRule> AddAsync(AutoReplyRule rule);\n        Task<IEnumerable<AutoReplyRule>> GetAllByBusinessIdAsync(Guid businessId);\n        Task<AutoReplyRule?> GetByIdAsync(Guid ruleId, Guid businessId);\n        Task<bool> UpdateAsync(AutoReplyRule rule);\n        Task<bool> DeleteAsync(Guid ruleId, Guid businessId);\n\n        // Runtime keyword match logic\n        Task<AutoReplyRule?> MatchByKeywordAsync(Guid businessId, string incomingMessage);\n        Task<bool> LinkFlowToRuleAsync(Guid businessId, string keyword, Guid flowId, string? flowName);\n        Task<AutoReplyRule> UpsertRuleLinkedToFlowAsync(Guid businessId, string keyword, Guid flowId, string? flowName);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Repositories/IFlowRepository.cs",
      "sha256": "dc4b9a1195add53536172098cfd18c52a19a3a5c767ba81f25e2bceb2a483e14",
      "language": "csharp",
      "size": 112,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Repositories\n{\n    public class IFlowRepository\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyFlowService.cs",
      "sha256": "60a2f344bc7993fa13dd56c9514c142e4a3bb6100c4e6f48056178d09d8d71b4",
      "language": "csharp",
      "size": 24746,
      "content": "using Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\nusing System.Numerics;\nusing System.Text.Json;\nusing xbytechat.api.CRM.Interfaces;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Repositories;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Services\n{\n    public class AutoReplyFlowService : IAutoReplyFlowService\n    {\n        private readonly IAutoReplyFlowRepository _flowRepository;\n        private readonly ILogger<AutoReplyFlowService> _logger;\n        private readonly IMessageEngineService _messageService;\n        private readonly ITagService _tagService;\n        private readonly IAutoReplyRepository _autoReplyRepository;\n        public AutoReplyFlowService(IAutoReplyFlowRepository flowrepository, ILogger<AutoReplyFlowService> logger,\n            IMessageEngineService messageService, ITagService tagService, IAutoReplyRepository autoReplyRepository)\n        {\n            _flowRepository = flowrepository;\n            _logger = logger;\n            _messageService = messageService;\n            _tagService = tagService;\n            _autoReplyRepository = autoReplyRepository;\n        }\n\n        //public async Task<Guid> SaveFlowAsync(SaveFlowDto dto)\n        //{\n        //    _logger.LogInformation(\"🔄 Starting flow save for business {BusinessId} with keyword '{Keyword}'\", dto.BusinessId, dto.TriggerKeyword);\n\n        //    var flow = new AutoReplyFlow\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = dto.BusinessId,\n        //        Name = dto.Name,\n        //        NodesJson = JsonConvert.SerializeObject(dto.Nodes),\n        //        EdgesJson = JsonConvert.SerializeObject(dto.Edges),\n        //        TriggerKeyword = dto.TriggerKeyword?.Trim().ToLower(),\n        //        IsActive = true,\n        //        CreatedAt = DateTime.UtcNow\n        //    };\n\n        //    var saved = await _flowRepository.SaveAsync(flow);\n        //    _logger.LogInformation(\"✅ Flow saved: {FlowId}\", saved.Id);\n\n        //    // ✅ Save parsed nodes\n        //    var parsedNodes = new List<AutoReplyFlowNode>();\n        //    var nodes = dto.Nodes as List<Dictionary<string, object>>;\n\n        //    if (nodes != null)\n        //    {\n        //        foreach (var nodeDict in nodes)\n        //        {\n        //            if (!nodeDict.ContainsKey(\"type\") || !nodeDict.ContainsKey(\"data\") || !nodeDict.ContainsKey(\"position\"))\n        //            {\n        //                _logger.LogWarning(\"⚠️ Skipped malformed node during flow save: {Node}\", JsonConvert.SerializeObject(nodeDict));\n        //                continue;\n        //            }\n\n        //            var data = nodeDict[\"data\"] as Dictionary<string, object>;\n        //            var positionDict = nodeDict[\"position\"] as Dictionary<string, object>;\n\n        //            var position = new Position\n        //            {\n        //                X = Convert.ToDouble(positionDict?[\"x\"] ?? 0),\n        //                Y = Convert.ToDouble(positionDict?[\"y\"] ?? 0)\n        //            };\n\n        //            parsedNodes.Add(new AutoReplyFlowNode\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                FlowId = saved.Id,\n        //                NodeType = nodeDict[\"type\"]?.ToString() ?? \"\",\n        //                Label = data?[\"label\"]?.ToString() ?? \"\",\n        //                ConfigJson = JsonConvert.SerializeObject(data?[\"config\"] ?? new { }),\n        //                Position = position // ✅ strongly typed\n        //            });\n        //        }\n        //    }\n\n        //    _logger.LogInformation(\"🧩 Parsed {NodeCount} nodes\", parsedNodes.Count);\n\n        //    // ✅ Save parsed edges\n        //    var parsedEdges = new List<AutoReplyFlowEdge>();\n        //    var edges = dto.Edges as List<Dictionary<string, object>>;\n\n        //    if (edges != null)\n        //    {\n        //        foreach (var edgeDict in edges)\n        //        {\n        //            if (!edgeDict.ContainsKey(\"source\") || !edgeDict.ContainsKey(\"target\"))\n        //            {\n        //                _logger.LogWarning(\"⚠️ Skipped malformed edge during flow save: {Edge}\", JsonConvert.SerializeObject(edgeDict));\n        //                continue;\n        //            }\n\n        //            parsedEdges.Add(new AutoReplyFlowEdge\n        //            {\n        //                Id = Guid.NewGuid(),\n        //                FlowId = saved.Id,\n        //                SourceNodeId = edgeDict[\"source\"]?.ToString() ?? \"\",\n        //                TargetNodeId = edgeDict[\"target\"]?.ToString() ?? \"\",\n        //                CreatedAt = DateTime.UtcNow\n        //            });\n        //        }\n        //    }\n\n        //    _logger.LogInformation(\"🔗 Parsed {EdgeCount} edges\", parsedEdges.Count);\n\n        //    await _flowRepository.SaveNodesAndEdgesAsync(parsedNodes, parsedEdges);\n\n        //    _logger.LogInformation(\"✅ Node + edge persistence complete for flow {FlowId}\", saved.Id);\n\n        //    return saved.Id;\n        //}\n\n        //public async Task<Guid> SaveFlowAsync(SaveFlowDto dto)\n        //{\n        //    _logger.LogInformation(\"🔄 Starting flow save for business {BusinessId} with keyword '{Keyword}'\", dto.BusinessId, dto.TriggerKeyword);\n\n        //    // ✅ Step 1: Save main flow\n        //    var flow = new AutoReplyFlow\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = dto.BusinessId,\n        //        Name = dto.Name?.Trim() ?? \"\",\n        //        NodesJson = JsonConvert.SerializeObject(dto.Nodes),\n        //        EdgesJson = JsonConvert.SerializeObject(dto.Edges),\n        //        TriggerKeyword = dto.TriggerKeyword?.Trim().ToLower(),\n        //        IsActive = true,\n        //        CreatedAt = DateTime.UtcNow\n        //    };\n\n        //    var saved = await _flowRepository.SaveAsync(flow);\n        //    _logger.LogInformation(\"✅ Flow saved: {FlowId}\", saved.Id);\n\n        //    // ✅ Step 2: Build ID map and parse nodes\n        //    var nodeIdMap = new Dictionary<string, Guid>();\n        //    var parsedNodes = new List<AutoReplyFlowNode>();\n\n        //    foreach (var n in dto.Nodes)\n        //    {\n        //        if (string.IsNullOrWhiteSpace(n.Id))\n        //        {\n        //            _logger.LogWarning(\"⚠️ Skipped node with missing Id\");\n        //            continue;\n        //        }\n\n        //        var internalNodeId = Guid.NewGuid();\n        //        nodeIdMap[n.Id] = internalNodeId;\n\n        //        parsedNodes.Add(new AutoReplyFlowNode\n        //        {\n        //            Id = internalNodeId,\n        //            FlowId = saved.Id,\n        //            NodeType = n.Type,\n        //            Label = n.Data?.Label ?? \"\",\n        //            ConfigJson = JsonConvert.SerializeObject(n.Data?.Config ?? new { }),\n        //            Position = new Position\n        //            {\n        //                X = n.Position?.X ?? 0,\n        //                Y = n.Position?.Y ?? 0\n        //            },\n        //            CreatedAt = DateTime.UtcNow\n        //        });\n        //    }\n\n        //    _logger.LogInformation(\"🧩 Parsed {NodeCount} nodes\", parsedNodes.Count);\n\n        //    // ✅ Step 3: Map Source/TargetNodeId from external → internal GUIDs\n        //    var parsedEdges = new List<AutoReplyFlowEdge>();\n\n        //    foreach (var e in dto.Edges)\n        //    {\n        //        if (!nodeIdMap.TryGetValue(e.SourceNodeId ?? \"\", out var sourceId))\n        //        {\n        //            _logger.LogWarning(\"⚠️ Edge skipped: SourceNodeId '{Source}' not found\", e.SourceNodeId);\n        //            continue;\n        //        }\n\n        //        if (!nodeIdMap.TryGetValue(e.TargetNodeId ?? \"\", out var targetId))\n        //        {\n        //            _logger.LogWarning(\"⚠️ Edge skipped: TargetNodeId '{Target}' not found\", e.TargetNodeId);\n        //            continue;\n        //        }\n\n        //        parsedEdges.Add(new AutoReplyFlowEdge\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            FlowId = saved.Id,\n        //            SourceNodeId = sourceId.ToString(),\n        //            TargetNodeId = targetId.ToString(),\n        //            CreatedAt = DateTime.UtcNow\n        //        });\n        //    }\n\n        //    _logger.LogInformation(\"🔗 Parsed {EdgeCount} edges\", parsedEdges.Count);\n\n        //    // ✅ Final Save\n        //    await _flowRepository.SaveNodesAndEdgesAsync(parsedNodes, parsedEdges);\n        //    _logger.LogInformation(\"✅ Node + edge persistence complete for flow {FlowId}\", saved.Id);\n\n        //    return saved.Id;\n        //}\n        //public async Task<Guid> SaveFlowAsync(SaveFlowDto dto)\n        //{\n        //    _logger.LogInformation(\"🔄 Starting flow save for business {BusinessId} with keyword '{Keyword}'\", dto?.BusinessId, dto?.TriggerKeyword);\n\n        //    if (dto == null) throw new ArgumentNullException(nameof(dto));\n        //    if (dto.BusinessId == Guid.Empty) throw new ArgumentException(\"BusinessId is required.\");\n        //    if (string.IsNullOrWhiteSpace(dto.TriggerKeyword)) throw new ArgumentException(\"TriggerKeyword is required.\");\n        //    if (dto.Nodes == null || !dto.Nodes.Any()) throw new ArgumentException(\"At least one node is required.\");\n\n        //    dto.Edges ??= new List<EdgeDto>();\n\n        //    // ✅ Step 1: Save Flow\n        //    var flow = new AutoReplyFlow\n        //    {\n        //        Id = Guid.NewGuid(),\n        //        BusinessId = dto.BusinessId,\n        //        Name = dto.Name?.Trim() ?? \"\",\n        //        NodesJson = JsonConvert.SerializeObject(dto.Nodes),\n        //        EdgesJson = JsonConvert.SerializeObject(dto.Edges),\n        //        TriggerKeyword = dto.TriggerKeyword?.Trim().ToLower(),\n        //        IsActive = true,\n        //        CreatedAt = DateTime.UtcNow\n        //    };\n\n        //    var savedFlow = await _flowRepository.SaveAsync(flow);\n        //    _logger.LogInformation(\"✅ Flow saved: {FlowId}\", savedFlow.Id);\n\n        //    // ✅ Step 2: Parse Nodes\n        //    var nodeIdMap = new Dictionary<string, Guid>();\n        //    var parsedNodes = new List<AutoReplyFlowNode>();\n\n        //    foreach (var n in dto.Nodes)\n        //    {\n        //        if (string.IsNullOrWhiteSpace(n.Id)) continue;\n\n        //        var internalNodeId = Guid.NewGuid();\n        //        nodeIdMap[n.Id] = internalNodeId;\n\n        //        string configJson = n.Data?.Config is JsonElement elem\n        //            ? elem.GetRawText()\n        //            : JsonConvert.SerializeObject(n.Data?.Config ?? new { });\n\n        //        parsedNodes.Add(new AutoReplyFlowNode\n        //        {\n        //            Id = internalNodeId,\n        //            FlowId = savedFlow.Id,\n        //            NodeType = n.Type,\n        //            Label = n.Data?.Label ?? \"\",\n        //            ConfigJson = configJson,\n        //            Position = new Position\n        //            {\n        //                X = n.Position?.X ?? 0,\n        //                Y = n.Position?.Y ?? 0\n        //            },\n        //            CreatedAt = DateTime.UtcNow\n        //        });\n        //    }\n\n        //    _logger.LogInformation(\"🧩 Parsed {NodeCount} nodes\", parsedNodes.Count);\n\n        //    // ✅ Step 3: Parse Edges\n        //    var parsedEdges = new List<AutoReplyFlowEdge>();\n\n        //    foreach (var e in dto.Edges)\n        //    {\n        //        if (!nodeIdMap.TryGetValue(e.SourceNodeId ?? \"\", out var sourceId)) continue;\n        //        if (!nodeIdMap.TryGetValue(e.TargetNodeId ?? \"\", out var targetId)) continue;\n\n        //        parsedEdges.Add(new AutoReplyFlowEdge\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            FlowId = savedFlow.Id,\n        //            SourceNodeId = sourceId.ToString(),\n        //            TargetNodeId = targetId.ToString(),\n        //            SourceHandle = e.SourceHandle, \n        //            TargetHandle = e.TargetHandle, \n        //            CreatedAt = DateTime.UtcNow\n        //        });\n        //    }\n\n        //    _logger.LogInformation(\"🔗 Parsed {EdgeCount} edges\", parsedEdges.Count);\n\n        //    // ✅ Step 4: Save Nodes + Edges\n        //    await _flowRepository.SaveNodesAndEdgesAsync(parsedNodes, parsedEdges);\n        //    _logger.LogInformation(\"✅ Node + edge persistence complete for flow {FlowId}\", savedFlow.Id);\n\n        //    // ✅ Step 5: Link to Rule via Repository\n        //    var keyword = dto.TriggerKeyword.Trim().ToLower();\n        //    var rule = await _autoReplyRepository.UpsertRuleLinkedToFlowAsync(dto.BusinessId, keyword, savedFlow.Id, dto.Name);\n\n        //    _logger.LogInformation(\"🔁 Linked flow to auto-reply rule: {RuleId}\", rule.Id);\n\n        //    return savedFlow.Id;\n        //}\n        public async Task<Guid> SaveFlowAsync(SaveFlowDto dto, Guid businessId)\n        {\n            _logger.LogInformation(\"🔄 Starting flow save for business {BusinessId} with keyword '{Keyword}'\", businessId, dto?.TriggerKeyword);\n\n            if (dto == null) throw new ArgumentNullException(nameof(dto));\n            if (string.IsNullOrWhiteSpace(dto.TriggerKeyword)) throw new ArgumentException(\"TriggerKeyword is required.\");\n            if (dto.Nodes == null || !dto.Nodes.Any()) throw new ArgumentException(\"At least one node is required.\");\n\n            dto.Edges ??= new List<EdgeDto>();\n\n            // ✅ Step 1: Save Flow\n            var flow = new AutoReplyFlow\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId, // << Use parameter, not from dto!\n                Name = dto.Name?.Trim() ?? \"\",\n                NodesJson = JsonConvert.SerializeObject(dto.Nodes),\n                EdgesJson = JsonConvert.SerializeObject(dto.Edges),\n                TriggerKeyword = dto.TriggerKeyword?.Trim().ToLower(),\n                IsActive = true,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            var savedFlow = await _flowRepository.SaveAsync(flow);\n            _logger.LogInformation(\"✅ Flow saved: {FlowId}\", savedFlow.Id);\n\n            // ... rest of code unchanged ...\n\n            // ✅ Step 5: Link to Rule via Repository\n            var keyword = dto.TriggerKeyword.Trim().ToLower();\n            var rule = await _autoReplyRepository.UpsertRuleLinkedToFlowAsync(\n                businessId, // << Use parameter, not from dto!\n                keyword, savedFlow.Id, dto.Name);\n\n            _logger.LogInformation(\"🔁 Linked flow to auto-reply rule: {RuleId}\", rule.Id);\n\n            return savedFlow.Id;\n        }\n\n        public async Task<List<SaveFlowDto>> GetFlowsByBusinessIdAsync(Guid businessId)\n        {\n            _logger.LogInformation(\"📥 Fetching auto-reply flows for business {BusinessId}\", businessId);\n\n            var flows = await _flowRepository.GetAllByBusinessIdAsync(businessId);\n\n            var results = flows.Select(f => new SaveFlowDto\n            {\n                Id = f.Id,\n                BusinessId = f.BusinessId,\n                Name = f.Name,\n                Nodes = string.IsNullOrEmpty(f.NodesJson)\n                    ? new()\n                    : JsonConvert.DeserializeObject<List<NodeDto>>(f.NodesJson),\n\n                Edges = string.IsNullOrEmpty(f.EdgesJson)\n                    ? new()\n                    : JsonConvert.DeserializeObject<List<EdgeDto>>(f.EdgesJson),\n\n\n                CreatedAt = f.CreatedAt\n            }).ToList();\n\n            _logger.LogInformation(\"📤 Returned {Count} auto-reply flows for business {BusinessId}\", results.Count, businessId);\n\n            return results;\n        }\n\n        public async Task<SaveFlowDto?> GetFlowByIdAsync(Guid flowId, Guid businessId)\n        {\n            var flow = await _flowRepository.GetByIdAsync(flowId, businessId);\n            if (flow == null)\n            {\n                _logger.LogWarning(\"❌ No flow found for FlowId {FlowId} and BusinessId {BusinessId}\", flowId, businessId);\n                return null;\n            }\n\n            var nodes = await _flowRepository.GetNodesByFlowIdAsync(flowId);\n            var edges = await _flowRepository.GetEdgesByFlowIdAsync(flowId);\n\n            var mappedNodes = nodes.Select(n => new Dictionary<string, object>\n            {\n                [\"id\"] = n.Id,\n                [\"type\"] = n.NodeType,\n                [\"position\"] = new Dictionary<string, object>\n                {\n                    [\"x\"] = n.Position?.X ?? 0,\n                    [\"y\"] = n.Position?.Y ?? 0\n                },\n                [\"data\"] = new Dictionary<string, object>\n                {\n                    [\"label\"] = n.Label,\n                    [\"config\"] = string.IsNullOrEmpty(n.ConfigJson)\n                        ? null\n                        : JsonConvert.DeserializeObject<object>(n.ConfigJson)\n                }\n            }).ToList();\n\n            var mappedEdges = edges.Select(e => new Dictionary<string, object>\n            {\n                [\"id\"] = e.Id,\n                [\"source\"] = e.SourceNodeId,\n                [\"target\"] = e.TargetNodeId\n            }).ToList();\n\n            _logger.LogInformation(\"📤 Returning flow {FlowId} with {NodeCount} nodes and {EdgeCount} edges\", flow.Id, mappedNodes.Count, mappedEdges.Count);\n\n            return new SaveFlowDto\n            {\n                Id = flow.Id,\n                BusinessId = flow.BusinessId,\n                Name = flow.Name,\n                Nodes = JsonConvert.DeserializeObject<List<NodeDto>>(JsonConvert.SerializeObject(mappedNodes)),\n                Edges = JsonConvert.DeserializeObject<List<EdgeDto>>(JsonConvert.SerializeObject(mappedEdges)),\n                CreatedAt = flow.CreatedAt\n            };\n\n        }\n\n        public async Task<int> GetFlowCountForBusinessAsync(Guid businessId)\n        {\n            return await _flowRepository.GetFlowCountAsync(businessId);\n        }\n\n        public async Task<bool> RenameFlowAsync(Guid id, string newName)\n        {\n            return await _flowRepository.RenameFlowAsync(id, newName);\n        }\n        public async Task<bool> DeleteFlowAsync(Guid id, Guid businessId)\n        {\n            return await _flowRepository.DeleteFlowAsync(id, businessId);\n        }\n        public async Task ExecuteFlowAsync(Guid businessId, string triggerKeyword, string customerPhone)\n        {\n            var flow = await _flowRepository.FindFlowByKeywordAsync(businessId, triggerKeyword);\n            if (flow == null) return;\n\n            var nodes = await _flowRepository.GetNodesByFlowIdAsync(flow.Id);\n            var edges = await _flowRepository.GetEdgesByFlowIdAsync(flow.Id);\n\n            var nodeMap = nodes.ToDictionary(n => n.Id, n => n);\n            var edgeMap = edges.GroupBy(e => e.SourceNodeId)\n                               .ToDictionary(g => g.Key, g => g.ToList());\n\n            var current = nodes.FirstOrDefault(n => n.NodeType == \"start\");\n            while (current != null)\n            {\n                switch (current.NodeType)\n                {\n                    case \"message\":\n                        var msgCfg = JsonConvert.DeserializeObject<MessageConfig>(current.ConfigJson);\n                        await _messageService.SendTextDirectAsync(new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = customerPhone,\n                            TextContent = msgCfg.Text\n                        });\n\n                        break;\n                    case \"template\":\n                        var tempCfg = JsonConvert.DeserializeObject<TemplateConfig>(current.ConfigJson);\n\n                        var dto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = customerPhone,\n                            TemplateName = tempCfg.TemplateName,\n                            TemplateParameters = tempCfg.Placeholders ?? new List<string>()\n                        };\n\n                        await _messageService.SendTemplateMessageSimpleAsync(businessId, dto);\n                        break;\n\n\n                    case \"wait\":\n                        var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(current.ConfigJson);\n                        await Task.Delay(TimeSpan.FromSeconds(waitCfg.Seconds));\n                        break;\n\n                    case \"tag\":\n                        var tagCfg = JsonConvert.DeserializeObject<TagNodeConfig>(current.ConfigJson);\n                        await _tagService.AssignTagsAsync(businessId, customerPhone, tagCfg.Tags);\n                        break;\n                }\n\n                var nextEdge = edgeMap.ContainsKey(current.Id.ToString())\n                     ? edgeMap[current.Id.ToString()].FirstOrDefault()\n                        : null;\n\n                if (nextEdge == null) break;\n\n                current = nodeMap.ContainsKey(Guid.Parse(nextEdge.TargetNodeId))\n                    ? nodeMap[Guid.Parse(nextEdge.TargetNodeId)]\n                    : null;\n\n            }\n        }\n        public async Task TriggerAutoReplyAsync(Guid businessId, string incomingText, string phone)\n        {\n            // Step 1: Find flow matching keyword\n            var flow = await _flowRepository.FindFlowByKeywordAsync(businessId, incomingText.ToLower());\n            if (flow == null) return;\n\n            // Step 2: Load flow nodes + edges\n            var nodes = await _flowRepository.GetStructuredNodesAsync(flow.Id);\n            var edges = await _flowRepository.GetStructuredEdgesAsync(flow.Id);\n\n            // Step 3: Find start node\n            var startNode = nodes.FirstOrDefault(n => n.NodeType == \"start\");\n            if (startNode == null) return;\n\n            var visited = new HashSet<string>();\n            var currentNodeId = startNode.Id.ToString();\n\n            while (!string.IsNullOrEmpty(currentNodeId) && !visited.Contains(currentNodeId))\n            {\n                visited.Add(currentNodeId);\n\n                var currentNode = nodes.FirstOrDefault(n => n.Id.ToString() == currentNodeId);\n                if (currentNode == null) break;\n\n                // Step 4: Handle current node\n                switch (currentNode.NodeType)\n                {\n                    case \"message\":\n                        var config = JsonConvert.DeserializeObject<MessageConfig>(currentNode.ConfigJson);\n                        await _messageService.SendTextDirectAsync(new TextMessageSendDto\n                        {\n                            BusinessId = businessId,\n                            RecipientNumber = phone,\n                            TextContent = config.Text\n                        });\n                        break;\n\n                    case \"template\":\n                        var tpl = JsonConvert.DeserializeObject<TemplateConfig>(currentNode.ConfigJson);\n\n                        var dto = new SimpleTemplateMessageDto\n                        {\n                            RecipientNumber = phone,\n                            TemplateName = tpl.TemplateName,\n                            TemplateParameters = tpl.Placeholders ?? new List<string>()\n                        };\n\n                        await _messageService.SendTemplateMessageSimpleAsync(businessId, dto);\n                        break;\n\n\n                    case \"wait\":\n                        var waitConfig = JsonConvert.DeserializeObject<WaitConfig>(currentNode.ConfigJson);\n                        await Task.Delay(waitConfig.Seconds * 1000); // Can replace with async scheduling later\n                        break;\n\n                    case \"tag\":\n                        var tagConfig = JsonConvert.DeserializeObject<TagNodeConfig>(currentNode.ConfigJson);\n                        await _tagService.AssignTagsAsync(businessId,phone, tagConfig.Tags);\n                        break;\n\n                }\n\n                // Step 5: Find next node\n                var nextEdge = edges.FirstOrDefault(e => e.SourceNodeId == currentNodeId);\n                currentNodeId = nextEdge?.TargetNodeId;\n            }\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyRuntimeService.cs",
      "sha256": "f9e35069e50bbf3a57f0c5134ae99c32f604d94885000c29aacb8ddab0d00d94",
      "language": "csharp",
      "size": 26209,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\nusing xbytechat.api.DTOs.Messages;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs.FlowNodeConfigs;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.Repositories;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Repositories;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Services;\nusing xbytechat.api;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.CRM.Interfaces;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class AutoReplyRuntimeService : IAutoReplyRuntimeService\n    {\n        private readonly IAutoReplyRepository _autoReplyRepo;\n        private readonly IAutoReplyFlowRepository _flowRepo;\n        private readonly IMessageEngineService _messageEngine;\n        private readonly AppDbContext _context;\n        private readonly ILogger<AutoReplyRuntimeService> _logger;\n        private readonly IContactService _contactService;\n        private readonly ITagService _tagService;\n        private readonly ITemplateMessageSender _templateSender;\n        public AutoReplyRuntimeService(\n            IAutoReplyRepository autoReplyRepo,\n            IAutoReplyFlowRepository flowRepo,\n            IMessageEngineService messageEngine,\n            AppDbContext context,\n            ILogger<AutoReplyRuntimeService> logger, IContactService contactService, ITagService tagService, ITemplateMessageSender templateSender)\n        {\n            _autoReplyRepo = autoReplyRepo;\n            _flowRepo = flowRepo;\n            _messageEngine = messageEngine;\n            _context = context;\n            _logger = logger;\n            _contactService = contactService;\n            _tagService = tagService;\n            _templateSender = templateSender;\n        }\n\n        public async Task<bool> TryRunAutoReplyFlowAsync(Guid businessId, string keyword, Guid contactId, string phone)\n        {\n            _logger.LogInformation(\"🔍 Auto-reply trigger: '{Keyword}' from {Phone}\", keyword, phone);\n\n            try\n            {\n                // 1️⃣ Try matching a flow by keyword\n                var flow = await _flowRepo.FindFlowByKeywordAsync(businessId, keyword);\n                if (flow != null)\n                {\n                    _logger.LogInformation(\"✅ Flow matched: {FlowName}\", flow.Name);\n                    await RunFlowAsync(flow.Id, businessId, contactId, phone, keyword, flow.Name);\n                    return true;\n                }\n\n                // 2️⃣ Fallback: Try matching auto-reply rule\n                var rule = await _autoReplyRepo.MatchByKeywordAsync(businessId, keyword);\n                if (rule != null)\n                {\n                    _logger.LogInformation(\"🔁 Fallback auto-reply triggered: {Rule}\", rule.TriggerKeyword);\n\n                    var messageDto = new TextMessageSendDto\n                    {\n                        BusinessId = businessId,\n                        RecipientNumber = phone,\n                        TextContent = rule.ReplyMessage\n                    };\n\n                    var result = await _messageEngine.SendTextDirectAsync(messageDto);\n\n                    await LogAutoReplyAsync(\n                        businessId,\n                        contactId,\n                        keyword,\n                        \"fallback\",\n                        rule.ReplyMessage,\n                        null,\n                        result?.LogId\n                    );\n\n                    return true;\n                }\n\n                _logger.LogWarning(\"❌ No flow or fallback rule matched for: {Keyword}\", keyword);\n                return false;\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Error in TryRunAutoReplyFlowAsync\");\n                return false;\n            }\n        }\n\n        public async Task RunFlowAsync(Guid flowId, Guid businessId, Guid contactId, string phone, string keyword, string flowName)\n        {\n            var nodes = await _flowRepo.GetNodesByFlowIdAsync(flowId);\n            var edges = await _flowRepo.GetEdgesByFlowIdAsync(flowId);\n\n            var nodeDict = nodes.ToDictionary(n => n.Id.ToString(), n => n);\n            var edgeLookup = edges.GroupBy(e => e.SourceNodeId)\n                                  .ToDictionary(g => g.Key, g => g.ToList());\n\n            var currentNodeId = nodes.FirstOrDefault(n => n.NodeType == \"start\")?.Id.ToString();\n            if (string.IsNullOrEmpty(currentNodeId)) return;\n\n            // ✅ Ensure contact exists\n            var contact = await _contactService.FindOrCreateAsync(businessId, phone);\n\n            while (!string.IsNullOrEmpty(currentNodeId))\n            {\n                if (!nodeDict.TryGetValue(currentNodeId, out var node)) break;\n\n                _logger.LogInformation(\"⚙️ Executing node {NodeId} [{NodeType}]\", node.Id, node.NodeType);\n\n                try\n                {\n                    switch (node.NodeType)\n                    {\n                        case \"start\":\n                            _logger.LogInformation(\"🚦 Start node reached: {NodeId}\", node.Id);\n\n                            // 🛑 If Start node contains buttons, STOP and wait for user interaction\n                            try\n                            {\n                                var config = JsonConvert.DeserializeObject<Dictionary<string, object>>(node.ConfigJson ?? \"{}\");\n                                if (config != null && config.TryGetValue(\"multiButtons\", out var rawButtons))\n                                {\n                                    var buttons = JsonConvert.DeserializeObject<List<object>>(rawButtons.ToString() ?? \"[]\");\n                                    if (buttons.Count > 0)\n                                    {\n                                        _logger.LogInformation(\"🛑 Start node has buttons – waiting for user interaction. Halting flow.\");\n                                        return;\n                                    }\n                                }\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"❌ Failed to parse start node config for button detection.\");\n                            }\n                            break;\n\n                        case \"message\":\n                            await ExecuteMessageNodeAsync(node, businessId, contactId, phone, keyword, flowName);\n                            break;\n\n                        case \"template\":\n                            await ExecuteTemplateNodeAsync(node, businessId, contactId, phone, keyword, flowName);\n\n                          \n                                try\n                                {\n                                    var cfg = JsonConvert.DeserializeObject<TemplateConfig>(node.ConfigJson ?? \"{}\");\n                                    if (cfg?.MultiButtons?.Any(b => !string.IsNullOrWhiteSpace(b.ButtonText)) == true)\n                                    {\n                                        _logger.LogInformation(\"🛑 Template node has buttons – halting flow for user click.\");\n                                        return;\n                                    }\n                                }\n\n                            \n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"❌ Failed to parse template config for button detection.\");\n                            }\n                            break;\n\n                        case \"tag\":\n                            await ExecuteTagNodeAsync(businessId, contactId, node);\n                            break;\n\n                        case \"wait\":\n                            try\n                            {\n                                var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(node.ConfigJson ?? \"{}\");\n                                var delayMs = (waitCfg?.Seconds ?? 1) * 1000;\n                                _logger.LogInformation(\"⏳ Wait node delay: {Seconds}s\", waitCfg?.Seconds ?? 1);\n                                await Task.Delay(delayMs);\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"❌ Failed to parse wait config for node {NodeId}\", node.Id);\n                            }\n                            break;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"❌ Error while executing node {NodeId} of type {NodeType}\", node.Id, node.NodeType);\n                }\n\n                currentNodeId = edgeLookup.TryGetValue(currentNodeId, out var next)\n                    ? next.FirstOrDefault()?.TargetNodeId\n                    : null;\n            }\n        }\n\n        private bool TryNodeHasButtons(string? configJson)\n        {\n            if (string.IsNullOrWhiteSpace(configJson)) return false;\n\n            try\n            {\n                var config = JsonConvert.DeserializeObject<Dictionary<string, object>>(configJson);\n                if (config != null && config.TryGetValue(\"multiButtons\", out var rawButtons))\n                {\n                    var buttons = JsonConvert.DeserializeObject<List<object>>(rawButtons.ToString() ?? \"[]\");\n                    return buttons.Count > 0;\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"⚠️ Failed to parse buttons from template config\");\n            }\n\n            return false;\n        }\n\n        private async Task LogAutoReplyAsync(Guid businessId, Guid contactId, string keyword, string type, string replyText, string? flowName, Guid? messageLogId)\n        {\n            var log = new AutoReplyLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                ContactId = contactId,\n                TriggerKeyword = keyword,\n                TriggerType = type,\n                ReplyContent = replyText,\n                FlowName = flowName,\n                MessageLogId = messageLogId,\n                TriggeredAt = DateTime.UtcNow\n            };\n\n            _context.AutoReplyLogs.Add(log);\n            await _context.SaveChangesAsync();\n        }\n\n\n        //    private async Task ExecuteTemplateNodeAsync(\n        //    AutoReplyFlowNode node,\n        //    Guid businessId,\n        //    Guid contactId,\n        //    string phone,\n        //    string keyword,\n        //    string? flowName)\n        //    {\n        //        _logger.LogInformation(\"🧠 Raw config JSON for template node: {Json}\", node.ConfigJson);\n\n        //        TemplateConfig? tmpl;\n        //        try\n        //        {\n        //            tmpl = JsonConvert.DeserializeObject<TemplateConfig>(node.ConfigJson ?? \"{}\");\n        //        }\n        //        catch (Exception ex)\n        //        {\n        //            _logger.LogError(ex, \"❌ Failed to deserialize TemplateConfig for node {NodeId}\", node.Id);\n        //            return;\n        //        }\n\n        //        if (tmpl == null || string.IsNullOrWhiteSpace(tmpl.TemplateName))\n        //        {\n        //            _logger.LogWarning(\"❌ Template node config is missing or invalid.\");\n        //            return;\n        //        }\n\n        //        var contact = await _context.Contacts\n        //            .FirstOrDefaultAsync(c => c.Id == contactId && c.BusinessId == businessId);\n\n        //        if (contact == null)\n        //        {\n        //            _logger.LogWarning(\"❌ Contact not found for AutoReply.\");\n        //            return;\n        //        }\n\n        //        //var buttons = tmpl.MultiButtons?.Select(b => new CampaignButton\n        //        //{\n        //        //    Title = b.ButtonText,\n        //        //    Type = b.ButtonType,\n        //        //    Value = b.TargetUrl\n        //        //}).ToList();\n        //        var buttons = tmpl.MultiButtons?\n        //.Where(b => !string.IsNullOrWhiteSpace(b.ButtonText)) // ✅ Avoid empty\n        //.Select((b, idx) => new\n        //{\n        //    type = \"button\",\n        //    sub_type = b.ButtonType.ToLowerInvariant(), // must be 'quick_reply' or 'url'\n        //    index = idx.ToString(),\n        //    parameters = new List<object>\n        //    {\n        //        new {\n        //            type = \"text\",\n        //            text = b.ButtonText\n        //        }\n        //    }\n        //}).ToList();\n\n        //        var response = await _templateSender.SendTemplateMessageToContactAsync(\n        //            businessId: businessId,\n        //            contact: contact,\n        //            templateName: tmpl.TemplateName,\n        //            templateParams: tmpl.Placeholders ?? new List<string>(),\n        //            imageUrl: tmpl.ImageUrl,\n        //            buttons: buttons,\n        //            source: \"auto_reply\",\n        //            refMessageId: null\n        //        );\n\n        //        await LogAutoReplyAsync(\n        //            businessId,\n        //            contactId,\n        //            keyword,\n        //            \"flow\",\n        //            $\"Template: {tmpl.TemplateName}\",\n        //            flowName,\n        //            response.LogId\n        //        );\n        //    }\n\n\n        private async Task ExecuteTemplateNodeAsync(\n    AutoReplyFlowNode node,\n    Guid businessId,\n    Guid contactId,\n    string phone,\n    string keyword,\n    string? flowName)\n        {\n            _logger.LogInformation(\"🧠 Raw config JSON for template node: {Json}\", node.ConfigJson);\n\n            TemplateConfig? tmpl;\n            try\n            {\n                tmpl = JsonConvert.DeserializeObject<TemplateConfig>(node.ConfigJson ?? \"{}\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to deserialize TemplateConfig for node {NodeId}\", node.Id);\n                return;\n            }\n\n            if (tmpl == null || string.IsNullOrWhiteSpace(tmpl.TemplateName))\n            {\n                _logger.LogWarning(\"❌ Template node config is missing or invalid.\");\n                return;\n            }\n\n            var contact = await _context.Contacts\n                .FirstOrDefaultAsync(c => c.Id == contactId && c.BusinessId == businessId);\n\n            if (contact == null)\n            {\n                _logger.LogWarning(\"❌ Contact not found for AutoReply.\");\n                return;\n            }\n\n            var buttons = tmpl.MultiButtons?\n                .Where(b => !string.IsNullOrWhiteSpace(b.ButtonText))\n                .Select(b => new CampaignButton\n                {\n                    Title = b.ButtonText,\n                    Type = b.ButtonType,\n                    Value = b.TargetUrl\n                })\n                .ToList();\n\n            var response = await _templateSender.SendTemplateMessageToContactAsync(\n                businessId: businessId,\n                contact: contact,\n                templateName: tmpl.TemplateName,\n                templateParams: tmpl.Placeholders ?? new List<string>(),\n                imageUrl: tmpl.ImageUrl,\n                buttons: buttons,\n                source: \"auto_reply\",\n                refMessageId: null\n            );\n\n            await LogAutoReplyAsync(\n                businessId,\n                contactId,\n                keyword,\n                \"flow\",\n                $\"Template: {tmpl.TemplateName}\",\n                flowName,\n                response.LogId\n            );\n        }\n\n        private async Task ExecuteMessageNodeAsync( AutoReplyFlowNode node, Guid businessId, Guid contactId,string phone, string keyword, string? flowName)\n        {\n            _logger.LogInformation(\"🧠 Raw config JSON for message node: {Json}\", node.ConfigJson);\n\n            MessageConfig? config = null;\n            try\n            {\n                config = JsonConvert.DeserializeObject<MessageConfig>(node.ConfigJson ?? \"{}\");\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to parse config for message node {NodeId}\", node.Id);\n                return;\n            }\n\n            if (config == null || string.IsNullOrWhiteSpace(config.Text))\n            {\n                _logger.LogWarning(\"⚠️ Message node config missing or empty.\");\n                return;\n            }\n\n            var result = await _messageEngine.SendTextDirectAsync(new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                RecipientNumber = phone,\n                TextContent = config.Text\n            });\n\n            await LogAutoReplyAsync(\n                businessId,\n                contactId,\n                keyword,\n                \"flow\",\n                config.Text,\n                flowName,\n                result?.LogId\n            );\n        }\n        private async Task ExecuteTagNodeAsync(Guid businessId, Guid contactId, AutoReplyFlowNode node)\n        {\n            if (node == null || string.IsNullOrWhiteSpace(node.ConfigJson))\n                return;\n\n            try\n            {\n                var config = System.Text.Json.JsonSerializer.Deserialize<TagNodeConfig>(node.ConfigJson);\n\n                if (config?.Tags != null && config.Tags.Any())\n                {\n                    // ✅ Load contact from DB\n                    var contact = await _context.Contacts.FirstOrDefaultAsync(c => c.Id == contactId && c.BusinessId == businessId);\n                    if (contact == null)\n                    {\n                        _logger.LogWarning(\"⚠️ TagNode: Contact not found for {ContactId}\", contactId);\n                        return;\n                    }\n\n                    await _tagService.AssignTagsAsync(businessId, contact.PhoneNumber, config.Tags);\n                    _logger.LogInformation(\"✅ TagNode: Tags [{Tags}] assigned to contact {Phone}\", string.Join(\", \", config.Tags), contact.PhoneNumber);\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ TagNode: Failed to execute for contact {ContactId}\", contactId);\n            }\n        }\n\n        public async Task TryRunAutoReplyFlowByButtonAsync(Guid businessId, string phone, string buttonText, Guid? refMessageId = null)\n        {\n            var contact = await _contactService.FindOrCreateAsync(businessId, phone);\n            if (contact == null)\n            {\n                _logger.LogWarning(\"❌ Contact not found or could not be created for phone: {Phone}\", phone);\n                return;\n            }\n\n            _logger.LogInformation(\"📩 Button clicked: '{ButtonText}' by {Phone}\", buttonText, phone);\n\n            var flows = await _flowRepo.GetAllByBusinessIdAsync(businessId);\n            if (flows == null || !flows.Any())\n            {\n                _logger.LogInformation(\"📭 No flows found for business {BusinessId}\", businessId);\n                return;\n            }\n\n            foreach (var flow in flows)\n            {\n                var nodes = await _flowRepo.GetNodesByFlowIdAsync(flow.Id);\n                var edges = await _flowRepo.GetEdgesByFlowIdAsync(flow.Id);\n\n                var matchedStartNode = nodes\n                    .Where(n => n.NodeType == \"start\")\n                    .FirstOrDefault(n =>\n                    {\n                        try\n                        {\n                            var config = JsonConvert.DeserializeObject<Dictionary<string, object>>(n.ConfigJson ?? \"{}\");\n\n                            if (config != null && config.TryGetValue(\"triggerKeywords\", out var raw))\n                            {\n                                var keywordArray = JsonConvert.DeserializeObject<List<string>>(raw.ToString() ?? \"[]\");\n\n                                return keywordArray.Any(k =>\n                                    string.Equals(k?.Trim(), buttonText.Trim(), StringComparison.OrdinalIgnoreCase));\n                            }\n\n                            return false;\n                        }\n                        catch\n                        {\n                            return false;\n                        }\n                    });\n\n                if (matchedStartNode != null)\n                {\n                    _logger.LogInformation(\"✅ Matched flow {FlowName} by button '{ButtonText}'\", flow.Name, buttonText);\n                   // await RunFlowAsync(flow.Id, businessId, contact.Id, phone, buttonText, flow.Name);\n                  await RunFlowFromButtonAsync(flow.Id, businessId, contact.Id, phone, buttonText);\n                    return;\n                }\n            }\n\n            _logger.LogInformation(\"❌ No flow matched for button: {ButtonText}\", buttonText);\n        }\n        public async Task RunFlowFromButtonAsync(Guid flowId, Guid businessId, Guid contactId, string phone, string buttonText)\n        {\n            var nodes = await _flowRepo.GetNodesByFlowIdAsync(flowId);\n            var edges = await _flowRepo.GetEdgesByFlowIdAsync(flowId);\n\n            var nodeMap = nodes.ToDictionary(n => n.Id.ToString(), n => n);\n            var edgeMap = edges.GroupBy(e => e.SourceNodeId)\n                               .ToDictionary(g => g.Key, g => g.ToList());\n\n            // 🟢 1. Find start node\n            var startNode = nodes.FirstOrDefault(n => n.NodeType == \"start\");\n            if (startNode == null)\n            {\n                _logger.LogWarning(\"❌ No start node found in flow {FlowId}\", flowId);\n                return;\n            }\n\n            // 🔍 2. Find button index from triggerKeywords\n            int matchedIndex = -1;\n            try\n            {\n                var config = JsonConvert.DeserializeObject<Dictionary<string, object>>(startNode.ConfigJson ?? \"{}\");\n\n                if (config != null && config.TryGetValue(\"triggerKeywords\", out var raw))\n                {\n                    var keywordList = JsonConvert.DeserializeObject<List<string>>(raw.ToString() ?? \"[]\");\n                    matchedIndex = keywordList.FindIndex(k =>\n                        string.Equals(k?.Trim(), buttonText.Trim(), StringComparison.OrdinalIgnoreCase));\n                }\n            }\n            catch (Exception ex)\n            {\n                _logger.LogError(ex, \"❌ Failed to parse Start node config\");\n                return;\n            }\n\n            if (matchedIndex < 0)\n            {\n                _logger.LogWarning(\"❌ No trigger match for buttonText '{Button}'\", buttonText);\n                return;\n            }\n\n            // ✅ 3. Lookup edge from StartNode using SourceHandle = button-{index}\n            var nextNodeId = edgeMap.TryGetValue(startNode.Id.ToString(), out var list)\n                ? list.FirstOrDefault(e => e.SourceHandle == $\"button-{matchedIndex}\")?.TargetNodeId\n                : null;\n\n            if (string.IsNullOrEmpty(nextNodeId))\n            {\n                _logger.LogWarning(\"❌ No outgoing edge found for button index {Index}\", matchedIndex);\n                return;\n            }\n\n            var visited = new HashSet<string>();\n\n            while (!string.IsNullOrEmpty(nextNodeId) && !visited.Contains(nextNodeId))\n            {\n                visited.Add(nextNodeId);\n\n                if (!nodeMap.TryGetValue(nextNodeId, out var node))\n                    break;\n\n                _logger.LogInformation(\"⚙️ Executing node {NodeId} [{NodeType}]\", node.Id, node.NodeType);\n\n                try\n                {\n                    switch (node.NodeType)\n                    {\n                        case \"message\":\n                            await ExecuteMessageNodeAsync(node, businessId, contactId, phone, buttonText, null);\n                            break;\n\n                        case \"template\":\n                            await ExecuteTemplateNodeAsync(node, businessId, contactId, phone, buttonText, null);\n\n                            // ✅ Check buttons and halt if any button exists\n                            try\n                            {\n                                var cfg = JsonConvert.DeserializeObject<TemplateConfig>(node.ConfigJson ?? \"{}\");\n                                if (cfg?.MultiButtons?.Any(b => !string.IsNullOrWhiteSpace(b.ButtonText)) == true)\n                                {\n                                    _logger.LogInformation(\"🛑 Template node has buttons – halting flow for user click.\");\n                                    return;\n                                }\n                            }\n                            catch (Exception ex)\n                            {\n                                _logger.LogError(ex, \"❌ Failed to parse template config for button detection.\");\n                            }\n                            break;\n\n\n                        case \"tag\":\n                            await ExecuteTagNodeAsync(businessId, contactId, node);\n                            break;\n\n                        case \"wait\":\n                            var waitCfg = JsonConvert.DeserializeObject<WaitConfig>(node.ConfigJson ?? \"{}\");\n                            await Task.Delay((waitCfg?.Seconds ?? 1) * 1000);\n                            break;\n                    }\n                }\n                catch (Exception ex)\n                {\n                    _logger.LogError(ex, \"❌ Error executing node {NodeId}\", node.Id);\n                }\n\n                nextNodeId = edgeMap.TryGetValue(nextNodeId, out var nextList)\n                    ? nextList.FirstOrDefault()?.TargetNodeId\n                    : null;\n            }\n        }\n\n    }\n}\n\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/AutoReplyService.cs",
      "sha256": "df6edf428cebc4dc2d292bef7eb4e47f8cdcbe402b71d79ff9e6ae300502cf70",
      "language": "csharp",
      "size": 3226,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.AutoReplyBuilder.Repositories;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class AutoReplyService : IAutoReplyService\n    {\n        private readonly IAutoReplyRepository _repository;\n\n        public AutoReplyService(IAutoReplyRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<AutoReplyRuleDto> CreateRuleAsync(Guid businessId, AutoReplyRuleDto dto)\n        {\n            var model = new AutoReplyRule\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = businessId,\n                TriggerKeyword = dto.TriggerKeyword,\n                ReplyMessage = dto.ReplyMessage,\n                MediaUrl = dto.MediaUrl,\n                Priority = dto.Priority,\n                IsActive = dto.IsActive,\n                CreatedAt = DateTime.UtcNow\n            };\n\n            var saved = await _repository.AddAsync(model);\n\n            return ToDto(saved);\n        }\n\n        public async Task<IEnumerable<AutoReplyRuleDto>> GetAllRulesAsync(Guid businessId)\n        {\n            var rules = await _repository.GetAllByBusinessIdAsync(businessId);\n            return rules.Select(ToDto);\n        }\n\n        public async Task<AutoReplyRuleDto?> GetRuleByIdAsync(Guid ruleId, Guid businessId)\n        {\n            var rule = await _repository.GetByIdAsync(ruleId, businessId);\n            return rule == null ? null : ToDto(rule);\n        }\n\n        public async Task<bool> UpdateRuleAsync(Guid businessId, AutoReplyRuleDto dto)\n        {\n            var existing = await _repository.GetByIdAsync(dto.Id!.Value, businessId);\n            if (existing == null) return false;\n\n            existing.TriggerKeyword = dto.TriggerKeyword;\n            existing.ReplyMessage = dto.ReplyMessage;\n            existing.MediaUrl = dto.MediaUrl;\n            existing.Priority = dto.Priority;\n            existing.IsActive = dto.IsActive;\n            existing.UpdatedAt = DateTime.UtcNow;\n\n            return await _repository.UpdateAsync(existing);\n        }\n\n        public async Task<bool> DeleteRuleAsync(Guid ruleId, Guid businessId)\n        {\n            return await _repository.DeleteAsync(ruleId, businessId);\n        }\n\n        public async Task<AutoReplyRuleDto?> MatchRuleByKeywordAsync(Guid businessId, string incomingMessage)\n        {\n            var rule = await _repository.MatchByKeywordAsync(businessId, incomingMessage);\n            return rule == null ? null : ToDto(rule);\n        }\n\n        private AutoReplyRuleDto ToDto(AutoReplyRule rule)\n        {\n            return new AutoReplyRuleDto\n            {\n                Id = rule.Id,\n                TriggerKeyword = rule.TriggerKeyword,\n                ReplyMessage = rule.ReplyMessage,\n                MediaUrl = rule.MediaUrl,\n                Priority = rule.Priority,\n                IsActive = rule.IsActive,\n                CreatedAt = rule.CreatedAt,\n                UpdatedAt = rule.UpdatedAt\n            };\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/FlowRunner.cs",
      "sha256": "d8c0004b19eb4964915bcf51a0ecdadf6dc89cfe50220970befa0fe58a5d4307",
      "language": "csharp",
      "size": 103,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class FlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyFlowService.cs",
      "sha256": "dfa67a436f77fb405478dfff58668d94aaed35d2e14d087bffd2fa6eb5b0112b",
      "language": "csharp",
      "size": 721,
      "content": "using System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.Flows.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Flows.Services\n{\n    public interface IAutoReplyFlowService\n    {\n        Task<Guid> SaveFlowAsync(SaveFlowDto dto, Guid businessId);\n        Task<List<SaveFlowDto>> GetFlowsByBusinessIdAsync(Guid businessId);\n        Task<SaveFlowDto?> GetFlowByIdAsync(Guid flowId, Guid businessId);\n        Task<int> GetFlowCountForBusinessAsync(Guid businessId);\n        Task<bool> RenameFlowAsync(Guid id, string newName);\n        Task<bool> DeleteFlowAsync(Guid id, Guid businessId);\n        Task ExecuteFlowAsync(Guid businessId, string triggerKeyword, string customerPhoneNumber);\n\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyRuntimeService.cs",
      "sha256": "444b22549b3c870a3e8cef485bfbf318b5c82a42194255e035be52e27262d4e9",
      "language": "csharp",
      "size": 646,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyRuntimeService\n    {\n        Task<bool> TryRunAutoReplyFlowAsync(Guid businessId, string messageText, Guid contactId, string phoneNumber);\n        Task RunFlowAsync(Guid flowId, Guid businessId, Guid contactId, string phone, string keyword, string flowName);\n        Task TryRunAutoReplyFlowByButtonAsync(Guid businessId, string phone, string buttonText, Guid? refMessageId = null);\n        Task RunFlowFromButtonAsync(Guid flowId, Guid businessId, Guid contactId, string phone, string buttonText);\n\n    }\n}\n\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IAutoReplyService.cs",
      "sha256": "b2816300ae56acd5368c993c2bccc75ff481290ca8379e745ac361e2d27e620f",
      "language": "csharp",
      "size": 763,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.AutoReplyBuilder.DTOs;\n\nnamespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public interface IAutoReplyService\n    {\n        Task<AutoReplyRuleDto> CreateRuleAsync(Guid businessId, AutoReplyRuleDto dto);\n        Task<IEnumerable<AutoReplyRuleDto>> GetAllRulesAsync(Guid businessId);\n        Task<AutoReplyRuleDto?> GetRuleByIdAsync(Guid ruleId, Guid businessId);\n        Task<bool> UpdateRuleAsync(Guid businessId, AutoReplyRuleDto dto);\n        Task<bool> DeleteRuleAsync(Guid ruleId, Guid businessId);\n\n        // For runtime matching\n        Task<AutoReplyRuleDto?> MatchRuleByKeywordAsync(Guid businessId, string incomingMessage);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyBuilder/Services/IFlowRunner.cs",
      "sha256": "11438f4864857ba65f652f4ed62baf47119c77fcd6933106db70602675dce48b",
      "language": "csharp",
      "size": 104,
      "content": "namespace xbytechat.api.Features.AutoReplyBuilder.Services\n{\n    public class IFlowRunner\n    {\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/AutoReplyTemplates/Restaurant/Configs/MenuNodeConfig.cs",
      "sha256": "f20da12fb12eed3191a2998cb2e7a7dbc65b03bfcb571cf1b6a413f52d78d42a",
      "language": "csharp",
      "size": 527,
      "content": "namespace xbytechat.api.Features.AutoReplyTemplates.Restaurant.Configs\n{\n    public class MenuNodeConfig\n    {\n        public string MenuTitle { get; set; } = string.Empty;         // e.g., \"Today's Specials\"\n        public string Description { get; set; } = string.Empty;       // e.g., \"Lunch combos starting at ₹199\"\n        public string MenuImageUrl { get; set; } = string.Empty;      // CDN or public link\n        public string MenuDownloadUrl { get; set; } = string.Empty;   // PDF link or product catalog URL\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppMetaWebhookController.cs",
      "sha256": "2557cea7249e3f7099e3fc3e53474acd46b9edd9419be5f82cfdd49113b5b629",
      "language": "csharp",
      "size": 2422,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/meta\")]\n    public class WhatsAppMetaWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppMetaWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n        private readonly IConfiguration _config;\n        public WhatsAppMetaWebhookController(ILogger<WhatsAppMetaWebhookController> log, IBillingIngestService ingest, IConfiguration config)\n        {\n            _log = log;\n            _ingest = ingest;\n            _config = config;\n        }\n\n        // Meta verification handshake\n        // GET /api/webhooks/whatsapp/meta?hub.mode=subscribe&hub.challenge=...&hub.verify_token=...&businessId=...\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge,\n                                    [FromQuery(Name = \"hub.verify_token\")] string verifyToken,\n                                    [FromQuery] Guid? businessId = null)\n        {\n            var expected = _config[\"WhatsApp:MetaVerifyToken\"]; // optional; if empty we accept\n            if (!string.IsNullOrWhiteSpace(expected) && !string.Equals(expected, verifyToken))\n            {\n                _log.LogWarning(\"Meta webhook verify failed. Provided token does not match.\");\n                return Unauthorized();\n            }\n            _log.LogInformation(\"Meta webhook verified. BusinessId={BusinessId}\", businessId);\n            return Content(challenge ?? string.Empty, \"text/plain\");\n        }\n\n        // POST /api/webhooks/whatsapp/meta?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Meta webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"META_CLOUD\", payload);\n\n            return Ok();\n        }\n\n        // If you need GET verification for Meta webhook, add it here.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppPinnacleWebhookController.cs",
      "sha256": "50c4e7ef562320331826b09fa5210313b19967296a61f89daf10e2e421b8bf73",
      "language": "csharp",
      "size": 1268,
      "content": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/pinnacle\")]\n    public class WhatsAppPinnacleWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppPinnacleWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n\n        public WhatsAppPinnacleWebhookController(\n            ILogger<WhatsAppPinnacleWebhookController> log,\n            IBillingIngestService ingest)\n        {\n            _log = log;\n            _ingest = ingest;\n        }\n\n        // POST /api/webhooks/whatsapp/pinnacle?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Pinnacle webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"PINNACLE\", payload);\n\n            return Ok();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/DTOs/BillingSnapshotDto.cs",
      "sha256": "ccb71af46ccda4580bcf96c49ae7cab671224aa519eaaf63e561d2fa39d0eb26",
      "language": "csharp",
      "size": 534,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat_api.Features.Billing.DTOs\n{\n    public class BillingSnapshotDto\n    {\n        public int TotalMessages { get; set; }\n        public int ChargeableMessages { get; set; }\n        public int FreeMessages { get; set; }\n        public Dictionary<string, int> CountByCategory { get; set; } = new();    // marketing, utility, authentication, service, free_entry\n        public Dictionary<string, decimal> SpendByCurrency { get; set; } = new();// \"USD\" => 12.34, \"INR\" => 250.00\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/Billing/Models/ProviderBillingEvent.cs",
      "sha256": "f923e2377733fecf0ad48ff39d28f1a6e1bbfe4e78f370748b864f1568285824",
      "language": "csharp",
      "size": 1179,
      "content": "using System;\n\nnamespace xbytechat_api.Features.Billing.Models\n{\n    public class ProviderBillingEvent\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n\n        // Link if we can; may be null if webhook arrives before we create MessageLog\n        public Guid? MessageLogId { get; set; }\n\n        public string Provider { get; set; } = \"\";          // \"Meta_cloud\", \"Pinnacle\"\n        public string EventType { get; set; } = \"\";         // \"conversation_started\", \"message_delivered\", \"pricing_update\", etc.\n\n        public string? ProviderMessageId { get; set; }      // \"wamid...\"\n        public string? ConversationId { get; set; }\n        public string? ConversationCategory { get; set; }\n        public bool? IsChargeable { get; set; }\n        public decimal? PriceAmount { get; set; }\n        public string? PriceCurrency { get; set; }\n\n        public string PayloadJson { get; set; } = \"\";       // original provider payload for audit\n        public DateTimeOffset OccurredAt { get; set; }      // when provider says it happened\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingIngestService.cs",
      "sha256": "f177bd5d56a15388b982936d70b7e02fb7942499fd6ffcf777a634207b0c47ac",
      "language": "csharp",
      "size": 41481,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // AppDbContext\nusing xbytechat_api.Features.Billing.Models;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingIngestService : IBillingIngestService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BillingIngestService> _log;\n\n        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n        {\n            // Meta send usually returns only message ID; pricing lands via webhook.\n            // We still extract ProviderMessageId early to link later webhook updates.\n            try\n            {\n                using var doc = JsonDocument.Parse(rawResponseJson);\n                string? providerMessageId =\n                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) && msgs.ValueKind == JsonValueKind.Array && msgs.GetArrayLength() > 0\n                        ? msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null\n                    : doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString()\n                    : null;\n\n                var logRow = await _db.MessageLogs.FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n                if (logRow != null)\n                {\n                    logRow.Provider = provider;\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        logRow.ProviderMessageId = providerMessageId;\n                }\n\n                // Store audit event\n                var ev = new ProviderBillingEvent\n                {\n                    BusinessId = businessId,\n                    MessageLogId = messageLogId,\n                    Provider = provider,\n                    EventType = \"send_response\",\n                    ProviderMessageId = providerMessageId,\n                    PayloadJson = rawResponseJson,\n                    OccurredAt = DateTimeOffset.UtcNow\n                };\n                _db.ProviderBillingEvents.Add(ev);\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Failed to ingest send response payload for business {biz}\", businessId);\n            }\n        }\n\n        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(payloadJson);\n                var now = DateTimeOffset.UtcNow;\n\n                // Local idempotency guard:\n                // Consider an event \"existing\" if (BusinessId, Provider, EventType)\n                // matches and we have either the same ProviderMessageId OR (when absent) the same ConversationId.\n                Task<bool> ExistsAsync(string eventType, string? providerMessageId, string? conversationId)\n                {\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                    {\n                        return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                            x.BusinessId == businessId &&\n                            x.Provider == provider &&\n                            x.EventType == eventType &&\n                            x.ProviderMessageId == providerMessageId);\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(conversationId))\n                    {\n                        return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                            x.BusinessId == businessId &&\n                            x.Provider == provider &&\n                            x.EventType == eventType &&\n                            x.ConversationId == conversationId);\n                    }\n\n                    // No natural key available; let it through (DB unique index can still protect if present).\n                    return Task.FromResult(false);\n                }\n\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Typical Meta structure:\n                    // entry[].changes[].value.statuses[] with:\n                    //  - id (wamid)\n                    //  - status (sent / delivered / read / etc.)\n                    //  - timestamp (unix seconds, string or number)\n                    //  - conversation { id, expiration_timestamp }\n                    //  - pricing { billable, category, amount, currency }\n                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n                        foreach (var change in Enumerate(entry, \"changes\"))\n                        {\n                            if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                            foreach (var st in Enumerate(value, \"statuses\"))\n                            {\n                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null;\n\n                                string? status = null;\n                                if (st.TryGetProperty(\"status\", out var statusEl) && statusEl.ValueKind == JsonValueKind.String)\n                                    status = statusEl.GetString()?.ToLowerInvariant();\n\n                                // OccurredAt from provider if present\n                                DateTimeOffset occurredAt = now;\n                                if (st.TryGetProperty(\"timestamp\", out var tsEl))\n                                {\n                                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var tsLong))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsLong);\n                                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var tsNum))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsNum);\n                                }\n\n                                // Conversation info (Meta expires 24h after start)\n                                string? conversationId = null;\n                                DateTimeOffset? convStartedAt = null;\n                                if (st.TryGetProperty(\"conversation\", out var convEl) && convEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (convEl.TryGetProperty(\"id\", out var cidEl)) conversationId = cidEl.GetString();\n\n                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl))\n                                    {\n                                        long exp;\n                                        if (expEl.ValueKind == JsonValueKind.String && long.TryParse(expEl.GetString(), out var expStr))\n                                            exp = expStr;\n                                        else if (expEl.ValueKind == JsonValueKind.Number && expEl.TryGetInt64(out var expNum))\n                                            exp = expNum;\n                                        else\n                                            exp = 0;\n\n                                        if (exp > 0)\n                                        {\n                                            var expiration = DateTimeOffset.FromUnixTimeSeconds(exp);\n                                            convStartedAt = expiration.AddHours(-24);\n                                        }\n                                    }\n                                }\n\n                                // Pricing block (optional per status)\n                                string? category = null;\n                                bool? billable = null;\n                                decimal? amount = null;\n                                string? currency = null;\n\n                                if (st.TryGetProperty(\"pricing\", out var pEl) && pEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (pEl.TryGetProperty(\"category\", out var catEl))\n                                        category = catEl.GetString()?.ToLowerInvariant();\n\n                                    if (pEl.TryGetProperty(\"billable\", out var bilEl) &&\n                                        (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False))\n                                        billable = bilEl.GetBoolean();\n\n                                    if (pEl.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n                                        amount = amtEl.GetDecimal();\n\n                                    if (pEl.TryGetProperty(\"currency\", out var curEl) && curEl.ValueKind == JsonValueKind.String)\n                                        currency = curEl.GetString();\n                                }\n\n                                // 1) Status event (sent/delivered/read...) — write once\n                                if (!string.IsNullOrWhiteSpace(status))\n                                {\n                                    var statusEventType = status; // store status as EventType\n                                    if (!await ExistsAsync(statusEventType, providerMessageId, conversationId))\n                                    {\n                                        _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                                        {\n                                            BusinessId = businessId,\n                                            Provider = provider,\n                                            EventType = statusEventType,\n                                            ProviderMessageId = providerMessageId,\n                                            ConversationId = conversationId,\n                                            ConversationCategory = category,\n                                            IsChargeable = billable,\n                                            PriceAmount = amount,\n                                            PriceCurrency = currency,\n                                            PayloadJson = payloadJson,\n                                            OccurredAt = occurredAt\n                                        });\n                                    }\n                                }\n\n                                // 2) Pricing update — write once\n                                bool hasAnyPricing = !string.IsNullOrWhiteSpace(category) || billable.HasValue || amount.HasValue || !string.IsNullOrWhiteSpace(currency);\n                                if (hasAnyPricing && !await ExistsAsync(\"pricing_update\", providerMessageId, conversationId))\n                                {\n                                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = \"pricing_update\",\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    });\n                                }\n\n                                // Keep MessageLog in sync (when linkable)\n                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                                if (logRow != null)\n                                {\n                                    logRow.Provider = provider;\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                        logRow.ProviderMessageId = providerMessageId;\n                                    if (!string.IsNullOrWhiteSpace(conversationId))\n                                        logRow.ConversationId = conversationId;\n                                    if (convStartedAt.HasValue)\n                                        logRow.ConversationStartedAt = convStartedAt;\n\n                                    if (billable.HasValue) logRow.IsChargeable = billable.Value;\n                                    if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n                                    if (amount.HasValue) logRow.PriceAmount = amount;\n                                    if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n                                }\n                            }\n                        }\n                }\n                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Scan for \"pricing\" nodes; try to infer message & conversation from parent context.\n                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n                    {\n                        string? category = pricing.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null;\n                        bool? billable = (pricing.TryGetProperty(\"billable\", out var bilEl) &&\n                                          (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False))\n                                          ? bilEl.GetBoolean() : (bool?)null;\n\n                        decimal? amount = null;\n                        if (pricing.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n                            amount = amtEl.GetDecimal();\n\n                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl) ? curEl.GetString() : null;\n\n                        var parent = TryGetParentObject(doc.RootElement, pricing);\n                        string? providerMessageId = TryGetString(parent, \"id\")\n                                                 ?? TryGetString(parent, \"message_id\")\n                                                 ?? TryGetString(parent, \"wamid\");\n                        string? conversationId = TryGetString(parent, \"conversation_id\")\n                                               ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n                        // Optional status in same parent\n                        string? status = TryGetString(parent, \"status\")?.ToLowerInvariant();\n\n                        // Pricing (deduped)\n                        if (!await ExistsAsync(\"pricing_update\", providerMessageId, conversationId))\n                        {\n                            _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = \"pricing_update\",\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            });\n                        }\n\n                        // Optional status (deduped)\n                        if (!string.IsNullOrWhiteSpace(status) && !await ExistsAsync(status, providerMessageId, conversationId))\n                        {\n                            _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = status,\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            });\n                        }\n\n                        // Update MessageLog when linkable\n                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                        if (logRow != null)\n                        {\n                            logRow.Provider = provider;\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                logRow.ProviderMessageId = providerMessageId;\n                            if (!string.IsNullOrWhiteSpace(conversationId))\n                                logRow.ConversationId = conversationId;\n\n                            if (billable.HasValue) logRow.IsChargeable = billable.Value;\n                            if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n                            if (amount.HasValue) logRow.PriceAmount = amount;\n                            if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n                        }\n                    }\n                }\n                else\n                {\n                    // Unknown provider; still store the raw event for audit (idempotency relaxed here)\n                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                    {\n                        BusinessId = businessId,\n                        Provider = provider,\n                        EventType = \"unknown_provider_webhook\",\n                        PayloadJson = payloadJson,\n                        OccurredAt = now\n                    });\n                }\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Failed to ingest webhook payload for business {biz}\", businessId);\n            }\n        }\n\n        // -------- helpers --------\n        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n        {\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var byMsgId = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ProviderMessageId == providerMessageId);\n                if (byMsgId != null) return byMsgId;\n            }\n\n            if (!string.IsNullOrWhiteSpace(conversationId))\n            {\n                var byConv = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ConversationId == conversationId);\n                if (byConv != null) return byConv;\n            }\n\n            return null;\n        }\n\n        // Enumerate array property safely\n        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n        {\n            if (root.ValueKind != JsonValueKind.Object) yield break;\n            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n            foreach (var x in arr.EnumerateArray()) yield return x;\n        }\n\n        // Breadth search for any property named `name` (unique name to avoid ambiguity)\n        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n        {\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n                        yield return p.Value;\n\n                    foreach (var x in JsonPathAll(p.Value, name))\n                        yield return x;\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in root.EnumerateArray())\n                    foreach (var x in JsonPathAll(item, name))\n                        yield return x;\n            }\n        }\n\n        // Very lightweight \"parent\" guess: look for an object in ancestry that contains the node reference (best-effort)\n        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n        {\n            // System.Text.Json doesn't expose parents. We accept best-effort by scanning objects containing 'pricing'\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (p.Value.ValueKind == JsonValueKind.Object)\n                    {\n                        if (object.ReferenceEquals(p.Value, node)) return root;\n                        var cand = TryGetParentObject(p.Value, node);\n                        if (cand.HasValue) return cand;\n                    }\n                    else if (p.Value.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var e in p.Value.EnumerateArray())\n                        {\n                            if (object.ReferenceEquals(e, node)) return root;\n                            var cand = TryGetParentObject(e, node);\n                            if (cand.HasValue) return cand;\n                        }\n                    }\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in root.EnumerateArray())\n                {\n                    var cand = TryGetParentObject(e, node);\n                    if (cand.HasValue) return cand;\n                }\n            }\n            return null;\n        }\n\n        private static string? TryGetString(JsonElement? obj, string name)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n        }\n\n        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object) return null;\n            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using System.Collections.Generic;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // AppDbContext\n//using xbytechat_api.Features.Billing.Models;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingIngestService : IBillingIngestService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<BillingIngestService> _log;\n\n//        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n//        {\n//            _db = db;\n//            _log = log;\n//        }\n\n//        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n//        {\n//            // Meta send usually returns only message ID; pricing lands via webhook.\n//            // We still extract ProviderMessageId early to link later webhook updates.\n//            try\n//            {\n//                using var doc = JsonDocument.Parse(rawResponseJson);\n//                string? providerMessageId =\n//                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) && msgs.ValueKind == JsonValueKind.Array && msgs.GetArrayLength() > 0\n//                        ? msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null\n//                    : doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString()\n//                    : null;\n\n//                var logRow = await _db.MessageLogs.FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n//                if (logRow != null)\n//                {\n//                    logRow.Provider = provider;\n//                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                        logRow.ProviderMessageId = providerMessageId;\n//                }\n\n//                // Store audit event\n//                var ev = new ProviderBillingEvent\n//                {\n//                    BusinessId = businessId,\n//                    MessageLogId = messageLogId,\n//                    Provider = provider,\n//                    EventType = \"send_response\",\n//                    ProviderMessageId = providerMessageId,\n//                    PayloadJson = rawResponseJson,\n//                    OccurredAt = DateTimeOffset.UtcNow\n//                };\n//                _db.ProviderBillingEvents.Add(ev);\n\n//                await _db.SaveChangesAsync();\n//            }\n//            catch (Exception ex)\n//            {\n//                _log.LogWarning(ex, \"Failed to ingest send response payload for business {biz}\", businessId);\n//            }\n//        }\n\n//        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n//        {\n//            try\n//            {\n//                using var doc = JsonDocument.Parse(payloadJson);\n//                var now = DateTimeOffset.UtcNow;\n\n//                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // Typical Meta structure:\n//                    // entry[].changes[].value.statuses[] with:\n//                    //  - id (wamid)\n//                    //  - pricing { billable, category, amount, currency }\n//                    //  - conversation { id, expiration_timestamp }\n//                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n//                    {\n//                        foreach (var change in Enumerate(entry, \"changes\"))\n//                        {\n//                            if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n//                            foreach (var st in Enumerate(value, \"statuses\"))\n//                            {\n//                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null;\n\n//                                string? category = st.TryGetProperty(\"pricing\", out var pEl) && pEl.ValueKind == JsonValueKind.Object\n//                                    ? pEl.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null\n//                                    : null;\n\n//                                bool? billable = st.TryGetProperty(\"pricing\", out var pEl2) && pEl2.ValueKind == JsonValueKind.Object\n//                                    ? pEl2.TryGetProperty(\"billable\", out var bilEl) && (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False)\n//                                        ? bilEl.GetBoolean() : (bool?)null\n//                                    : (bool?)null;\n\n//                                decimal? amount = null;\n//                                string? currency = null;\n//                                if (st.TryGetProperty(\"pricing\", out var pEl3) && pEl3.ValueKind == JsonValueKind.Object)\n//                                {\n//                                    if (pEl3.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n//                                        amount = amtEl.GetDecimal();\n//                                    if (pEl3.TryGetProperty(\"currency\", out var curEl))\n//                                        currency = curEl.GetString();\n//                                }\n\n//                                string? conversationId = null;\n//                                DateTimeOffset? convStartedAt = null;\n//                                if (st.TryGetProperty(\"conversation\", out var convEl) && convEl.ValueKind == JsonValueKind.Object)\n//                                {\n//                                    if (convEl.TryGetProperty(\"id\", out var cidEl))\n//                                        conversationId = cidEl.GetString();\n\n//                                    // expiration_timestamp is seconds; start time not directly given.\n//                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl) && expEl.ValueKind == JsonValueKind.Number)\n//                                    {\n//                                        var exp = DateTimeOffset.FromUnixTimeSeconds(expEl.GetInt64());\n//                                        convStartedAt = exp.AddHours(-24);\n//                                    }\n//                                }\n\n//                                // Audit event\n//                                var ev = new ProviderBillingEvent\n//                                {\n//                                    BusinessId = businessId,\n//                                    Provider = provider,\n//                                    EventType = \"pricing_update\",\n//                                    ProviderMessageId = providerMessageId,\n//                                    ConversationId = conversationId,\n//                                    ConversationCategory = category,\n//                                    IsChargeable = billable,\n//                                    PriceAmount = amount,\n//                                    PriceCurrency = currency,\n//                                    PayloadJson = payloadJson,\n//                                    OccurredAt = now\n//                                };\n//                                _db.ProviderBillingEvents.Add(ev);\n\n//                                // Update MessageLog when possible\n//                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n//                                if (logRow != null)\n//                                {\n//                                    logRow.Provider = provider;\n//                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                                        logRow.ProviderMessageId = providerMessageId;\n//                                    if (billable.HasValue) logRow.IsChargeable = billable.Value;\n//                                    if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n//                                    if (!string.IsNullOrWhiteSpace(conversationId)) logRow.ConversationId = conversationId;\n//                                    if (amount.HasValue) logRow.PriceAmount = amount;\n//                                    if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n//                                    if (convStartedAt.HasValue) logRow.ConversationStartedAt = convStartedAt;\n//                                }\n//                            }\n//                        }\n//                    }\n//                }\n//                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // Pinnacle payloads vary, but often include \"message_id\", \"conversation\" with id/category and \"pricing\".\n//                    // We'll scan the whole tree for any \"pricing\" objects, and attempt nearby fields for message id and conversation.\n//                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n//                    {\n//                        string? category = pricing.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null;\n//                        bool? billable = pricing.TryGetProperty(\"billable\", out var bilEl) && (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False)\n//                            ? bilEl.GetBoolean() : (bool?)null;\n\n//                        decimal? amount = null;\n//                        if (pricing.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n//                            amount = amtEl.GetDecimal();\n//                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl) ? curEl.GetString() : null;\n\n//                        // Heuristics to pick neighbors in same object\n//                        var parent = TryGetParentObject(doc.RootElement, pricing);\n//                        string? providerMessageId = TryGetString(parent, \"id\")\n//                                                 ?? TryGetString(parent, \"message_id\")\n//                                                 ?? TryGetString(parent, \"wamid\");\n//                        string? conversationId = TryGetString(parent, \"conversation_id\")\n//                                               ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n//                        var ev = new ProviderBillingEvent\n//                        {\n//                            BusinessId = businessId,\n//                            Provider = provider,\n//                            EventType = \"pricing_update\",\n//                            ProviderMessageId = providerMessageId,\n//                            ConversationId = conversationId,\n//                            ConversationCategory = category,\n//                            IsChargeable = billable,\n//                            PriceAmount = amount,\n//                            PriceCurrency = currency,\n//                            PayloadJson = payloadJson,\n//                            OccurredAt = now\n//                        };\n//                        _db.ProviderBillingEvents.Add(ev);\n\n//                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n//                        if (logRow != null)\n//                        {\n//                            logRow.Provider = provider;\n//                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                                logRow.ProviderMessageId = providerMessageId;\n//                            if (billable.HasValue) logRow.IsChargeable = billable.Value;\n//                            if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n//                            if (!string.IsNullOrWhiteSpace(conversationId)) logRow.ConversationId = conversationId;\n//                            if (amount.HasValue) logRow.PriceAmount = amount;\n//                            if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n//                        }\n//                    }\n//                }\n//                else\n//                {\n//                    // Unknown provider; still store the raw event for audit\n//                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n//                    {\n//                        BusinessId = businessId,\n//                        Provider = provider,\n//                        EventType = \"unknown_provider_webhook\",\n//                        PayloadJson = payloadJson,\n//                        OccurredAt = now\n//                    });\n//                }\n\n//                await _db.SaveChangesAsync();\n//            }\n//            catch (Exception ex)\n//            {\n//                _log.LogWarning(ex, \"Failed to ingest webhook payload for business {biz}\", businessId);\n//            }\n//        }\n\n//        // -------- helpers --------\n//        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n//        {\n//            if (!string.IsNullOrWhiteSpace(providerMessageId))\n//            {\n//                var byMsgId = await _db.MessageLogs\n//                    .OrderByDescending(x => x.CreatedAt)\n//                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ProviderMessageId == providerMessageId);\n//                if (byMsgId != null) return byMsgId;\n//            }\n\n//            if (!string.IsNullOrWhiteSpace(conversationId))\n//            {\n//                var byConv = await _db.MessageLogs\n//                    .OrderByDescending(x => x.CreatedAt)\n//                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ConversationId == conversationId);\n//                if (byConv != null) return byConv;\n//            }\n\n//            return null;\n//        }\n\n//        // Enumerate array property safely\n//        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n//        {\n//            if (root.ValueKind != JsonValueKind.Object) yield break;\n//            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n//            foreach (var x in arr.EnumerateArray()) yield return x;\n//        }\n\n//        // Breadth search for any property named `name` (unique name to avoid ambiguity)\n//        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n//        {\n//            if (root.ValueKind == JsonValueKind.Object)\n//            {\n//                foreach (var p in root.EnumerateObject())\n//                {\n//                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n//                        yield return p.Value;\n\n//                    foreach (var x in JsonPathAll(p.Value, name))\n//                        yield return x;\n//                }\n//            }\n//            else if (root.ValueKind == JsonValueKind.Array)\n//            {\n//                foreach (var item in root.EnumerateArray())\n//                    foreach (var x in JsonPathAll(item, name))\n//                        yield return x;\n//            }\n//        }\n\n//        // Very lightweight \"parent\" guess: look for an object in ancestry that contains the node reference (best-effort)\n//        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n//        {\n//            // System.Text.Json doesn't expose parents. We accept best-effort by scanning objects containing 'pricing'\n//            if (root.ValueKind == JsonValueKind.Object)\n//            {\n//                foreach (var p in root.EnumerateObject())\n//                {\n//                    if (p.Value.ValueKind == JsonValueKind.Object)\n//                    {\n//                        if (object.ReferenceEquals(p.Value, node)) return root;\n//                        var cand = TryGetParentObject(p.Value, node);\n//                        if (cand.HasValue) return cand;\n//                    }\n//                    else if (p.Value.ValueKind == JsonValueKind.Array)\n//                    {\n//                        foreach (var e in p.Value.EnumerateArray())\n//                        {\n//                            if (object.ReferenceEquals(e, node)) return root;\n//                            var cand = TryGetParentObject(e, node);\n//                            if (cand.HasValue) return cand;\n//                        }\n//                    }\n//                }\n//            }\n//            else if (root.ValueKind == JsonValueKind.Array)\n//            {\n//                foreach (var e in root.EnumerateArray())\n//                {\n//                    var cand = TryGetParentObject(e, node);\n//                    if (cand.HasValue) return cand;\n//                }\n//            }\n//            return null;\n//        }\n\n//        private static string? TryGetString(JsonElement? obj, string name)\n//        {\n//            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n//            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n//        }\n\n//        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n//        {\n//            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n//            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object) return null;\n//            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingReadService.cs",
      "sha256": "0298676bbd8d96132ccbaf42ca893f76a03f769606106dfe82a6bed17982b5fc",
      "language": "csharp",
      "size": 7066,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\n\nusing xbytechat.api;                               // AppDbContext\nusing xbytechat_api.Features.Billing.DTOs;         // BillingSnapshotDto\nusing xbytechat_api.Features.Billing.Models;       // ProviderBillingEvent (for _db.ProviderBillingEvents)\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingReadService : IBillingReadService\n    {\n        private readonly AppDbContext _db;\n        public BillingReadService(AppDbContext db) => _db = db;\n\n        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n        {\n            // Build inclusive [from..to] range in UTC\n            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n            // 1) Volume: total messages in the period (unchanged behavior)\n            var totalMessages = await _db.MessageLogs.AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt)\n                .CountAsync();\n\n            // 2) Billing source of truth: pricing_update events in the period\n            //    (Only select small projection; we'll dedupe in-memory safely.)\n            var evRaw = await _db.ProviderBillingEvents.AsNoTracking()\n                .Where(e => e.BusinessId == businessId\n                            && e.EventType == \"pricing_update\"\n                            && e.OccurredAt >= fromDt && e.OccurredAt <= toDt)\n                .Select(e => new {\n                    e.Provider,\n                    e.ProviderMessageId,\n                    e.EventType,\n                    e.ConversationId,\n                    e.ConversationCategory,\n                    e.IsChargeable,\n                    e.PriceAmount,\n                    e.PriceCurrency\n                })\n                .ToListAsync();\n\n            // 2a) Defend against webhook replays (if DB unique index not yet deployed)\n            //     Deduplicate on Provider+ProviderMessageId+EventType to drop repeats of the same message event.\n            var evDedup = evRaw\n                .GroupBy(e => new { e.Provider, e.ProviderMessageId, e.EventType })\n                .Select(g => g.First())\n                .ToList();\n\n            // 2b) Group by conversation to compute window-level metrics\n            var convGroups = evDedup\n                .Where(e => !string.IsNullOrWhiteSpace(e.ConversationId))\n                .GroupBy(e => e.ConversationId!)\n                .ToList();\n\n            // Chargeable windows: any event in the conversation marked billable == true\n            var chargeableWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == true));\n\n            // Free windows: conversations explicitly marked billable == false and NOT marked true anywhere\n            var freeWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == false) && !g.Any(x => x.IsChargeable == true));\n\n            // Count by category (per conversation, pick first non-empty category; default \"unknown\")\n            var countByCategory = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                var category = g.Select(x => x.ConversationCategory)\n                                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))\n                                ?.ToLowerInvariant() ?? \"unknown\";\n                countByCategory[category] = countByCategory.TryGetValue(category, out var c) ? c + 1 : 1;\n            }\n\n            // Spend by currency: for each conversation, take the latest non-null amount (if any), then sum by currency\n            var spendByCurrency = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                // Prefer an explicit currency on any event in the conversation\n                var amountWithCurrency = g.LastOrDefault(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency));\n                if (amountWithCurrency?.IsChargeable == true) // only count billable windows\n                {\n                    var cur = amountWithCurrency.PriceCurrency!.ToUpperInvariant();\n                    var amt = amountWithCurrency.PriceAmount!.Value;\n                    spendByCurrency[cur] = spendByCurrency.TryGetValue(cur, out var sum) ? sum + amt : amt;\n                }\n            }\n\n            // Compose DTO\n            var dto = new BillingSnapshotDto\n            {\n                TotalMessages = totalMessages,\n                // These two are now \"window\"-level metrics (conversations) – most accurate for billing with Meta.\n                ChargeableMessages = chargeableWindows,\n                FreeMessages = freeWindows,\n                CountByCategory = countByCategory,\n                SpendByCurrency = spendByCurrency\n            };\n\n            return dto;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat_api.Features.Billing.DTOs;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingReadService : IBillingReadService\n//    {\n//        private readonly AppDbContext _db;\n//        public BillingReadService(AppDbContext db) => _db = db;\n\n//        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n//        {\n//            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n//            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n//            var q = _db.MessageLogs.AsNoTracking()\n//                    .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt);\n\n//            var list = await q.Select(x => new {\n//                x.IsChargeable,\n//                x.ConversationCategory,\n//                x.PriceAmount,\n//                x.PriceCurrency\n//            }).ToListAsync();\n\n//            var dto = new BillingSnapshotDto\n//            {\n//                TotalMessages = list.Count,\n//                ChargeableMessages = list.Count(x => x.IsChargeable == true),\n//                FreeMessages = list.Count(x => x.IsChargeable == false)\n//            };\n\n//            dto.CountByCategory = list\n//                .GroupBy(x => string.IsNullOrWhiteSpace(x.ConversationCategory) ? \"unknown\" : x.ConversationCategory!.ToLowerInvariant())\n//                .ToDictionary(g => g.Key, g => g.Count());\n\n//            dto.SpendByCurrency = list\n//                .Where(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency))\n//                .GroupBy(x => x.PriceCurrency!)\n//                .ToDictionary(g => g.Key, g => g.Sum(v => v.PriceAmount!.Value));\n\n//            return dto;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingIngestService.cs",
      "sha256": "8678a1ec3a5979b124caa81faa47d93d5ca21bd8c0d97bf35a8d55bb50824bdf",
      "language": "csharp",
      "size": 416,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingIngestService\n    {\n        Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson);\n        Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson);\n        \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingReadService.cs",
      "sha256": "146ab2ebc0dea7d43cd6d050c51c28118cf4c7655b369657e198861aa6c9c3ca",
      "language": "csharp",
      "size": 306,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingReadService\n    {\n        Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Controllers/BusinessesController.cs",
      "sha256": "a37f76360f9d1f356eb29e802bba2b199ff644811854d1f026ee04e86b3f06d2",
      "language": "csharp",
      "size": 6134,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Helpers;\nusing Serilog;\nusing System.Security.Claims;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing Microsoft.AspNetCore.Authorization;\n\nnamespace xbytechat.api.Features.BusinessModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class BusinessesController : ControllerBase\n    {\n        private readonly IBusinessService _businessService;\n\n        public BusinessesController(IBusinessService businessService)\n        {\n            _businessService = businessService;\n        }\n\n\n\n        [HttpGet(\"pending\")]\n        [Authorize(Roles = \"admin,superadmin,partner\")] // partners see scoped; admin/superadmin see ALL\n        public async Task<IActionResult> GetPendingBusinesses()\n        {\n            try\n            {\n                // Read role/id from multiple possible claim types\n                var role = User.FindFirst(ClaimTypes.Role)?.Value\n                           ?? User.FindFirst(\"role\")?.Value\n                           ?? User.FindFirst(\"roles\")?.Value\n                           ?? \"\";\n\n                var userId = User.FindFirst(\"id\")?.Value\n                           ?? User.FindFirst(ClaimTypes.NameIdentifier)?.Value\n                           ?? User.FindFirst(\"sub\")?.Value\n                           ?? \"\";\n\n                var result = await _businessService.GetPendingBusinessesAsync(role, userId);\n                return Ok(ResponseResult.SuccessInfo(\"✅ Pending businesses fetched successfully.\", result));\n            }\n            catch\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"❌ Failed to fetch pending businesses. Please try again later.\"));\n            }\n        }\n\n\n        // ✅ Get business by ID (used for profile completion)\n\n        [HttpGet(\"{id}\")]\n        public async Task<IActionResult> GetBusinessById(Guid id)\n        {\n            try\n            {\n                var business = await _businessService.GetByIdAsync(id);\n                if (business == null)\n                    return NotFound(ResponseResult.ErrorInfo(\"❌ Business not found.\"));\n\n                return Ok(business);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"🚨 Failed to fetch business. \" + ex.Message));\n            }\n        }\n\n        [HttpPut(\"assigned-to/{id}\")]\n        public async Task<IActionResult> UpdateBusiness(Guid id, [FromBody] Business business)\n        {\n            if (id != business.Id)\n            {\n                return BadRequest(new { message = \"❌ ID mismatch.\" });\n            }\n\n            var result = await _businessService.UpdateBusinessAsync(business);\n            if (!result.Success)\n            {\n                return BadRequest(result);\n            }\n\n            return Ok(result);\n        }\n\n\n        // 🟢 Approve a business\n        [HttpPost(\"approve/{id}\")]\n        public async Task<IActionResult> Approve(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.ApproveBusinessAsync(id);\n\n                if (result.Success)\n                {\n                    // ✅ Optional Success Logging\n                    Log.Information(\"✅ Business approved successfully. BusinessId: {BusinessId}\", id);\n                    return Ok(result);\n                }\n                else\n                {\n                    // ✅ Optional Warning Logging\n                    Log.Warning(\"⚠️ Business approval failed. BusinessId: {BusinessId} - Message: {Message}\", id, result.Message);\n                    return BadRequest(result);\n                }\n            }\n            catch (Exception ex)\n            {\n                // ✅ Proper Error Logging\n                Log.Error(ex, \"❌ Exception occurred while approving business. BusinessId: {BusinessId}\", id);\n\n                return StatusCode(500, ResponseResult.ErrorInfo(\n                    \"❌ Something went wrong while approving business. Please try again later.\"\n                ));\n            }\n        }\n\n\n        // 🔴 Reject a business\n        [HttpPost(\"reject/{id}\")]\n        public async Task<IActionResult> Reject(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.RejectBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"❌ Failed to reject business. \" + ex.Message));\n            }\n        }\n\n        // 🟡 Put a business on hold\n        [HttpPost(\"hold/{id}\")]\n        public async Task<IActionResult> Hold(Guid id)\n        {\n            try\n            {\n                var result = await _businessService.HoldBusinessAsync(id);\n                return result.Success ? Ok(result) : NotFound(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"❌ Failed to hold business. \" + ex.Message));\n            }\n        }\n\n        // 🛠 Complete profile after signup\n        [HttpPost(\"profile-completion/{businessId}\")]\n        public async Task<IActionResult> CompleteProfile(Guid businessId, [FromBody] ProfileCompletionDto dto)\n        {\n            try\n            {\n                var result = await _businessService.CompleteProfileAsync(businessId, dto);\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                return StatusCode(500, ResponseResult.ErrorInfo(\"❌ Failed to update profile. \" + ex.Message));\n            }\n        }\n\n        [HttpGet(\"approved\")]\n        [Authorize(Roles = \"SuperAdmin\")]\n        public async Task<IActionResult> GetApprovedBusinesses()\n        {\n            var result = await _businessService.GetApprovedBusinessesAsync();\n            return Ok(result);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/PendingBusinessDto.cs",
      "sha256": "262c7390254b692bef62525ec48c34eb502354e446d2e98e77586b32f640f2be",
      "language": "csharp",
      "size": 482,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class PendingBusinessDto\n    {\n        public Guid BusinessId { get; set; }\n        public string CompanyName { get; set; }\n        public string BusinessEmail { get; set; }\n        public string? RepresentativeName { get; set; }\n        public string? Phone { get; set; }\n        public string Plan { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public bool? IsApproved { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/ProfileCompletionDto.cs",
      "sha256": "cbd238cd045c0ee7bfc5061311058fa84005f29244727a11ef5b7a6eedbcf64f",
      "language": "csharp",
      "size": 489,
      "content": "namespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class ProfileCompletionDto\n    {\n        public string? BusinessName { get; set; }\n        public string? ReperesentativeName { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Phone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/DTOs/SignupBusinessDto.cs",
      "sha256": "daebace2d54e91a96825decc469c8acd57822d3e74bd5271ca80792e36cbb30e",
      "language": "csharp",
      "size": 717,
      "content": "using System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.BusinessModule.DTOs\n{\n    public class SignupBusinessDto\n    {\n        [Required]\n        public string CompanyName { get; set; }\n\n        [Required]\n        [EmailAddress]\n        public string Email { get; set; }\n\n        [Required]\n        public string Password { get; set; }\n\n        public string? RepresentativeName { get; set; }\n\n        public string? Phone { get; set; }\n        public string RoleName { get; set; } = \"business\"; // Default to business role\n\n        // 🆕 NEW FIELD (Internal use only)\n        public Guid? CreatedByPartnerId { get; set; } // to assign the business to a specific user/agent/partner}\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Models/Business.cs",
      "sha256": "88684dd541d49eb7c1c8d896f46aa2a50c59c2f7385cdbaae206d7829b0616c3",
      "language": "csharp",
      "size": 2914,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat_api.WhatsAppSettings.Models;\n\nnamespace xbytechat.api.Features.BusinessModule.Models\n{\n    public class Business\n    {\n        public Guid Id { get; set; }\n\n        // 🏢 Basic Info\n        public string? CompanyName { get; set; }\n        public string BusinessName { get; set; }\n        public string BusinessEmail { get; set; }  // Not used for login, just business contact\n        public string? RepresentativeName { get; set; }\n\n        public Guid? CreatedByPartnerId { get; set; }\n        public string? Phone { get; set; }\n        public string? CompanyPhone { get; set; }\n        public string? Website { get; set; }\n        public string? Address { get; set; }\n        public string? Industry { get; set; }\n        public string? LogoUrl { get; set; }\n\n        // 📦 SaaS Plan & Status using Enums\n        // public enum PlanType { Basic, Smart, Advanced } -- moved to bisinessinfo\n        // public PlanType Plan { get; set; } = PlanType.Basic;  // moved to bisinessinfo\n        public enum StatusType { Pending, Approved, Rejected }\n        public StatusType Status { get; set; } = StatusType.Pending;  // Default to Pending\n\n        // 📝 Metadata\n        public string? Tags { get; set; }\n        public string? Source { get; set; }\n        public string? Notes { get; set; }\n\n        // 📅 Timestamps\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public bool IsApproved { get; set; } = false;\n        public string? ApprovedBy { get; set; }\n        public DateTime? ApprovedAt { get; set; }\n        public DateTime? LastLoginAt { get; set; }\n\n        // 🗑 Soft Deletion\n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n        public string? DeletedBy { get; set; }\n\n        // 👥 Navigation Property - List of Users (nullable if no users)\n        public List<User> Users { get; set; } = new();\n\n\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n        public ICollection<Campaign> Campaigns { get; set; } = new List<Campaign>();\n        // 🔗 Plan Info linked\n\n        /// This is a one-to-one relationship with BusinessPlanInfo\n        public BusinessPlanInfo? BusinessPlanInfo { get; set; }\n\n        public Guid? PlanId { get; set; } // Nullable in case no plan is assigned yet\n        public Plan? Plan { get; set; }   // Navigation property to the Plan entity\n\n       // public WhatsAppSettingEntity WhatsAppSettings { get; set; }\n        public ICollection<WhatsAppSettingEntity> WhatsAppSettings { get; set; }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/BusinessService.cs",
      "sha256": "d6d0693abd329640c88df84e5a648966ef197a27291c9889c12bf27c3c67f355",
      "language": "csharp",
      "size": 18183,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing System.Security.Cryptography;\nusing System.Text;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.AccessControl.Models;\nusing xbytechat.api.Features.AuditTrail.Models;\nusing xbytechat.api.Features.AuditTrail.Services;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.PlanManagement.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models.BusinessModel;\nusing xbytechat.api.Repositories.Interfaces;\n\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n    public class BusinessService : IBusinessService\n    {\n        private readonly IGenericRepository<Business> _businessRepo;\n        private readonly IGenericRepository<User> _userRepo;\n        private readonly IGenericRepository<Role> _roleRepo;\n        private readonly IAuditLogService _auditLogService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n        // inside BusinessService class (class scope, not inside a method)\n        private static readonly Guid BASIC_PLAN_ID = Guid.Parse(\"5f9f5de1-a0b2-48ba-b03d-77b27345613f\");\n\n        public BusinessService(\n            IGenericRepository<Business> businessRepo,\n            IGenericRepository<User> userRepo,\n            IGenericRepository<Role> roleRepo,\n            IAuditLogService auditLogService,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _businessRepo = businessRepo;\n            _userRepo = userRepo;\n            _roleRepo = roleRepo;\n            _auditLogService = auditLogService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n        public async Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto)\n        {\n            var normalizedEmail = dto.Email.Trim().ToLower();\n            var existing = await _userRepo.FirstOrDefaultAsync(u => u.Email == normalizedEmail);\n            if (existing != null)\n                return ResponseResult.ErrorInfo(\"❌ Email already exists\");\n\n            var business = new Business\n            {\n                Id = Guid.NewGuid(),\n                CompanyName = dto.CompanyName,\n                BusinessName = dto.CompanyName,\n                BusinessEmail = normalizedEmail,\n                RepresentativeName = dto.RepresentativeName,\n                Phone = dto.Phone,\n                Status = Business.StatusType.Pending,\n                // Plan = PlanType.Basic,\n                IsApproved = false,\n                CreatedAt = DateTime.UtcNow,\n                PlanId = BASIC_PLAN_ID   // ✅ hard-code Basic plan here\n            };\n            // STEP 2: Create Plan Info separately\n            var planInfo = new BusinessPlanInfo\n            {\n                BusinessId = business.Id,\n                Plan = PlanType.Basic,\n                TotalMonthlyQuota = 1000,\n                RemainingMessages = 1000,\n                QuotaResetDate = DateTime.UtcNow.AddMonths(1),\n                WalletBalance = 0\n            };\n            // STEP 3: Link them\n            business.BusinessPlanInfo = planInfo;\n            // STEP 4: Save both\n            await _businessRepo.AddAsync(business);\n            await _businessRepo.SaveAsync();\n\n            var role = await _roleRepo.FirstOrDefaultAsync(r => r.Name.ToLower() == dto.RoleName.Trim().ToLower());\n\n            if (role == null)\n                return ResponseResult.ErrorInfo(\"❌ Invalid role specified\");\n\n            var user = new User\n            {\n                Id = Guid.NewGuid(),\n                Name = dto.CompanyName,\n                Email = normalizedEmail,\n                PasswordHash = HashPassword(dto.Password),\n                Role = role,\n                Status = \"Pending\",\n                BusinessId = business.Id\n            };\n\n            await _userRepo.AddAsync(user);\n            await _userRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = user.Id,\n                PerformedByUserName = user.Name,\n                RoleAtTime = \"business\",\n                ActionType = \"business.signup\",\n                Description = $\"New business signup: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"✅ Signup successful. Pending approval.\", new { BusinessId = business.Id });\n        }\n\n        public async Task<ResponseResult> UpdateBusinessAsync(Business business)\n        {\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"❌ Invalid business object provided.\");\n\n            try\n            {\n                _businessRepo.Update(business);\n                await _businessRepo.SaveAsync();\n\n                return ResponseResult.SuccessInfo(\"✅ Business updated successfully.\");\n            }\n            catch (Exception ex)\n            {\n                // 🚨 Catch any unexpected error\n                return ResponseResult.ErrorInfo(\"❌ Failed to update business: \" + ex.Message);\n            }\n        }\n\n        //public async Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId)\n        //{\n        //    try\n        //    {\n        //        role = role?.ToLowerInvariant();\n\n        //         ✅ Superadmin / admin: see ALL pending, ignore userId\n        //        if (role == \"superadmin\" || role == \"admin\")\n        //        {\n        //            var all = await _businessRepo.AsQueryable()\n        //                .Where(b => b.Status == Business.StatusType.Pending && !b.IsDeleted)\n        //                .OrderByDescending(b => b.CreatedAt)\n        //                .ToListAsync();\n\n        //            return all.Select(b => new PendingBusinessDto\n        //            {\n        //                BusinessId = b.Id,\n        //                CompanyName = b.CompanyName ?? \"\",\n        //                BusinessEmail = b.BusinessEmail ?? \"\",\n        //                RepresentativeName = b.RepresentativeName ?? \"\",\n        //                Phone = b.Phone ?? \"\",\n        //                Plan = b.BusinessPlanInfo?.Plan.ToString() ?? \"Unknown\",\n        //                CreatedAt = b.CreatedAt,\n        //                IsApproved = b.IsApproved\n        //            }).ToList();\n        //        }\n\n        //         🧭 Partner: scoped list(unchanged)\n        //        if (role == \"partner\" && Guid.TryParse(userId, out var partnerGuid))\n        //        {\n        //            var scoped = await _businessRepo.AsQueryable()\n        //                .Where(b => b.Status == Business.StatusType.Pending\n        //                            && !b.IsDeleted\n        //                            && b.CreatedByPartnerId == partnerGuid)\n        //                .OrderByDescending(b => b.CreatedAt)\n        //                .ToListAsync();\n\n        //            return scoped.Select(b => new PendingBusinessDto\n        //            {\n        //                BusinessId = b.Id,\n        //                CompanyName = b.CompanyName ?? \"\",\n        //                BusinessEmail = b.BusinessEmail ?? \"\",\n        //                RepresentativeName = b.RepresentativeName ?? \"\",\n        //                Phone = b.Phone ?? \"\",\n        //                Plan = b.BusinessPlanInfo?.Plan.ToString() ?? \"Unknown\",\n        //                CreatedAt = b.CreatedAt,\n        //                IsApproved = b.IsApproved\n        //            }).ToList();\n        //        }\n\n        //        Everyone else: empty\n        //        return new();\n        //    }\n        //    catch\n        //    {\n        //        return new();\n        //    }\n        //}\n\n\n        public async Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId)\n        {\n            try\n            {\n                var roleLc = (role ?? \"\").ToLowerInvariant();\n\n                // base: pending + not deleted\n                IQueryable<Business> q = _businessRepo.AsQueryable()\n                    .AsNoTracking()\n                    .Include(b => b.BusinessPlanInfo)   // ✅ load enum Plan from BusinessPlanInfo\n                                                        // .Include(b => b.Plan)            // ← only if you have a Plan navigation property\n                    .Where(b => b.Status == Business.StatusType.Pending && !b.IsDeleted);\n\n                // scope for partner\n                if (roleLc == \"partner\")\n                {\n                    if (!Guid.TryParse(userId, out var partnerId)) return new();\n                    q = q.Where(b => b.CreatedByPartnerId == partnerId);\n                }\n                else if (roleLc != \"admin\" && roleLc != \"superadmin\")\n                {\n                    return new(); // anyone else: nothing\n                }\n\n                var items = await q.OrderByDescending(b => b.CreatedAt).ToListAsync();\n\n                // Map to your existing DTO; with Include() the enum will be present\n                return items.Select(b => new PendingBusinessDto\n                {\n                    BusinessId = b.Id,\n                    CompanyName = b.CompanyName ?? \"\",\n                    BusinessEmail = b.BusinessEmail ?? \"\",\n                    RepresentativeName = b.RepresentativeName ?? \"\",\n                    Phone = b.Phone ?? \"\",\n                    // Shows \"Basic\" etc. because BusinessPlanInfo is now loaded\n                    Plan = b.BusinessPlanInfo?.Plan.ToString() ?? \"Unknown\",\n                    CreatedAt = b.CreatedAt,\n                    IsApproved = b.IsApproved\n                }).ToList();\n            }\n            catch\n            {\n                return new();\n            }\n        }\n\n        public async Task<ResponseResult> ApproveBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo\n                .AsQueryable()\n                .Include(b => b.Users)\n                .FirstOrDefaultAsync(b => b.Id == businessId);\n\n            if (business == null)\n                return ResponseResult.ErrorInfo(\"❌ Business not found.\");\n\n            // ✅ Current Logged-in User Details\n            var httpContext = _httpContextAccessor.HttpContext;\n            var currentUserId = httpContext?.User?.FindFirst(\"id\")?.Value;\n            var currentUserRole = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"role\"))?.Value;\n            //httpContext?.User?.FindFirst(\"role\")?.Value;\n\n            // var currentUserName = httpContext?.User?.FindFirst(\"name\")?.Value ?? \"Unknown\";\n            var currentUserName = httpContext?.User?.Claims\n    .FirstOrDefault(c => c.Type.Contains(\"name\"))?.Value ?? \"Unknown\";\n            if (string.IsNullOrEmpty(currentUserId) || string.IsNullOrEmpty(currentUserRole))\n                return ResponseResult.ErrorInfo(\"❌ Unauthorized access. Please login again.\");\n\n            var currentGuid = Guid.Parse(currentUserId);\n\n            // ✅ Authorization Logic\n            var isSuperAdmin = currentUserRole.Equals(\"admin\", StringComparison.OrdinalIgnoreCase) ||\n                               currentUserRole.Equals(\"superadmin\", StringComparison.OrdinalIgnoreCase);\n\n            var isAssignedPartner = business.CreatedByPartnerId.HasValue &&\n                                     business.CreatedByPartnerId.Value == currentGuid;\n\n            if (!isSuperAdmin && !isAssignedPartner)\n            {\n                return ResponseResult.ErrorInfo(\"⛔ You are not authorized to approve this business.\");\n            }\n\n            // ✅ Approve Business\n       \n            business.IsApproved = true;\n            business.Status = Business.StatusType.Approved;\n            business.ApprovedAt = DateTime.UtcNow;\n            business.ApprovedBy = currentUserName;\n                       _businessRepo.Update(business);\n\n            // ✅ Update all Users to \"ProfilePending\"\n            foreach (var user in business.Users)\n            {\n                user.Status = \"Active\";\n                _userRepo.Update(user);\n            }\n\n            await _businessRepo.SaveAsync();\n            await _userRepo.SaveAsync();\n\n            // ✅ Audit Log\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = currentGuid,\n                PerformedByUserName = currentUserName,\n                RoleAtTime = currentUserRole,\n                ActionType = \"business.approved\",\n                Description = $\"Business approved: {business.CompanyName}\",\n                IPAddress = httpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = httpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"✅ Business approved successfully.\");\n        }\n\n        public async Task<ResponseResult> RejectBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"❌ Business not found\");\n\n            business.Status = Business.StatusType.Rejected;\n            business.IsDeleted = true;\n            business.DeletedAt = DateTime.UtcNow;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.rejected\",\n                Description = $\"Business rejected: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"✅ Business rejected and marked as deleted\");\n        }\n\n        public async Task<ResponseResult> HoldBusinessAsync(Guid businessId)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"❌ Business not found\");\n\n            business.IsApproved = false;\n            business.Status = Business.StatusType.Pending;\n\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n\n            await _auditLogService.SaveLogAsync(new AuditLog\n            {\n                BusinessId = business.Id,\n                PerformedByUserId = Guid.TryParse(_httpContextAccessor.HttpContext?.User?.FindFirst(\"id\")?.Value, out var userId) ? userId : Guid.Empty,\n                PerformedByUserName = _httpContextAccessor.HttpContext?.User?.FindFirst(\"email\")?.Value,\n                RoleAtTime = _httpContextAccessor.HttpContext?.User?.FindFirst(\"role\")?.Value,\n                ActionType = \"business.hold\",\n                Description = $\"Business put on hold: {business.CompanyName}\",\n                IPAddress = _httpContextAccessor.HttpContext?.Connection?.RemoteIpAddress?.ToString(),\n                UserAgent = _httpContextAccessor.HttpContext?.Request?.Headers[\"User-Agent\"].ToString()\n            });\n\n            return ResponseResult.SuccessInfo(\"⏸ Business put on hold\");\n        }\n\n        public async Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto)\n        {\n            var business = await _businessRepo.FindByIdAsync(businessId);\n            if (business is null)\n                return ResponseResult.ErrorInfo(\"❌ Business not found\");\n\n            if (!string.IsNullOrEmpty(dto.BusinessName)) business.BusinessName = dto.BusinessName;\n            if (!string.IsNullOrEmpty(dto.CompanyPhone)) business.CompanyPhone = dto.CompanyPhone;\n            if (!string.IsNullOrEmpty(dto.Website)) business.Website = dto.Website;\n            if (!string.IsNullOrEmpty(dto.Address)) business.Address = dto.Address;\n            if (!string.IsNullOrEmpty(dto.Industry)) business.Industry = dto.Industry;\n            if (!string.IsNullOrEmpty(dto.LogoUrl)) business.LogoUrl = dto.LogoUrl;\n            if (!string.IsNullOrEmpty(dto.ReperesentativeName)) business.RepresentativeName = dto.ReperesentativeName;\n            if (!string.IsNullOrEmpty(dto.Phone)) business.Phone = dto.Phone;\n            _businessRepo.Update(business);\n            await _businessRepo.SaveAsync();\n            return ResponseResult.SuccessInfo(\"✅ Profile updated successfully\");\n        }\n\n        public async Task<Business?> GetBusinessByEmailAsync(string email)\n        {\n            return await _businessRepo.FirstOrDefaultAsync(b => b.BusinessEmail.ToLower() == email.Trim().ToLower());\n        }\n\n        private string HashPassword(string password)\n        {\n            using var sha = SHA256.Create();\n            var bytes = Encoding.UTF8.GetBytes(password);\n            var hash = sha.ComputeHash(bytes);\n            return Convert.ToBase64String(hash);\n        }\n\n        public async Task<Business?> GetByIdAsync(Guid businessId)\n        {\n            return await _businessRepo.FindByIdAsync(businessId);\n        }\n\n        public async Task<List<Business>> GetApprovedBusinessesAsync()\n        {\n            return await _businessRepo.AsQueryable()\n               .Where(b => b.IsApproved && !b.IsDeleted)\n               .OrderBy(b => b.CompanyName)\n               .ToListAsync();\n        }\n        public IQueryable<Business> Query()\n        {\n            return _businessRepo.AsQueryable();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/BusinessModule/Services/IBusinessService.cs",
      "sha256": "5205ee768b8669a55cd022a8bec1e88cabbc330f576d4532922b1e43378461ed",
      "language": "csharp",
      "size": 1180,
      "content": "using System.Runtime.CompilerServices;\nusing xbytechat.api.Features.BusinessModule.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Models;\nnamespace xbytechat.api.Features.BusinessModule.Services\n{\n\n    public interface IBusinessService\n    {\n        IQueryable<Business> Query();\n        Task<ResponseResult> SignupBusinessAsync(SignupBusinessDto dto); /// Signup + create admin user\n\n        Task<ResponseResult> ApproveBusinessAsync(Guid businessId);      // Admin action\n        Task<ResponseResult> RejectBusinessAsync(Guid businessId);       // Admin action\n        Task<ResponseResult> HoldBusinessAsync(Guid businessId);         // Admin action\n        Task<ResponseResult> CompleteProfileAsync(Guid businessId, ProfileCompletionDto dto); // Post-login completion\n        Task<Business?> GetBusinessByEmailAsync(string email);\n        Task<Business?> GetByIdAsync(Guid businessId);\n        Task<ResponseResult> UpdateBusinessAsync(Business business);\n        Task<List<PendingBusinessDto>> GetPendingBusinessesAsync(string role, string userId);\n        Task<List<Business>> GetApprovedBusinessesAsync();\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignController.cs",
      "sha256": "3ac64096a0e207027ed704a44ed1519f3a97ddcd184cde3ab9373c70938316b0",
      "language": "csharp",
      "size": 13885,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing System;\nusing System.Security.Claims;\nusing System.Threading.Tasks;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.BusinessModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\nusing static xbytechat.api.Features.MessagesEngine.Controllers.MessageEngineController;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class CampaignController : ControllerBase\n    {\n        private readonly ICampaignService _campaignService;\n        private readonly IBusinessService _businessService;\n        private readonly IMessageEngineService _messageService;\n        private readonly IHttpContextAccessor _httpContextAccessor;\n\n        public CampaignController(\n            ICampaignService campaignService,\n            IBusinessService businessService,\n            IMessageEngineService messageEngineService,\n            IHttpContextAccessor httpContextAccessor)\n        {\n            _campaignService = campaignService;\n            _businessService = businessService;\n            _messageService = messageEngineService;\n            _httpContextAccessor = httpContextAccessor;\n        }\n\n\n        [HttpGet(\"get-image-campaign\")]\n        public async Task<IActionResult> GetAll([FromQuery] string? type)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var items = await _campaignService.GetAllCampaignsAsync(businessId, type);\n            return Ok(items);\n        }\n        [HttpGet(\"paginated\")]\n        public async Task<IActionResult> GetPaginatedCampaigns([FromQuery] PaginatedRequest request)\n        {\n            var user = HttpContext.User;\n            var businessIdClaim = user.FindFirst(\"businessId\");\n\n            if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                return Unauthorized(new { message = \"🚫 Invalid or missing BusinessId claim.\" });\n\n            var result = await _campaignService.GetPaginatedCampaignsAsync(businessId, request);\n            return Ok(result);\n        }\n\n        [HttpGet(\"debug-claims\")]\n        public IActionResult DebugClaims()\n        {\n            var user = HttpContext.User;\n            var businessId = user.FindFirst(\"businessId\")?.Value;\n\n            return Ok(new\n            {\n                name = user.Identity?.Name,\n                businessId\n            });\n        }\n\n        [HttpPost(\"create-text-campaign\")]\n        public async Task<IActionResult> CreateTextCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var businessIdClaim = User.FindFirst(\"businessId\")?.Value;\n                if (!Guid.TryParse(businessIdClaim, out var businessId))\n                    return Unauthorized(new { message = \"🚫 Invalid or missing BusinessId claim.\" });\n\n                var createdBy = User.Identity?.Name ?? \"system\";\n\n                if (string.IsNullOrWhiteSpace(dto.Name))\n                    return BadRequest(new { message = \"🚫 Campaign name is required.\" });\n\n                if (string.IsNullOrWhiteSpace(dto.TemplateId))\n                    return BadRequest(new { message = \"🚫 TemplateId is required for template campaigns.\" });\n\n                if (string.IsNullOrWhiteSpace(dto.MessageTemplate))\n                    return BadRequest(new { message = \"🚫 Message template content is required.\" });\n\n                var campaignId = await _campaignService.CreateTextCampaignAsync(dto, businessId, createdBy);\n\n                return campaignId != null\n                    ? Ok(new\n                    {\n                        success = true,\n                        message = \"✅ Campaign created successfully\",\n                        campaignId = campaignId.Value\n                    })\n                    : BadRequest(new { success = false, message = \"❌ Failed to create campaign\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Exception in CreateTextCampaign\");\n                return StatusCode(500, new { message = \"🚨 Internal server error\", error = ex.Message });\n            }\n        }\n\n        [HttpPost(\"create-image-campaign\")]\n        public async Task<IActionResult> CreateImageCampaign([FromBody] CampaignCreateDto dto)\n        {\n            try\n            {\n                var user = HttpContext.User;\n                var businessIdClaim = user.FindFirst(\"businessId\");\n\n                if (businessIdClaim == null || !Guid.TryParse(businessIdClaim.Value, out var businessId))\n                    return Unauthorized(new { message = \"🚫 Invalid or missing BusinessId claim.\" });\n\n                if (dto.MultiButtons != null && dto.MultiButtons.Any())\n                {\n                    var allowedTypes = new[] { \"url\", \"copy_code\", \"flow\", \"phone_number\", \"quick_reply\" };\n                    foreach (var button in dto.MultiButtons)\n                    {\n                        var type = button.ButtonType?.Trim().ToLower();\n\n                        if (!allowedTypes.Contains(type))\n                            return BadRequest(new { message = $\"❌ Invalid ButtonType: '{type}' is not supported.\" });\n\n                        var needsValue = new[] { \"url\", \"flow\", \"copy_code\", \"phone_number\" };\n                        if (needsValue.Contains(type) && string.IsNullOrWhiteSpace(button.TargetUrl))\n                            return BadRequest(new { message = $\"❌ Button '{button.ButtonText}' requires a valid TargetUrl or Value for type '{type}'.\" });\n\n                        if (button.TargetUrl?.ToLower() == \"unknown\")\n                            return BadRequest(new { message = $\"❌ Invalid value 'unknown' found in button '{button.ButtonText}'.\" });\n                    }\n                }\n\n                var createdBy = user.Identity?.Name ?? \"system\";\n                var campaignId = await _campaignService.CreateImageCampaignAsync(businessId, dto, createdBy);\n\n                return Ok(new\n                {\n                    success = true,\n                    message = \"✅ Campaign created successfully\",\n                    campaignId\n                });\n            }\n            catch (UnauthorizedAccessException ex)\n            {\n                return BadRequest(new { message = ex.Message });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Exception in CreateImageCampaign\");\n                return StatusCode(500, new { message = \"🚨 Internal server error\", error = ex.Message });\n            }\n        }\n\n        // ✅ Moved above {id} routes\n        [HttpPost(\"{id}/assign-contacts\")]\n        public async Task<IActionResult> AssignContactsToCampaign(Guid id, [FromBody] AssignContactsDto request)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.AssignContactsToCampaignAsync(id, businessId, request.ContactIds);\n\n                return success\n                    ? Ok(new { message = \"✅ Contacts assigned\" })\n                    : BadRequest(new { message = \"❌ Failed to assign contacts\" });\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"❌ Error assigning contacts: \" + ex.Message);\n                return StatusCode(500, new { message = \"Internal error\", error = ex.Message });\n            }\n        }\n\n        [HttpDelete(\"{campaignId}/recipients/{contactId}\")]\n        public async Task<IActionResult> RemoveCampaignRecipient(Guid campaignId, Guid contactId)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var success = await _campaignService.RemoveRecipientAsync(businessId, campaignId, contactId);\n\n                if (!success)\n                    return NotFound(new { message = \"Recipient not found or not assigned\" });\n\n                return NoContent();\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"❌ Remove recipient failed: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error removing recipient\", detail = ex.Message });\n            }\n        }\n\n        // Put this inside CampaignService (same class as SendTemplateCampaignWithTypeDetectionAsync)\n        private static string? ResolveRecipientPhone(CampaignRecipient r)\n        {\n            // Try Contact first, then AudienceMember fallbacks\n            return r?.Contact?.PhoneNumber\n                ?? r?.AudienceMember?.PhoneE164\n                ?? r?.AudienceMember?.PhoneRaw;\n        }\n\n        // Send All Type of campaign method \n        [HttpPost(\"send-campaign/{campaignId}\")] // use to send free text and Template campaigns\n        public async Task<IActionResult> SendTemplateCampaign(Guid campaignId)\n        {\n            try\n            {\n                var result = await _campaignService.SendTemplateCampaignWithTypeDetectionAsync(campaignId);\n                return result.Success ? Ok(result) : BadRequest(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Exception while sending image template campaign\");\n                return StatusCode(500, ResponseResult.ErrorInfo(\"🚨 Server error while sending campaign\", ex.ToString()));\n            }\n        }\n\n        [HttpPost(\"send-template-campaign/{id}\")]\n        public async Task<IActionResult> SendImageCampaign(Guid id)\n        {\n            var result = await _campaignService.SendTemplateCampaignAsync(id);\n            return result.Success ? Ok(result) : BadRequest(result);\n        }\n\n        [HttpPost(\"send/{campaignId}\")]\n        public async Task<IActionResult> SendCampaign(Guid campaignId)\n        {\n            try\n            {\n                var ipAddress = HttpContext.Connection.RemoteIpAddress?.ToString() ?? \"unknown\";\n                var userAgent = Request.Headers[\"User-Agent\"].ToString() ?? \"unknown\";\n\n                var success = await _campaignService.SendCampaignAsync(campaignId, ipAddress, userAgent);\n\n                return success\n                    ? Ok(new { success = true, message = \"✅ Campaign sent successfully\" })\n                    : BadRequest(new { success = false, message = \"❌ Campaign sending failed\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"❌ Exception in SendCampaign\");\n                return StatusCode(500, new { success = false, message = \"🚨 Internal Server Error\", error = ex.Message });\n            }\n        }\n\n        [HttpPut(\"{id}\")]\n        public async Task<IActionResult> UpdateCampaign(Guid id, [FromBody] CampaignCreateDto dto)\n        {\n            var result = await _campaignService.UpdateCampaignAsync(id, dto);\n            return result\n                ? Ok(new { message = \"✏️ Campaign updated successfully\" })\n                : BadRequest(new { message = \"❌ Update failed — only draft campaigns can be edited\" });\n        }\n\n        [HttpDelete(\"{id}\")]\n        public async Task<IActionResult> DeleteCampaign(Guid id)\n        {\n            var result = await _campaignService.DeleteCampaignAsync(id);\n            return result\n                ? Ok(new { message = \"🗑️ Campaign deleted successfully\" })\n                : BadRequest(new { message = \"❌ Delete failed — only draft campaigns can be deleted\" });\n        }\n        private Guid GetBusinessIdOrThrow()\n        {\n            string? raw =\n                User?.FindFirst(\"business_id\")?.Value ??\n                User?.FindFirst(\"BusinessId\")?.Value ??\n                User?.FindFirst(\"businessId\")?.Value ??\n                Request.Headers[\"X-Business-Id\"].FirstOrDefault();\n\n            if (!Guid.TryParse(raw, out var id))\n                throw new UnauthorizedAccessException(\"Business context missing.\");\n            return id;\n        }\n        [HttpGet(\"recipients/{id}\")]\n        public async Task<IActionResult> GetCampaignRecipients(Guid id)\n        {\n            try\n            {\n                var businessId = GetBusinessId();\n                var recipients = await _campaignService.GetRecipientsByCampaignIdAsync(id, businessId);\n                return Ok(recipients);\n            }\n            catch (Exception ex)\n            {\n                Console.WriteLine(\"❌ Error fetching campaign recipients: \" + ex.Message);\n                return StatusCode(500, new { message = \"Error fetching recipients\", detail = ex.Message });\n            }\n        }\n\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<CampaignDto>> GetCampaignById(Guid id)\n        {\n            var businessId = GetBusinessId();\n            var campaign = await _campaignService.GetCampaignByIdAsync(id, businessId);\n\n            if (campaign == null)\n                return NotFound();\n\n            return Ok(campaign);\n        }\n\n        private Guid GetBusinessId()\n        {\n            var claim = HttpContext.User.FindFirst(\"businessId\")?.Value;\n            if (string.IsNullOrEmpty(claim))\n                throw new UnauthorizedAccessException(\"BusinessId not found in token claims.\");\n\n            return Guid.Parse(claim);\n        }\n    \n        [HttpGet(\"list/{businessId:guid}\")]\n        public async Task<IActionResult> GetAvailableFlows(Guid businessId, [FromQuery] bool onlyPublished = true)\n        {\n            var items = await _campaignService.GetAvailableFlowsAsync(businessId, onlyPublished);\n            return Ok(new { success = true, items });\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignCsvSampleController.cs",
      "sha256": "e13843bfd6f5e2b253d20b7f78d49ff93bc77eff7d616da94f5ae0330559aeee",
      "language": "csharp",
      "size": 36970,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.AuthModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\nusing xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/csv-sample\")]\n    [Authorize]\n    public sealed class CampaignCsvSampleController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignPreviewService _preview;\n        private readonly IWhatsAppTemplateFetcherService _tpl;\n\n        public CampaignCsvSampleController(AppDbContext db, ICampaignPreviewService preview, IWhatsAppTemplateFetcherService tpl)\n        {\n            _db = db;\n            _preview = preview;\n            _tpl = tpl;\n        }\n\n        private sealed class SchemaResult\n        {\n            public bool Found { get; set; }\n            public List<string> Headers { get; set; } = new(); // dynamic per-row CSV columns (no phone, no media url)\n            public int PlaceholderCount { get; set; }           // body placeholders count\n            public string HeaderType { get; set; } = \"none\";     // \"none\" | \"image\" | \"video\" | \"document\" | \"text\"\n            public bool HeaderNeedsUrl { get; set; }             // true for image/video/document\n        }\n\n        // GET /api/campaigns/{campaignId}/csv-sample/schema\n        // GET /api/campaigns/{campaignId}/csv-sample/schema\n        [HttpGet(\"schema\")]\n        public async Task<IActionResult> GetSchema([FromRoute] Guid campaignId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var schema = await BuildSchemaAsync(businessId, campaignId, ct);\n            if (!schema.Found) return NotFound();\n\n            // Flatten so FE can read sc.headers / sc.placeholderCount\n            return Ok(new\n            {\n                headers = schema.Headers,                   // e.g. [\"parameter1\",\"headerpara1\",\"buttonpara1\"]\n                placeholderCount = schema.PlaceholderCount, // body placeholders count\n                header = new\n                {\n                    type = schema.HeaderType,               // \"none\" | \"image\" | \"video\" | \"document\" | \"text\"\n                    needsUrl = schema.HeaderNeedsUrl        // true for image/video/document\n                }\n            });\n        }\n\n        // GET /api/campaigns/{campaignId}/csv-sample\n        // -> returns ONLY the header row (no sample values)\n        [HttpGet]\n        public async Task<IActionResult> Download([FromRoute] Guid campaignId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var schema = await BuildSchemaAsync(businessId, campaignId, ct);\n            if (!schema.Found) return NotFound();\n\n            // phone is always first; then our dynamic columns (already lowercased)\n            var headers = new List<string> { \"phone\" };\n            headers.AddRange(schema.Headers);\n\n            var line = string.Join(\",\", headers.Select(EscapeCsv));\n            var bytes = Encoding.UTF8.GetBytes(line + \"\\n\");\n            var fileName = $\"campaign-{campaignId:N}-sample.csv\";\n            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n        }\n\n        // -------- schema builder (creates lowercase column names) --------\n        private async Task<SchemaResult> BuildSchemaAsync(Guid businessId, Guid campaignId, CancellationToken ct)\n        {\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId && !c.IsDeleted)\n                .Select(c => new { c.Id, c.BusinessId, c.TemplateId, c.MessageTemplate, c.Provider })\n                .FirstOrDefaultAsync(ct);\n\n            if (campaign == null)\n                return new SchemaResult { Found = false };\n\n            var templateName =\n                !string.IsNullOrWhiteSpace(campaign.TemplateId) ? campaign.TemplateId! :\n                !string.IsNullOrWhiteSpace(campaign.MessageTemplate) ? campaign.MessageTemplate! :\n                string.Empty;\n\n            if (string.IsNullOrWhiteSpace(templateName))\n            {\n                return new SchemaResult\n                {\n                    Found = true,\n                    Headers = new List<string>(), // dynamic columns only; \"phone\" is added by the downloader\n                    PlaceholderCount = 0,\n                    HeaderType = \"none\",\n                    HeaderNeedsUrl = false\n                };\n            }\n\n            var provider = (campaign.Provider ?? \"META_CLOUD\").ToUpperInvariant();\n\n            // 1) Normalized meta from service\n            var meta = await _tpl.GetTemplateMetaAsync(\n                campaign.BusinessId,\n                templateName,\n                language: null,\n                provider: provider\n            );\n\n            // 2) DB row fallback — NOTE: provider filter REMOVED to avoid mismatches\n            var tplRow = await _db.WhatsAppTemplates\n                .AsNoTracking()\n                .Where(w => w.BusinessId == businessId\n                            && w.IsActive\n                            && w.Name == templateName)\n                .OrderByDescending(w => w.UpdatedAt > w.CreatedAt ? w.UpdatedAt : w.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            var headers = new List<string>();\n\n            // BODY placeholders -> parameter1..N\n            int bodyCount = 0;\n            if (meta?.BodyPlaceholders is { Count: > 0 })\n            {\n                bodyCount = meta.BodyPlaceholders.Count;\n            }\n            else if (tplRow?.PlaceholderCount is int pc && pc > 0)\n            {\n                bodyCount = pc;\n            }\n            else\n            {\n                var bodyText = meta?.GetType().GetProperty(\"Body\")?.GetValue(meta) as string;\n                if (!string.IsNullOrWhiteSpace(bodyText))\n                {\n                    var m = Regex.Matches(bodyText, @\"\\{\\{\\s*(\\d+)\\s*\\}\\}\");\n                    if (m.Count > 0)\n                        bodyCount = m.Select(x => int.Parse(x.Groups[1].Value)).DefaultIfEmpty(0).Max();\n                }\n            }\n            for (int i = 1; i <= bodyCount; i++) headers.Add($\"parameter{i}\");\n\n            // HEADER detection (media is campaign-level; text header may have params)\n            string headerTypeNorm = (meta?.HeaderType ?? \"\").Trim().ToUpperInvariant();\n            if (string.IsNullOrEmpty(headerTypeNorm) && tplRow?.HasImageHeader == true)\n                headerTypeNorm = \"IMAGE\";\n\n            string respHeaderType = \"none\";\n            bool needsUrl = false;\n            switch (headerTypeNorm)\n            {\n                case \"IMAGE\": respHeaderType = \"image\"; needsUrl = true; break;\n                case \"VIDEO\": respHeaderType = \"video\"; needsUrl = true; break;\n                case \"DOCUMENT\":\n                case \"PDF\": respHeaderType = \"document\"; needsUrl = true; break;\n                case \"TEXT\": respHeaderType = \"text\"; needsUrl = false; break;\n                default: respHeaderType = \"none\"; needsUrl = false; break;\n            }\n\n            // Text header placeholders -> headerpara1..M\n            if (respHeaderType == \"text\")\n            {\n                int headerVarCount = 0;\n                var hpProp = meta?.GetType().GetProperty(\"HeaderPlaceholders\");\n                if (hpProp?.GetValue(meta) is IEnumerable<object> hpEnum)\n                {\n                    headerVarCount = hpEnum.Cast<object>().Count();\n                }\n                else\n                {\n                    var headerText =\n                        meta?.GetType().GetProperty(\"Header\")?.GetValue(meta) as string ??\n                        meta?.GetType().GetProperty(\"HeaderText\")?.GetValue(meta) as string ?? \"\";\n                    if (!string.IsNullOrWhiteSpace(headerText))\n                    {\n                        var m = Regex.Matches(headerText, @\"\\{\\{\\s*(\\d+)\\s*\\}\\}\");\n                        if (m.Count > 0)\n                            headerVarCount = m.Select(x => int.Parse(x.Groups[1].Value)).DefaultIfEmpty(0).Max();\n                    }\n                }\n                for (int i = 1; i <= headerVarCount; i++)\n                    headers.Add($\"headerpara{i}\");\n            }\n\n            // Dynamic URL buttons -> buttonpara1..3\n            bool LooksDynamic(string? val) => !string.IsNullOrEmpty(val) && val.Contains(\"{{\");\n            bool IsUrlish(string? type, string? subType)\n            {\n                type = (type ?? \"\").ToLowerInvariant();\n                subType = (subType ?? \"\").ToLowerInvariant();\n                return type == \"url\" || subType == \"url\";\n            }\n            int GetPos(object b, int fallbackOneBased)\n            {\n                var t = b.GetType();\n                if (t.GetProperty(\"Index\")?.GetValue(b) is int idx && idx > 0) return idx;\n                if (t.GetProperty(\"Order\")?.GetValue(b) is int ord && ord >= 0) return ord + 1;\n                if (t.GetProperty(\"Position\")?.GetValue(b) is int pos && pos > 0) return pos;\n                return fallbackOneBased;\n            }\n\n            var positions = new SortedSet<int>();\n\n            // A) normalized meta.Buttons\n            if (meta?.Buttons is { Count: > 0 })\n            {\n                var urlBtns = meta.Buttons\n                    .Where(b => IsUrlish(b.GetType().GetProperty(\"Type\")?.GetValue(b) as string,\n                                         b.GetType().GetProperty(\"SubType\")?.GetValue(b) as string))\n                    .ToList();\n\n                for (int i = 0; i < urlBtns.Count && positions.Count < 3; i++)\n                {\n                    var b = urlBtns[i];\n                    var val = b.GetType().GetProperty(\"Value\")?.GetValue(b) as string;\n                    var subType = b.GetType().GetProperty(\"SubType\")?.GetValue(b) as string;\n                    var urlType = b.GetType().GetProperty(\"UrlType\")?.GetValue(b) as string;\n                    var hasPh = b.GetType().GetProperty(\"HasPlaceholder\")?.GetValue(b) as bool?;\n\n                    var dynamicByProps =\n                        LooksDynamic(val) ||\n                        string.Equals(subType, \"DYNAMIC\", StringComparison.OrdinalIgnoreCase) ||\n                        string.Equals(urlType, \"DYNAMIC\", StringComparison.OrdinalIgnoreCase) ||\n                        hasPh == true;\n\n                    if (dynamicByProps)\n                    {\n                        var pos = GetPos(b, i + 1);\n                        if (pos >= 1 && pos <= 3) positions.Add(pos);\n                    }\n                }\n            }\n\n            // B) ButtonsJson fallback\n            if (positions.Count < 3 && !string.IsNullOrWhiteSpace(tplRow?.ButtonsJson))\n            {\n                try\n                {\n                    var root = JsonDocument.Parse(tplRow.ButtonsJson).RootElement;\n                    if (root.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var el in root.EnumerateArray())\n                        {\n                            if (positions.Count >= 3) break;\n\n                            var type = el.TryGetProperty(\"type\", out var tkn) ? tkn.GetString() : null;\n                            if (!IsUrlish(type, null)) continue;\n\n                            int pos = 0;\n                            if (el.TryGetProperty(\"index\", out var iTok) && iTok.TryGetInt32(out var idx) && idx > 0) pos = idx;\n                            else if (el.TryGetProperty(\"order\", out var oTok) && oTok.TryGetInt32(out var ord) && ord >= 0) pos = ord + 1;\n\n                            string? value = null;\n                            if (el.TryGetProperty(\"value\", out var vTok) && vTok.ValueKind == JsonValueKind.String)\n                                value = vTok.GetString();\n\n                            bool hasParam = false;\n                            if (el.TryGetProperty(\"parameters\", out var pTok) && pTok.ValueKind == JsonValueKind.Array)\n                            {\n                                foreach (var p in pTok.EnumerateArray())\n                                {\n                                    if (p.TryGetProperty(\"text\", out var txt) && txt.ValueKind == JsonValueKind.String)\n                                    {\n                                        var s = txt.GetString();\n                                        if (!string.IsNullOrEmpty(s) && s.Contains(\"{{\")) { hasParam = true; break; }\n                                    }\n                                }\n                            }\n\n                            if (LooksDynamic(value) || hasParam)\n                            {\n                                if (pos <= 0) pos = positions.Count + 1;\n                                if (pos >= 1 && pos <= 3) positions.Add(pos);\n                            }\n                        }\n                    }\n                }\n                catch { /* ignore bad JSON */ }\n            }\n\n            foreach (var pos in positions)\n            {\n                var key = $\"buttonpara{pos}\";\n                if (!headers.Contains(key, StringComparer.OrdinalIgnoreCase))\n                    headers.Add(key);\n            }\n\n            // ensure lowercase\n            headers = headers.Select(h => h.ToLowerInvariant()).ToList();\n\n            return new SchemaResult\n            {\n                Found = true,\n                Headers = headers,\n                PlaceholderCount = bodyCount,\n                HeaderType = respHeaderType,\n                HeaderNeedsUrl = needsUrl\n            };\n        }\n\n        private static string EscapeCsv(string input)\n        {\n            if (input == null) return \"\";\n            var needsQuotes = input.Contains(',') || input.Contains('\"') || input.Contains('\\n') || input.Contains('\\r');\n            var s = input.Replace(\"\\\"\", \"\\\"\\\"\");\n            return needsQuotes ? $\"\\\"{s}\\\"\" : s;\n        }\n    }\n}\n\n//using System;\n//using System.Collections.Generic;\n//using System.Linq;\n//using System.Text;\n//using System.Text.Json;\n//using System.Text.RegularExpressions;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Mvc;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat.api.AuthModule.Models;\n//using xbytechat.api.Features.CampaignModule.Services;\n//using xbytechat.api.Shared;\n//using xbytechat_api.WhatsAppSettings.Services; // User.GetBusinessId()\n\n//namespace xbytechat.api.Features.CampaignModule.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/campaigns/{campaignId:guid}/csv-sample\")]\n//    [Authorize]\n//    public sealed class CampaignCsvSampleController : ControllerBase\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ICampaignPreviewService _preview;\n//        private readonly IWhatsAppTemplateFetcherService _tpl;\n//        public CampaignCsvSampleController(AppDbContext db, ICampaignPreviewService preview, IWhatsAppTemplateFetcherService tpl)\n//        {\n//            _db = db;\n//            _preview = preview;\n//            _tpl = tpl;\n//        }\n\n//        // Add at top of file if missing:\n\n\n//        // -----------------------------------------------\n//        // DTO used internally for building the schema\n//        // -----------------------------------------------\n//        private sealed class SchemaResult\n//        {\n//            public bool Found { get; set; }\n//            public List<string> Headers { get; set; } = new();\n//            public int PlaceholderCount { get; set; } // body placeholders count\n//            public string HeaderType { get; set; } = \"none\"; // \"none\" | \"image\" | \"video\" | \"document\" | \"text\"\n//            public bool HeaderNeedsUrl { get; set; } // true for image/video/document header\n//        }\n\n//        // -----------------------------------------------\n//        // GET /campaigns/{campaignId}/csv-sample/schema\n//        // -----------------------------------------------\n//        [HttpGet(\"schema\")]\n//        public async Task<IActionResult> GetSchema([FromRoute] Guid campaignId, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized();\n\n//            var schema = await BuildSchemaAsync(businessId, campaignId, ct);\n//            if (!schema.Found) return NotFound();\n\n//            return Ok(new\n//            {\n//                success = true,\n//                data = new\n//                {\n//                    headers = schema.Headers,                     // ONLY per-row CSV fields (no phone, no media URL)\n//                    placeholderCount = schema.PlaceholderCount,   // body placeholders count\n//                    header = new\n//                    {\n//                        type = schema.HeaderType,                 // \"none\" | \"image\" | \"video\" | \"document\" | \"text\"\n//                        needsUrl = schema.HeaderNeedsUrl          // true iff header is image/video/document\n//                    }\n//                }\n//            });\n//        }\n\n//        // -----------------------------------------------\n//        // Builder\n//        // -----------------------------------------------\n//        private async Task<SchemaResult> BuildSchemaAsync(Guid businessId, Guid campaignId, CancellationToken ct)\n//        {\n//            var campaign = await _db.Campaigns\n//                .AsNoTracking()\n//                .Where(c => c.Id == campaignId && c.BusinessId == businessId && !c.IsDeleted)\n//                .Select(c => new { c.Id, c.BusinessId, c.TemplateId, c.MessageTemplate, c.Provider })\n//                .FirstOrDefaultAsync(ct);\n\n//            if (campaign == null)\n//                return new SchemaResult { Found = false };\n\n//            var templateName =\n//                !string.IsNullOrWhiteSpace(campaign.TemplateId) ? campaign.TemplateId! :\n//                !string.IsNullOrWhiteSpace(campaign.MessageTemplate) ? campaign.MessageTemplate! :\n//                string.Empty;\n\n//            // If no template selected, we still return a valid, empty schema (FE will just ask for phone).\n//            if (string.IsNullOrWhiteSpace(templateName))\n//            {\n//                return new SchemaResult\n//                {\n//                    Found = true,\n//                    Headers = new List<string>(),     // do NOT inject \"phone\" here\n//                    PlaceholderCount = 0,\n//                    HeaderType = \"none\",\n//                    HeaderNeedsUrl = false\n//                };\n//            }\n\n//            var provider = (campaign.Provider ?? \"META_CLOUD\").ToUpperInvariant();\n\n//            // 1) Normalized meta from your template service\n//            var meta = await _tpl.GetTemplateMetaAsync(\n//                campaign.BusinessId,\n//                templateName,\n//                language: null,\n//                provider: provider\n//            );\n\n//            // 2) Fallback to raw WhatsAppTemplates row\n//            var tplRow = await _db.WhatsAppTemplates\n//                .AsNoTracking()\n//                .Where(w => w.BusinessId == businessId\n//                         && w.IsActive\n//                         && w.Name == templateName\n//                         && w.Provider == provider)\n//                .OrderByDescending(w => w.UpdatedAt > w.CreatedAt ? w.UpdatedAt : w.CreatedAt)\n//                .FirstOrDefaultAsync(ct);\n\n//            var headers = new List<string>(); // <- per-row CSV columns only (NO \"phone\", NO media URL constant)\n\n//            // ---------------- BODY placeholders ----------------\n//            int bodyCount = 0;\n\n//            if (meta?.BodyPlaceholders is { Count: > 0 })\n//            {\n//                bodyCount = meta.BodyPlaceholders.Count;\n//            }\n//            else if (tplRow?.PlaceholderCount is int pc && pc > 0)\n//            {\n//                bodyCount = pc;\n//            }\n//            else\n//            {\n//                // Last resort: parse {{n}} from a 'Body' text if present\n//                var bodyText = meta?.GetType().GetProperty(\"Body\")?.GetValue(meta) as string;\n//                if (!string.IsNullOrWhiteSpace(bodyText))\n//                {\n//                    var m = Regex.Matches(bodyText, @\"\\{\\{\\s*(\\d+)\\s*\\}\\}\");\n//                    if (m.Count > 0)\n//                        bodyCount = m.Select(x => int.Parse(x.Groups[1].Value)).DefaultIfEmpty(0).Max();\n//                }\n//            }\n//            for (int i = 1; i <= bodyCount; i++) headers.Add($\"body.{i}\");\n\n//            // ---------------- HEADER type + header text placeholders ----------------\n//            // Normalize header type\n//            string headerTypeNorm = (meta?.HeaderType ?? \"\").Trim().ToUpperInvariant();\n//            if (string.IsNullOrEmpty(headerTypeNorm) && tplRow?.HasImageHeader == true)\n//                headerTypeNorm = \"IMAGE\"; // legacy fallback\n\n//            // Map to response type + needsUrl\n//            string respHeaderType = \"none\";\n//            bool needsUrl = false;\n\n//            switch (headerTypeNorm)\n//            {\n//                case \"IMAGE\":\n//                    respHeaderType = \"image\";\n//                    needsUrl = true;\n//                    break;\n//                case \"VIDEO\":\n//                    respHeaderType = \"video\";\n//                    needsUrl = true;\n//                    break;\n//                case \"DOCUMENT\":\n//                case \"PDF\":\n//                    respHeaderType = \"document\";\n//                    needsUrl = true;\n//                    break;\n//                case \"TEXT\":\n//                    respHeaderType = \"text\";\n//                    needsUrl = false;\n//                    break;\n//                default:\n//                    respHeaderType = \"none\";\n//                    needsUrl = false;\n//                    break;\n//            }\n\n//            // If header is TEXT, include its own placeholders as header.1, header.2, ...\n//            if (respHeaderType == \"text\")\n//            {\n//                int headerVarCount = 0;\n\n//                // Prefer an explicit placeholder list if your meta has it\n//                var headerPlaceholdersProp = meta?.GetType().GetProperty(\"HeaderPlaceholders\");\n//                if (headerPlaceholdersProp?.GetValue(meta) is IEnumerable<object> hpEnum)\n//                {\n//                    headerVarCount = hpEnum.Cast<object>().Count();\n//                }\n//                else\n//                {\n//                    // Fallback: parse {{n}} from header text\n//                    var headerText =\n//                        meta?.GetType().GetProperty(\"Header\")?.GetValue(meta) as string ??\n//                        meta?.GetType().GetProperty(\"HeaderText\")?.GetValue(meta) as string ??\n//                        string.Empty;\n\n//                    if (!string.IsNullOrWhiteSpace(headerText))\n//                    {\n//                        var m = Regex.Matches(headerText, @\"\\{\\{\\s*(\\d+)\\s*\\}\\}\");\n//                        if (m.Count > 0)\n//                            headerVarCount = m.Select(x => int.Parse(x.Groups[1].Value)).DefaultIfEmpty(0).Max();\n//                    }\n//                }\n\n//                for (int i = 1; i <= headerVarCount; i++)\n//                    headers.Add($\"header.{i}\");\n//            }\n\n//            // ---------------- DYNAMIC URL BUTTONS -> button{i}.url_param ----------------\n//            bool LooksDynamic(string? val) => !string.IsNullOrEmpty(val) && val.Contains(\"{{\");\n\n//            bool IsUrlish(string? type, string? subType)\n//            {\n//                type = (type ?? \"\").ToLowerInvariant();\n//                subType = (subType ?? \"\").ToLowerInvariant();\n//                return type == \"url\" || subType == \"url\";\n//            }\n\n//            int GetPos(object b, int fallbackOneBased)\n//            {\n//                var t = b.GetType();\n//                if (t.GetProperty(\"Index\")?.GetValue(b) is int idx && idx > 0) return idx;\n//                if (t.GetProperty(\"Order\")?.GetValue(b) is int ord && ord >= 0) return ord + 1;\n//                if (t.GetProperty(\"Position\")?.GetValue(b) is int pos && pos > 0) return pos;\n//                return fallbackOneBased;\n//            }\n\n//            var positions = new SortedSet<int>();\n\n//            // A) meta.Buttons (normalized)\n//            if (meta?.Buttons is { Count: > 0 })\n//            {\n//                var urlBtns = meta.Buttons\n//                    .Where(b => IsUrlish(b.GetType().GetProperty(\"Type\")?.GetValue(b) as string,\n//                                         b.GetType().GetProperty(\"SubType\")?.GetValue(b) as string))\n//                    .ToList();\n\n//                for (int i = 0; i < urlBtns.Count && positions.Count < 3; i++)\n//                {\n//                    var b = urlBtns[i];\n//                    var val = b.GetType().GetProperty(\"Value\")?.GetValue(b) as string;\n//                    var subType = b.GetType().GetProperty(\"SubType\")?.GetValue(b) as string;\n//                    var urlType = b.GetType().GetProperty(\"UrlType\")?.GetValue(b) as string;\n//                    var hasPh = b.GetType().GetProperty(\"HasPlaceholder\")?.GetValue(b) as bool?;\n\n//                    var dynamicByProps =\n//                        LooksDynamic(val) ||\n//                        string.Equals(subType, \"DYNAMIC\", StringComparison.OrdinalIgnoreCase) ||\n//                        string.Equals(urlType, \"DYNAMIC\", StringComparison.OrdinalIgnoreCase) ||\n//                        hasPh == true;\n\n//                    if (dynamicByProps)\n//                    {\n//                        var pos = GetPos(b, i + 1);\n//                        if (pos >= 1 && pos <= 3) positions.Add(pos);\n//                    }\n//                }\n//            }\n\n//            // B) raw ButtonsJson fallback (from DB row)\n//            if (positions.Count < 3 && !string.IsNullOrWhiteSpace(tplRow?.ButtonsJson))\n//            {\n//                try\n//                {\n//                    var root = System.Text.Json.JsonDocument.Parse(tplRow.ButtonsJson).RootElement;\n//                    if (root.ValueKind == System.Text.Json.JsonValueKind.Array)\n//                    {\n//                        foreach (var el in root.EnumerateArray())\n//                        {\n//                            if (positions.Count >= 3) break;\n\n//                            var type = el.TryGetProperty(\"type\", out var tkn) ? tkn.GetString() : null;\n//                            if (!IsUrlish(type, null)) continue;\n\n//                            int pos = 0;\n//                            if (el.TryGetProperty(\"index\", out var iTok) && iTok.TryGetInt32(out var idx) && idx > 0) pos = idx;\n//                            else if (el.TryGetProperty(\"order\", out var oTok) && oTok.TryGetInt32(out var ord) && ord >= 0) pos = ord + 1;\n\n//                            string? value = null;\n//                            if (el.TryGetProperty(\"value\", out var vTok) && vTok.ValueKind == System.Text.Json.JsonValueKind.String)\n//                                value = vTok.GetString();\n\n//                            bool hasParam = false;\n//                            if (el.TryGetProperty(\"parameters\", out var pTok) && pTok.ValueKind == System.Text.Json.JsonValueKind.Array)\n//                            {\n//                                foreach (var p in pTok.EnumerateArray())\n//                                {\n//                                    if (p.TryGetProperty(\"text\", out var txt) && txt.ValueKind == System.Text.Json.JsonValueKind.String)\n//                                    {\n//                                        var s = txt.GetString();\n//                                        if (!string.IsNullOrEmpty(s) && s.Contains(\"{{\")) { hasParam = true; break; }\n//                                    }\n//                                }\n//                            }\n\n//                            if (LooksDynamic(value) || hasParam)\n//                            {\n//                                if (pos <= 0) pos = positions.Count + 1;\n//                                if (pos >= 1 && pos <= 3) positions.Add(pos);\n//                            }\n//                        }\n//                    }\n//                }\n//                catch { /* ignore bad JSON */ }\n//            }\n\n//            foreach (var pos in positions)\n//            {\n//                var key = $\"button{pos}.url_param\";\n//                if (!headers.Contains(key, StringComparer.OrdinalIgnoreCase))\n//                    headers.Add(key);\n//            }\n\n//            // DONE\n//            return new SchemaResult\n//            {\n//                Found = true,\n//                Headers = headers,\n//                PlaceholderCount = bodyCount,\n//                HeaderType = respHeaderType,\n//                HeaderNeedsUrl = needsUrl\n//            };\n//        }\n\n\n\n\n\n//        [HttpGet]\n//        // [HttpGet(\"download-sample/{campaignId:guid}\")]\n//        public async Task<IActionResult> Download(Guid campaignId, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized();\n\n//            var schema = await BuildSchemaAsync(businessId, campaignId, ct);\n//            if (!schema.Found) return NotFound();\n\n//            // First row only: the header names the FE expects to see\n//            var sb = new StringBuilder();\n//            sb.AppendLine(string.Join(\",\", schema.Headers.Select(h =>\n//                h.Contains(',') ? $\"\\\"{h.Replace(\"\\\"\", \"\\\"\\\"\")}\\\"\" : h)));\n\n//            var bytes = Encoding.UTF8.GetBytes(sb.ToString());\n//            var fileName = $\"sample_{campaignId:N}.csv\";\n//            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n//        }\n\n//        // -----------------------\n//        // Helpers\n//        // -----------------------\n\n\n\n//        //private async Task<SchemaResult> BuildSchemaAsync(Guid businessId, Guid campaignId, CancellationToken ct)\n//        //{\n//        //    var campaign = await _db.Campaigns\n//        //        .AsNoTracking()\n//        //        .Where(c => c.Id == campaignId && c.BusinessId == businessId && !c.IsDeleted)\n//        //        .Select(c => new\n//        //        {\n//        //            c.Id,\n//        //            c.BusinessId,\n//        //            c.TemplateId,\n//        //            c.MessageTemplate,\n//        //            c.Provider\n//        //        })\n//        //        .FirstOrDefaultAsync(ct);\n\n//        //    if (campaign == null)\n//        //        return new SchemaResult { Found = false };\n\n//        //    var templateName =\n//        //        !string.IsNullOrWhiteSpace(campaign.TemplateId) ? campaign.TemplateId! :\n//        //        !string.IsNullOrWhiteSpace(campaign.MessageTemplate) ? campaign.MessageTemplate! :\n//        //        string.Empty;\n\n//        //    if (string.IsNullOrWhiteSpace(templateName))\n//        //        return new SchemaResult { Found = true, Headers = new List<string> { \"phone\" }, PlaceholderCount = 0 };\n\n//        //    var provider = (campaign.Provider ?? \"META\").ToUpperInvariant();\n\n//        //    // 1) Normalized meta (may be sparse on some branches)\n//        //    var meta = await _tpl.GetTemplateMetaAsync(\n//        //        campaign.BusinessId,\n//        //        templateName,\n//        //        language: null,\n//        //        provider: provider\n//        //    );\n\n//        //    // 2) Raw DB row fallback (has ButtonsJson / HasImageHeader / PlaceholderCount)\n//        //    var tplRow = await _db.WhatsAppTemplates\n//        //        .AsNoTracking()\n//        //        .Where(w => w.BusinessId == businessId\n//        //                    && w.IsActive\n//        //                    && w.Name == templateName\n//        //                    && w.Provider == provider)\n//        //        .OrderByDescending(w => (w.UpdatedAt > w.CreatedAt ? w.UpdatedAt : w.CreatedAt))\n//        //        .FirstOrDefaultAsync(ct);\n\n//        //    var headers = new List<string> { \"phone\" };\n//        //    int bodyCount = 0;\n\n//        //    // ---------- BODY PLACEHOLDERS ----------\n//        //    if (meta?.BodyPlaceholders != null && meta.BodyPlaceholders.Count > 0)\n//        //    {\n//        //        bodyCount = meta.BodyPlaceholders.Count;\n//        //    }\n//        //    else if (tplRow?.PlaceholderCount is int pc && pc > 0)\n//        //    {\n//        //        bodyCount = pc;\n//        //    }\n//        //    else\n//        //    {\n//        //        // try to infer from body text if available in meta\n//        //        var bodyText = meta?.GetType()?.GetProperty(\"Body\")?.GetValue(meta) as string;\n//        //        if (!string.IsNullOrWhiteSpace(bodyText))\n//        //        {\n//        //            var m = System.Text.RegularExpressions.Regex.Matches(bodyText, @\"\\{\\{\\s*(\\d+)\\s*\\}\\}\");\n//        //            if (m.Count > 0)\n//        //                bodyCount = m.Select(x => int.Parse(x.Groups[1].Value)).DefaultIfEmpty(0).Max();\n//        //        }\n//        //    }\n//        //    for (int i = 1; i <= bodyCount; i++)\n//        //        headers.Add($\"body.{i}\");\n\n//        //    // ---------- HEADER MEDIA ----------\n//        //    string headerType = (meta?.HeaderType ?? string.Empty).ToUpperInvariant();\n//        //    if (string.IsNullOrEmpty(headerType))\n//        //    {\n//        //        // legacy bool\n//        //        var hasImg = meta?.GetType()?.GetProperty(\"HasHeaderMedia\")?.GetValue(meta) as bool?\n//        //                     ?? meta?.GetType()?.GetProperty(\"HasImageHeader\")?.GetValue(meta) as bool?;\n//        //        if (hasImg == true) headerType = \"IMAGE\";\n//        //        // row fallback?\n//        //        if (string.IsNullOrEmpty(headerType) && tplRow?.HasImageHeader == true) headerType = \"IMAGE\";\n//        //    }\n\n//        //    if (headerType == \"IMAGE\") headers.Add(\"header.image_url\");\n//        //    if (headerType == \"VIDEO\") headers.Add(\"header.video_url\");\n//        //    if (headerType == \"DOCUMENT\" || headerType == \"PDF\") headers.Add(\"header.document_url\");\n\n//        //    // ---------- DYNAMIC URL BUTTONS ----------\n//        //    // Match FE logic: a button needs a CSV value if:\n//        //    //  - it's a URL-like button (type/subType says url) AND\n//        //    //  - the URL contains a {{…}} placeholder OR parameters array contains a {{…}} text\n//        //    var dynamicPositions = new SortedSet<int>();\n\n//        //    bool LooksDynamic(string? val) =>\n//        //    !string.IsNullOrEmpty(val) && val.Contains(\"{{\", StringComparison.Ordinal);\n\n//        //    bool IsUrlish(string? type, string? subType)\n//        //    {\n//        //        type = (type ?? string.Empty).ToLowerInvariant();\n//        //        subType = (subType ?? string.Empty).ToLowerInvariant();\n//        //        return type == \"url\" || subType == \"url\";\n//        //    }\n\n\n//        //    int GetPos(object b, int fallbackOneBased)\n//        //    {\n//        //        var t = b.GetType();\n//        //        if (t.GetProperty(\"Index\")?.GetValue(b) is int idx && idx > 0) return idx;\n//        //        if (t.GetProperty(\"Order\")?.GetValue(b) is int ord && ord >= 0) return ord + 1;\n//        //        if (t.GetProperty(\"Position\")?.GetValue(b) is int pos && pos > 0) return pos;\n//        //        return fallbackOneBased;\n//        //    }\n\n//        //    // A) meta.Buttons\n//        //    if (meta?.Buttons != null && meta.Buttons.Count > 0)\n//        //    {\n//        //        for (int i = 0; i < meta.Buttons.Count && dynamicPositions.Count < 3; i++)\n//        //        {\n//        //            var b = meta.Buttons[i];\n//        //            var type = b.Type;\n//        //            var subType = b.GetType().GetProperty(\"SubType\")?.GetValue(b) as string; // if present\n//        //            var value = b.Value;\n\n//        //            if (IsUrlish(type, subType) && LooksDynamic(value))\n//        //            {\n//        //                var pos = GetPos(b, i + 1);\n//        //                if (pos >= 1 && pos <= 3) dynamicPositions.Add(pos);\n//        //            }\n//        //        }\n//        //    }\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchController.cs",
      "sha256": "10a3d3b319ca0133677bf5c5a4574cefc68fc164ddc1ceb4d65bf1ee11ebe84e",
      "language": "csharp",
      "size": 1904,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch\")]\n    [Authorize]\n    public class CampaignDispatchController : ControllerBase\n    {\n        private readonly ICampaignDispatcher _dispatcher;\n\n        public CampaignDispatchController(ICampaignDispatcher dispatcher)\n        {\n            _dispatcher = dispatcher;\n        }\n\n        /// <summary>\n        /// Dispatch materialized recipients to the outbound queue.\n        /// Query: mode=canary|full, count=25 (used when mode=canary).\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<CampaignDispatchResponseDto>> Dispatch(\n            [FromRoute] Guid campaignId,\n            [FromQuery] string mode = \"canary\",\n            [FromQuery] int count = 25,\n            CancellationToken ct = default)\n        {\n            try\n            {\n                var businessId = ResolveBusinessId();\n                var resp = await _dispatcher.DispatchAsync(businessId, campaignId, mode, count, ct);\n                return Ok(resp);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Dispatch failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"Dispatch failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        private Guid ResolveBusinessId()\n        {\n            var bidStr = User.FindFirst(\"BusinessId\")?.Value\n                         ?? Request.Headers[\"X-Business-Id\"].ToString();\n            return Guid.TryParse(bidStr, out var bid) ? bid : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchPlanController.cs",
      "sha256": "fa1771645ec3aa53f0c0b793831c1a0f3bd6667a876b07d2c0494eaca0a72152",
      "language": "csharp",
      "size": 1271,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch-plan\")]\n    [Authorize]\n    public class CampaignDispatchPlanController : ControllerBase\n    {\n        private readonly ICampaignDispatchPlannerService _planner;\n\n        public CampaignDispatchPlanController(ICampaignDispatchPlannerService planner)\n        {\n            _planner = planner;\n        }\n\n        /// <summary>\n        /// Returns a read-only dispatch plan: batches, offsets, and throttle summary.\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 2000, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Dispatch plan requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var data = await _planner.PlanAsync(businessId, campaignId, limit, ct);\n            return Ok(new { success = true, data });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDispatchPlanExportController.cs",
      "sha256": "99c81c3dcba5bf94c119c5e35543288d8a87e691eb1f55fe071d9fee7eec30f5",
      "language": "csharp",
      "size": 1332,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/dispatch-plan.csv\")]\n    [Authorize]\n    public class CampaignDispatchPlanExportController : ControllerBase\n    {\n        private readonly ICsvExportService _csv;\n\n        public CampaignDispatchPlanExportController(ICsvExportService csv)\n        {\n            _csv = csv;\n        }\n\n        /// <summary>\n        /// Streams a CSV of the dispatch plan (batches, offsets, recipients).\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 2000, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Dispatch Plan CSV requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var bytes = await _csv.BuildDispatchPlanCsvAsync(businessId, campaignId, limit, ct);\n            var fileName = $\"dispatch_plan_{campaignId:N}.csv\";\n            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignDryRunController.cs",
      "sha256": "578d68a41c396cb59025d014be7fa8a9c8776b15be6d7e098e8b5a3511502eb0",
      "language": "csharp",
      "size": 1127,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns\")]\n    [Authorize]\n    public sealed class CampaignDryRunController : ControllerBase\n    {\n        private readonly ICampaignService _campaigns;\n        public CampaignDryRunController(ICampaignService campaigns) => _campaigns = campaigns;\n\n        // GET /api/campaigns/{campaignId}/dry-run?limit=20\n        [HttpGet(\"{campaignId:guid}/dry-run\")]\n        public async Task<IActionResult> DryRun([FromRoute] Guid campaignId, [FromQuery] int limit = 20)\n        {\n            if (campaignId == Guid.Empty) return BadRequest(new { message = \"Invalid campaignId\" });\n            if (limit <= 0) limit = 20;\n            if (limit > 200) limit = 200; // guardrails\n\n            var resp = await _campaigns.DryRunTemplateCampaignAsync(campaignId, limit);\n            return Ok(resp);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMappingsController.cs",
      "sha256": "e4aa5327bae9ff9f05b0388d401b2855e319d128d59889ebd9b8c165dba29616",
      "language": "csharp",
      "size": 3321,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/mappings\")]\n    [Authorize] // adjust to your auth\n    public sealed class CampaignMappingsController : ControllerBase\n    {\n        private readonly IVariableMappingService _svc;\n        private readonly IMappingSuggestionService _suggest;\n\n        public CampaignMappingsController(IVariableMappingService svc, IMappingSuggestionService suggest)\n        {\n            _svc = svc;\n            _suggest = suggest;\n        }\n\n        /// <summary>\n        /// Returns saved variable mappings for a campaign.\n        /// Shape: dictionary of token -> source (e.g., \"first_name\" -> \"csv:First Name\")\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> GetAsync(\n            [FromRoute] Guid campaignId,\n            CancellationToken ct = default)\n        {\n            var businessId = GetBusinessIdOrThrow();\n            var map = await _svc.GetForCampaignAsync(businessId, campaignId, ct);\n            return Ok(map ?? new System.Collections.Generic.Dictionary<string, string>());\n        }\n\n        /// <summary>\n        /// Saves variable mappings for a campaign.\n        /// Body: { \"tokenA\": \"csv:HeaderA\", \"tokenB\": \"static:Hello\", ... }\n        /// </summary>\n        [HttpPost]\n        public async Task<IActionResult> SaveAsync(\n            [FromRoute] Guid campaignId,\n            [FromBody] System.Collections.Generic.Dictionary<string, string> mappings,\n            CancellationToken ct = default)\n        {\n            if (mappings is null)\n                return BadRequest(\"Body cannot be null; send a mapping dictionary.\");\n\n            var businessId = GetBusinessIdOrThrow();\n            await _svc.SaveAsync(businessId, campaignId, mappings, ct);\n            return NoContent();\n        }\n\n        /// <summary>\n        /// Suggest default mappings from CSV headers and campaign tokens.\n        /// GET /api/campaigns/{campaignId}/mappings/suggest?batchId=...\n        /// </summary>\n        [HttpGet(\"suggest\")]\n        public async Task<IActionResult> SuggestAsync(\n            [FromRoute] Guid campaignId,\n            [FromQuery] Guid batchId,\n            CancellationToken ct = default)\n        {\n            if (batchId == Guid.Empty)\n                return BadRequest(\"batchId is required.\");\n\n            var businessId = GetBusinessIdOrThrow();\n            var map = await _suggest.SuggestAsync(businessId, campaignId, batchId, ct);\n            return Ok(map);\n        }\n\n        // -- helpers --\n\n        private Guid GetBusinessIdOrThrow()\n        {\n            string? raw =\n                User?.FindFirst(\"business_id\")?.Value ??\n                User?.FindFirst(\"BusinessId\")?.Value ??\n                Request.Headers[\"X-Business-Id\"].FirstOrDefault();\n\n            if (!Guid.TryParse(raw, out var id))\n                throw new UnauthorizedAccessException(\n                    \"Business context missing. Pass X-Business-Id header or ensure the business_id claim is present.\");\n\n            return id;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializationController.cs",
      "sha256": "ba44f1458a39c736281ecc8dbed383fac7a646d34853127258aff6364bcf25d7",
      "language": "csharp",
      "size": 1417,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize\")]\n    [Authorize]\n    public class CampaignMaterializationController : ControllerBase\n    {\n        private readonly ICampaignMaterializationService _materializer;\n\n        public CampaignMaterializationController(ICampaignMaterializationService materializer)\n        {\n            _materializer = materializer;\n        }\n\n        /// <summary>\n        /// Returns a page (limit) of fully materialized recipients: placeholder values and resolved button URLs.\n        /// No send, read-only.\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 200, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Materialize GET requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var data = await _materializer.MaterializeAsync(businessId, campaignId, limit, ct);\n            return Ok(new { success = true, data });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializationExportController.cs",
      "sha256": "1b18901d4ea990ce054a6dbb6d28e9e86341034ba56f73c92987ba2a015d8aba",
      "language": "csharp",
      "size": 1330,
      "content": "using System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize.csv\")]\n    [Authorize]\n    public class CampaignMaterializationExportController : ControllerBase\n    {\n        private readonly ICsvExportService _csv;\n\n        public CampaignMaterializationExportController(ICsvExportService csv)\n        {\n            _csv = csv;\n        }\n\n        /// <summary>\n        /// Streams a CSV of materialized recipients (params + button URLs).\n        /// </summary>\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId, [FromQuery] int limit = 200, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            Log.Information(\"Materialize CSV requested {@Ctx}\", new { businessId, campaignId, limit });\n\n            var bytes = await _csv.BuildMaterializedCsvAsync(businessId, campaignId, limit, ct);\n            var fileName = $\"materialized_{campaignId:N}.csv\";\n            return File(bytes, \"text/csv; charset=utf-8\", fileName);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignMaterializeController.cs",
      "sha256": "b33ba1d9af212e9a0085afb4690075cb7a604acfff240d0f281e30c5fd261c49",
      "language": "csharp",
      "size": 3621,
      "content": "// File: Features/CampaignModule/Controllers/CampaignMaterializeController.cs\nusing System;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/materialize\")]\n    [Authorize]\n    public class CampaignMaterializeController : ControllerBase\n    {\n        private readonly ICampaignMaterializer _csvMaterializer;\n        private readonly ICampaignMaterializationService _recipientPreview;\n\n        public CampaignMaterializeController(\n            ICampaignMaterializer csvMaterializer,\n            ICampaignMaterializationService recipientPreview)\n        {\n            _csvMaterializer = csvMaterializer;\n            _recipientPreview = recipientPreview;\n        }\n\n        /// <summary>\n        /// CSV-based materialization. Use Persist=false for dry-run preview; Persist=true to commit Audience + Recipients.\n        /// </summary>\n        [HttpPost]\n        public async Task<ActionResult<CampaignCsvMaterializeResponseDto>> CsvCreate(\n            [FromRoute] Guid campaignId,\n            [FromBody] CampaignCsvMaterializeRequestDto dto,\n            CancellationToken ct)\n        {\n            try\n            {\n                if (dto is null) return BadRequest(\"Body required.\");\n\n                var businessId = ResolveBusinessId();\n                Log.Information(\"📦 Materialize request: campaign={CampaignId} persist={Persist} batch={BatchId} audience='{Audience}'\",\n                    campaignId, dto.Persist, dto.CsvBatchId, dto.AudienceName);\n\n                var result = await _csvMaterializer.CreateAsync(businessId, campaignId, dto, ct);\n\n                Log.Information(\"📦 Materialize result: campaign={CampaignId} materialized={Count} skipped={Skipped} audienceId={AudienceId}\",\n                    campaignId, result.MaterializedCount, result.SkippedCount, result.AudienceId);\n\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"CSV materialize failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"CSV materialize failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        /// <summary>\n        /// Recipient-based preview (read-only), using existing recipients + contacts.\n        /// </summary>\n        [HttpGet(\"recipients\")]\n        public async Task<ActionResult<CampaignMaterializeResultDto>> RecipientPreview(\n            [FromRoute] Guid campaignId,\n            [FromQuery] int limit = 200,\n            CancellationToken ct = default)\n        {\n            try\n            {\n                var businessId = ResolveBusinessId();\n                var result = await _recipientPreview.MaterializeAsync(businessId, campaignId, limit, ct);\n                return Ok(result);\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Recipient preview failed for Campaign {CampaignId}\", campaignId);\n                return Problem(title: \"Recipient preview failed\", detail: ex.Message, statusCode: 400);\n            }\n        }\n\n        private Guid ResolveBusinessId()\n        {\n            var bidStr = User.FindFirst(\"BusinessId\")?.Value\n                         ?? Request.Headers[\"X-Business-Id\"].ToString();\n            return Guid.TryParse(bidStr, out var bid) ? bid : Guid.Empty;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignPreviewController.cs",
      "sha256": "0f88ad7bec9bc43c01918eaa6fe58c499f1926fecc2a7e9430ae6d99cc47cf36",
      "language": "csharp",
      "size": 1384,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/preview\")]\n    [Authorize]\n    public class CampaignPreviewController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignPreviewService _preview;\n\n        public CampaignPreviewController(AppDbContext db, ICampaignPreviewService preview)\n        {\n            _db = db; _preview = preview;\n        }\n\n        [HttpPost]\n        public async Task<ActionResult<CampaignPreviewResponseDto>> Preview(Guid campaignId, [FromBody] CampaignPreviewRequestDto req)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var data = await _preview.PreviewAsync(businessId, campaignId, req?.ContactId);\n            return Ok(data);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignRecipientController.cs",
      "sha256": "247e52ea9259e04d5bc4fb6e22d3aa4791b77af05431022b0572a837bbf7e326",
      "language": "csharp",
      "size": 3341,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/[controller]\")]\n    public class CampaignRecipientController : ControllerBase\n    {\n        private readonly ICampaignRecipientService _recipientService;\n\n        public CampaignRecipientController(ICampaignRecipientService recipientService)\n        {\n            _recipientService = recipientService;\n        }\n\n        // ✅ Get a single recipient by ID\n        [HttpGet(\"{id}\")]\n        public async Task<ActionResult<CampaignRecipientDto>> GetRecipientById(Guid id)\n        {\n            var recipient = await _recipientService.GetByIdAsync(id);\n            if (recipient == null)\n                return NotFound(new { message = \"Recipient not found\" });\n\n            return Ok(recipient);\n        }\n\n        // ✅ Get all recipients for a specific campaign\n        [HttpGet(\"/api/campaigns/{campaignId}/recipients\")]\n        public async Task<ActionResult> GetRecipientsForCampaign(Guid campaignId)\n        {\n            var recipients = await _recipientService.GetByCampaignIdAsync(campaignId);\n            return Ok(recipients);\n        }\n\n        // ✅ Update recipient status (e.g., from Pending → Sent)\n        [HttpPut(\"{recipientId}/status\")]\n        public async Task<ActionResult> UpdateStatus(Guid recipientId, [FromQuery] string newStatus)\n        {\n            var success = await _recipientService.UpdateStatusAsync(recipientId, newStatus);\n            if (!success)\n                return NotFound(new { message = \"Recipient not found or update failed\" });\n\n            return Ok(new { message = \"Status updated\" });\n        }\n\n        // ✅ Track a reply from customer\n        [HttpPut(\"{recipientId}/reply\")]\n        public async Task<ActionResult> TrackReply(Guid recipientId, [FromQuery] string replyText)\n        {\n            var success = await _recipientService.TrackReplyAsync(recipientId, replyText);\n            if (!success)\n                return NotFound(new { message = \"Recipient not found or tracking failed\" });\n\n            return Ok(new { message = \"Reply tracked\" });\n        }\n\n        // 🔍 Search recipients by optional filters (status, keyword)\n        [HttpGet(\"search\")]\n        public async Task<ActionResult<List<CampaignRecipientDto>>> SearchRecipients([FromQuery] string? status, [FromQuery] string? keyword)\n        {\n            var results = await _recipientService.SearchRecipientsAsync(status, keyword);\n            return Ok(results);\n        }\n\n        [HttpPost(\"{id}/assign-contacts\")]\n        public async Task<IActionResult> AssignContacts(Guid id, [FromBody] AssignContactsDto dto)\n        {\n            try\n            {\n                await _recipientService.AssignContactsToCampaignAsync(id, dto.ContactIds);\n                return Ok(new { message = \"Contacts assigned successfully\" });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error assigning contacts to campaign\");\n                return StatusCode(500, new { message = \"Failed to assign contacts\" });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignRetryController.cs",
      "sha256": "ca2204f071f6a85505d1550007e2bb2fa0ea7c35a4d13542b1ed9727751b1b9f",
      "language": "csharp",
      "size": 1424,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns\")]\n    [Authorize]\n    public sealed class CampaignRetryController : ControllerBase\n    {\n        private readonly Services.ICampaignRetryService _retry;\n\n        public CampaignRetryController(Services.ICampaignRetryService retry)\n        {\n            _retry = retry;\n        }\n\n        // POST /api/campaigns/{campaignId}/retry-failed?limit=200\n        [HttpPost(\"{campaignId:guid}/retry-failed\")]\n        public async Task<IActionResult> RetryFailed([FromRoute] Guid campaignId, [FromQuery] int limit = 200)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(new { success = false, error = \"Invalid business context.\" });\n\n            try\n            {\n                var data = await _retry.RetryFailedAsync(businessId, campaignId, limit);\n                return Ok(new { success = true, data });\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"RetryFailed error for Campaign {CampaignId}\", campaignId);\n                return BadRequest(new { success = false, error = ex.Message });\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CampaignVariableMapController.cs",
      "sha256": "882eb072e75759c98b2257f09ada75c7721d73996978f7d35a4ce3721ee13767",
      "language": "csharp",
      "size": 1942,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/variables\")]\n    [Authorize]\n    public class CampaignVariableMapController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignVariableMapService _svc;\n\n        public CampaignVariableMapController(AppDbContext db, ICampaignVariableMapService svc)\n        { _db = db; _svc = svc; }\n\n        [HttpGet]\n        public async Task<IActionResult> Get(Guid campaignId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound(new { success = false, message = \"Campaign not found\" });\n\n            var data = await _svc.GetAsync(businessId, campaignId);\n            return Ok(new { success = true, data });\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Save(Guid campaignId, [FromBody] CampaignVariableMapDto body)\n        {\n            var businessId = User.GetBusinessId();\n            var userName = User.Identity?.Name ?? \"system\";\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            if (body == null) return BadRequest(new { success = false, message = \"Body required\" });\n            body.CampaignId = campaignId;\n\n            var ok = await _svc.SaveAsync(businessId, body, userName);\n            return Ok(new { success = ok });\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/CsvBatchController.cs",
      "sha256": "c0570a7e546e94d11dfba66c342200f26f65b9d289abf5a3f3b26cc34c75d3f6",
      "language": "csharp",
      "size": 14872,
      "content": "using System;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared;   // User.GetBusinessId()\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Features.CampaignModule.DTOs.Requests;  // ResponseResult\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/csv/batch\")]\n    [Authorize]\n    public class CsvBatchController : ControllerBase\n    {\n        private readonly ICsvBatchService _service;\n\n        public CsvBatchController(ICsvBatchService service)\n        {\n            _service = service;\n        }\n\n        /// <summary>Upload a CSV, create a batch, and ingest rows.</summary>\n        [HttpPost]\n        [RequestSizeLimit(1024L * 1024L * 200L)] // 200 MB\n        public async Task<IActionResult> Upload(\n            [FromForm] CsvBatchUploadForm form,\n            CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty)\n                return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            if (form.File is null || form.File.Length == 0)\n                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required\"));\n\n            // soft sanity (many browsers use text/csv; don't block others)\n            var allowed = new[] { \"text/csv\", \"application/vnd.ms-excel\", \"application/octet-stream\" };\n            if (!allowed.Contains(form.File.ContentType, StringComparer.OrdinalIgnoreCase))\n                Log.Warning(\"Unusual CSV content type: {ContentType}\", form.File.ContentType);\n\n            await using var stream = form.File.OpenReadStream();\n\n            var result = await _service.CreateAndIngestAsync(\n                businessId: businessId,\n                fileName: form.File.FileName,\n                stream: stream,\n                audienceId: form.AudienceId,\n                ct: ct);\n\n            return Ok(new { success = true, data = result });\n        }\n\n\n        [HttpGet(\"{batchId:guid}\")]\n        public async Task<IActionResult> Get(Guid batchId, CancellationToken ct)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var result = await _service.GetBatchAsync(businessId, batchId, ct);\n            if (result == null) return NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n            return Ok(new { success = true, data = result });\n        }\n\n        [HttpGet(\"{batchId:guid}/sample\")]\n        public async Task<IActionResult> Sample(Guid batchId, [FromQuery] int take = 20, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var rows = await _service.GetSamplesAsync(businessId, batchId, take, ct);\n            return Ok(new { success = true, data = rows });\n        }\n\n        [HttpGet]\n        public async Task<IActionResult> List([FromQuery] int limit = 20, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var list = await _service.ListBatchesAsync(businessId, limit, ct);\n            return Ok(new { success = true, data = list });\n        }\n\n        [HttpGet(\"{batchId:guid}/rows\")]\n        public async Task<IActionResult> RowsPage(Guid batchId, [FromQuery] int skip = 0, [FromQuery] int take = 50, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var page = await _service.GetRowsPageAsync(businessId, batchId, skip, take, ct);\n            return Ok(new { success = true, data = page });\n        }\n\n        //[HttpPost(\"{batchId:guid}/validate\")]\n        //public async Task<IActionResult> Validate(Guid batchId, [FromBody] CsvBatchValidationRequestDto request, CancellationToken ct = default)\n        //{\n        //    var businessId = User.GetBusinessId();\n        //    if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n        //    var result = await _service.ValidateAsync(businessId, batchId, request, ct);\n        //    return Ok(new { success = true, data = result });\n        //}\n\n        [HttpDelete(\"{batchId:guid}\")]\n        public async Task<IActionResult> Delete(Guid batchId, CancellationToken ct = default)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n            var ok = await _service.DeleteBatchAsync(businessId, batchId, ct);\n            return ok ? Ok(new { success = true }) : NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Http;\n//using Microsoft.AspNetCore.Mvc;\n//using Serilog;\n//using xbytechat.api.Features.CampaignModule.DTOs;\n//using xbytechat.api.Features.CampaignModule.Services;\n//using xbytechat.api.Helpers; // User.GetBusinessId()\n//using xbytechat.api.Shared;  // ResponseResult\n\n//namespace xbytechat.api.Features.CampaignModule.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/csv/batch\")]\n//    [Authorize]\n//    public class CsvBatchController : ControllerBase\n//    {\n//        private readonly ICsvBatchService _service;\n\n//        public CsvBatchController(ICsvBatchService service)\n//        {\n//            _service = service;\n//        }\n\n//        /// <summary>Upload a CSV, create a batch, and ingest rows.</summary>\n//        [HttpPost]\n//        [RequestSizeLimit(1024L * 1024L * 200L)] // 200 MB cap; adjust as needed\n//        public async Task<IActionResult> Upload(\n//            [FromQuery] Guid? audienceId,\n//            [FromForm] IFormFile file,\n//            CancellationToken ct)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty)\n//                return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            if (file is null || file.Length == 0)\n//                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required\"));\n\n//            // soft sanity (many browsers use text/csv; don't block others)\n//            var allowed = new[] { \"text/csv\", \"application/vnd.ms-excel\", \"application/octet-stream\" };\n//            if (!allowed.Contains(file.ContentType, StringComparer.OrdinalIgnoreCase))\n//                Log.Warning(\"Unusual CSV content type: {ContentType}\", file.ContentType);\n\n//            await using var stream = file.OpenReadStream();\n\n//            // All validation (incl. optional audience check) happens inside the service.\n//            var result = await _service.CreateAndIngestAsync(\n//                businessId: businessId,\n//                fileName: file.FileName,\n//                stream: stream,\n//                audienceId: audienceId,\n//                ct: ct);\n\n//            return Ok(new { success = true, data = result });\n//        }\n\n//        /// <summary>Get batch info (headers, counts)</summary>\n//        [HttpGet(\"{batchId:guid}\")]\n//        public async Task<IActionResult> Get(Guid batchId, CancellationToken ct)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var result = await _service.GetBatchAsync(businessId, batchId, ct);\n//            if (result == null) return NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n\n//            return Ok(new { success = true, data = result });\n//        }\n\n//        /// <summary>Get first N sample rows to help build mappings.</summary>\n//        [HttpGet(\"{batchId:guid}/sample\")]\n//        public async Task<IActionResult> Sample(Guid batchId, [FromQuery] int take = 20, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var rows = await _service.GetSamplesAsync(businessId, batchId, take, ct);\n//            return Ok(new { success = true, data = rows });\n//        }\n\n//        // ---------------- NEW endpoints below ----------------\n\n//        /// <summary>List recent CSV batches (default 20, cap 100).</summary>\n//        [HttpGet]\n//        public async Task<IActionResult> List([FromQuery] int limit = 20, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var list = await _service.ListBatchesAsync(businessId, limit, ct);\n//            return Ok(new { success = true, data = list });\n//        }\n\n//        /// <summary>Get a paged slice of rows for a batch.</summary>\n//        [HttpGet(\"{batchId:guid}/rows\")]\n//        public async Task<IActionResult> RowsPage(\n//            Guid batchId,\n//            [FromQuery] int skip = 0,\n//            [FromQuery] int take = 50,\n//            CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var page = await _service.GetRowsPageAsync(businessId, batchId, skip, take, ct);\n//            return Ok(new { success = true, data = page });\n//        }\n\n//        /// <summary>Validate a batch (phone presence, duplicates, missing required headers).</summary>\n//        [HttpPost(\"{batchId:guid}/validate\")]\n//        public async Task<IActionResult> Validate(\n//            Guid batchId,\n//            [FromBody] CsvBatchValidationRequestDto request,\n//            CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var result = await _service.ValidateAsync(businessId, batchId, request, ct);\n//            return Ok(new { success = true, data = result });\n//        }\n\n//        /// <summary>Delete a CSV batch and all its rows (transactional).</summary>\n//        [HttpDelete(\"{batchId:guid}\")]\n//        public async Task<IActionResult> Delete(Guid batchId, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var ok = await _service.DeleteBatchAsync(businessId, batchId, ct);\n//            return ok ? Ok(new { success = true }) : NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n//        }\n//    }\n//}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading;\n//using System.Threading.Tasks;\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.Http;\n//using Microsoft.AspNetCore.Mvc;\n//using Serilog;\n//using xbytechat.api;\n//using xbytechat.api.Features.CampaignModule.DTOs;\n//using xbytechat.api.Features.CampaignModule.Services;\n//using xbytechat.api.Helpers;\n//using xbytechat.api.Shared;\n\n//namespace xbytechat.api.Features.CampaignModule.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/csv/batch\")]\n//    [Authorize]\n//    public class CsvBatchController : ControllerBase\n//    {\n//        private readonly ICsvBatchService _service;\n\n//        public CsvBatchController(ICsvBatchService service)\n//        {\n//            _service = service;\n//        }\n\n//        /// <summary>\n//        /// Upload a CSV, create a batch, and ingest rows.\n//        /// </summary>\n//        [HttpPost]\n//        [RequestSizeLimit(1024L * 1024L * 200L)] // 200 MB cap; adjust as needed\n//        public async Task<IActionResult> Upload([FromQuery] Guid audienceId, IFormFile file, CancellationToken ct)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            if (audienceId == Guid.Empty)\n//                return BadRequest(ResponseResult.ErrorInfo(\"audienceId is required\"));\n\n//            if (file == null || file.Length == 0)\n//                return BadRequest(ResponseResult.ErrorInfo(\"CSV file is required\"));\n\n//            // quick mime sanity (optional, many browsers send text/csv)\n//            var allowed = new[] { \"text/csv\", \"application/vnd.ms-excel\", \"application/octet-stream\" };\n//            if (!allowed.Contains(file.ContentType, StringComparer.OrdinalIgnoreCase))\n//                Log.Warning(\"Unusual CSV content type: {ContentType}\", file.ContentType);\n\n//            using var stream = file.OpenReadStream();\n//            var result = await _service.CreateAndIngestAsync(businessId, audienceId, file.FileName, stream, ct);\n\n//            return Ok(new { success = true, data = result });\n//        }\n\n//        /// <summary>\n//        /// Get batch info (headers, counts)\n//        /// </summary>\n//        [HttpGet(\"{batchId:guid}\")]\n//        public async Task<IActionResult> Get(Guid batchId, CancellationToken ct)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var result = await _service.GetBatchAsync(businessId, batchId, ct);\n//            if (result == null) return NotFound(ResponseResult.ErrorInfo(\"Batch not found\"));\n\n//            return Ok(new { success = true, data = result });\n//        }\n\n//        /// <summary>\n//        /// Get first N sample rows to help build mappings.\n//        /// </summary>\n//        [HttpGet(\"{batchId:guid}/sample\")]\n//        public async Task<IActionResult> Sample(Guid batchId, [FromQuery] int take = 20, CancellationToken ct = default)\n//        {\n//            var businessId = User.GetBusinessId();\n//            if (businessId == Guid.Empty) return Unauthorized(ResponseResult.ErrorInfo(\"Invalid business\"));\n\n//            var rows = await _service.GetSamplesAsync(businessId, batchId, take, ct);\n//            return Ok(new { success = true, data = rows });\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Controllers/OutboundCampaignQueueController.cs",
      "sha256": "b32af6b334cd55462ca38b0506a7d1d5a4961309a1c4d260324faec64efb7c12",
      "language": "csharp",
      "size": 4153,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Features.CampaignModule.Services;\nusing xbytechat.api.Shared; // for User.GetBusinessId()\n\nnamespace xbytechat.api.Features.CampaignModule.Controllers\n{\n    [ApiController]\n    [Route(\"api/campaigns/{campaignId:guid}/queue\")]\n    [Authorize]\n    public class OutboundCampaignQueueController : ControllerBase\n    {\n        private readonly AppDbContext _db;\n        private readonly IOutboundCampaignQueueService _queue;\n\n        public OutboundCampaignQueueController(AppDbContext db, IOutboundCampaignQueueService queue)\n        {\n            _db = db; _queue = queue;\n        }\n\n        // GET: /api/campaigns/{id}/queue/jobs\n        [HttpGet(\"jobs\")]\n        public async Task<ActionResult<IEnumerable<OutboundCampaignJobDto>>> ListJobs(Guid campaignId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // ownership check\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var jobs = await _queue.GetJobsForCampaignAsync(businessId, campaignId);\n            return Ok(jobs.Select(Map));\n        }\n\n        // POST: /api/campaigns/{id}/queue/enqueue?forceDuplicate=false\n        [HttpPost(\"enqueue\")]\n        public async Task<ActionResult<object>> Enqueue(Guid campaignId, [FromQuery] bool forceDuplicate = false)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var exists = await _db.Campaigns.AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n            if (!exists) return NotFound();\n\n            var jobId = await _queue.EnqueueAsync(businessId, campaignId, forceDuplicate);\n            return Ok(new { success = true, jobId });\n        }\n\n        // POST: /api/campaigns/{id}/queue/{jobId}/retry\n        [HttpPost(\"{jobId:guid}/retry\")]\n        public async Task<ActionResult<object>> Retry(Guid campaignId, Guid jobId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            // Optional: ensure job belongs to this campaign & business\n            var job = await _db.OutboundCampaignJobs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(j => j.Id == jobId && j.BusinessId == businessId && j.CampaignId == campaignId);\n\n            if (job == null) return NotFound();\n\n            var ok = await _queue.ForceRetryNowAsync(businessId, jobId);\n            return Ok(new { success = ok });\n        }\n\n        // POST: /api/campaigns/{id}/queue/{jobId}/cancel\n        [HttpPost(\"{jobId:guid}/cancel\")]\n        public async Task<ActionResult<object>> Cancel(Guid campaignId, Guid jobId)\n        {\n            var businessId = User.GetBusinessId();\n            if (businessId == Guid.Empty) return Unauthorized();\n\n            var job = await _db.OutboundCampaignJobs\n                .AsNoTracking()\n                .FirstOrDefaultAsync(j => j.Id == jobId && j.BusinessId == businessId && j.CampaignId == campaignId);\n\n            if (job == null) return NotFound();\n\n            var ok = await _queue.CancelAsync(businessId, jobId);\n            return Ok(new { success = ok });\n        }\n\n        private static OutboundCampaignJobDto Map(OutboundCampaignJob j) => new OutboundCampaignJobDto\n        {\n            Id = j.Id,\n            BusinessId = j.BusinessId,\n            CampaignId = j.CampaignId,\n            Status = j.Status,\n            Attempt = j.Attempt,\n            MaxAttempts = j.MaxAttempts,\n            NextAttemptAt = j.NextAttemptAt,\n            LastError = j.LastError,\n            CreatedAt = j.CreatedAt,\n            UpdatedAt = j.UpdatedAt\n        };\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/AssignContactsDto.cs",
      "sha256": "8f8b9b0da213111f833dd07dd7e5189ccc02984cef1b34deb5b1d93a5d40678e",
      "language": "csharp",
      "size": 156,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class AssignContactsDto\n    {\n        public List<Guid> ContactIds { get; set; }\n    }\n\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignButtonDto.cs",
      "sha256": "21e757f8859c9ea36b40c0d3418d5211cce8a22a26b07b81af62b723f93dc2e5",
      "language": "csharp",
      "size": 379,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignButtonDto\n    {\n        public string ButtonText { get; set; } = string.Empty; // 📍 e.g., \"Buy Now\"\n        public string ButtonType { get; set; } = \"url\";         // 🔘 url | quick_reply | call\n        public string TargetUrl { get; set; } = string.Empty;  // 🌐 or phone/call param\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignButtonParamFromMetaDto.cs",
      "sha256": "d218adbbc4e6418548f3dfe962c8b867fc7f364be490f6533d04fb5c61f17f30",
      "language": "csharp",
      "size": 391,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignButtonParamFromMetaDto\n    {\n        public string Text { get; set; } = string.Empty;\n        public string Type { get; set; } = string.Empty;\n        public string SubType { get; set; } = string.Empty;\n        public string Value { get; set; } = string.Empty;\n        public int Position { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignCreateDto.cs",
      "sha256": "6b6b7b78d42631d7c64b527942ea1452b1d5860ded056d77d24b634d801cd6be",
      "language": "csharp",
      "size": 1881,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.CTAManagement.DTOs;\nusing xbytechat.api.Features.MessagesEngine.DTOs; // Required to reference CTAButtonDto\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignCreateDto\n    {\n        public string Name { get; set; }\n\n        [Column(TypeName = \"text\")]\n        public string MessageTemplate { get; set; }\n\n        public string? TemplateId { get; set; } // ✅ Optional Meta template ID\n\n        public string? FollowUpTemplateId { get; set; } // 🔁 Auto-reply template after interest\n\n        public string? CampaignType { get; set; } //= \"template\"; // \"text\", \"template\", \"cta\"\n\n        public Guid? CtaId { get; set; } // 🔘 For legacy CTA support (optional)\n\n        public Guid? CTAFlowConfigId { get; set; }\n        public List<CampaignButtonDto> MultiButtons { get; set; } = new(); // ✅ New multi-button support\n        public DateTime? ScheduledAt { get; set; } // 📅 Optional future scheduling\n\n        //public List<Guid>? ContactIds { get; set; } // 👥 Target contact list\n\n        public string? ImageUrl { get; set; } // 🖼️ Optional image field\n\n        public string? ImageCaption { get; set; } // 📝 Optional caption\n\n        public List<Guid> ContactIds { get; set; } = new();\n\n        public List<string>? TemplateParameters { get; set; }\n        public List<CampaignButtonParamFromMetaDto>? ButtonParams { get; set; }\n\n        // Sender fields (REQUIRED for reliability)\n        public string Provider { get; set; }            // \"PINNACLE\" | \"META_CLOUD\" (UPPERCASE)\n        public string PhoneNumberId { get; set; }\n\n        public string? HeaderKind { get; set; }        // \"image\" | \"video\" | \"document\" | \"text\" | \"none\"\n        public string? HeaderMediaUrl { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignCsvMaterializeDtos.cs",
      "sha256": "56c8084a7a0a181e779d3ad774edd588567949c55bcca324c7614b3c7528098c",
      "language": "csharp",
      "size": 1503,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignCsvMaterializeRequestDto\n    {\n        [Required] public Guid CsvBatchId { get; set; }\n        public Dictionary<string, string>? Mappings { get; set; } // token -> header or \"constant:Value\"\n        public string? PhoneField { get; set; }\n        public bool NormalizePhones { get; set; } = true;\n        public bool Deduplicate { get; set; } = true;\n        public int? Limit { get; set; } = 200;\n\n        public bool Persist { get; set; } = false;\n        public string? AudienceName { get; set; } // required when Persist=true\n    }\n\n    public sealed class CsvMaterializedRowDto\n    {\n        public int RowIndex { get; set; }\n        public string? Phone { get; set; }\n        public Dictionary<string, string> Variables { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public sealed class CampaignCsvMaterializeResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public Guid CsvBatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int MaterializedCount { get; set; }\n        public int SkippedCount { get; set; }\n        public Guid? AudienceId { get; set; }          // if persisted\n        public List<CsvMaterializedRowDto> Preview { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDispatchDtos.cs",
      "sha256": "141796a3913c2089c829bec345ac9d929fb9d8d23826436df34de7d709426f82",
      "language": "csharp",
      "size": 884,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignDispatchResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string Mode { get; set; } = \"canary\"; // canary|full\n        public int RequestedCount { get; set; }\n        public int SelectedCount { get; set; }\n        public int EnqueuedCount { get; set; }\n        public List<DispatchedRecipientDto> Sample { get; set; } = new(); // small sample for debug\n        public List<string> Warnings { get; set; } = new();\n    }\n\n    public sealed class DispatchedRecipientDto\n    {\n        public Guid RecipientId { get; set; }\n        public string? Phone { get; set; }\n        public string? Status { get; set; }\n        public DateTime? MaterializedAt { get; set; }\n        public string? IdempotencyKey { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDispatchPlanDtos.cs",
      "sha256": "11f2306c03e0faa381004558316aded4856107a52df35dde32c528be27d16f34",
      "language": "csharp",
      "size": 1870,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class DispatchBatchDto\n    {\n        public int BatchNumber { get; set; }\n        public int StartIndex { get; set; }\n        public int Count { get; set; }\n\n        /// <summary>Total approximate payload size for this batch in bytes (text + buttons, naive estimate).</summary>\n        public int ApproxBytes { get; set; }\n\n        /// <summary>Seconds since plan start when this batch is allowed to start (based on throttling).</summary>\n        public int OffsetSeconds { get; set; }\n\n        public List<Guid?> RecipientIds { get; set; } = new();   // when using CampaignRecipients\n        public List<string?> Phones { get; set; } = new();\n        public List<string> Notes { get; set; } = new();\n    }\n\n    public class DispatchThrottleDto\n    {\n        public string Plan { get; set; } = \"Unknown\";\n        public string Provider { get; set; } = \"Auto\";\n        public int MaxBatchSize { get; set; } = 50;\n        public int MaxPerMinute { get; set; } = 300;\n        public int ComputedBatches { get; set; }\n        public int EstimatedMinutes { get; set; }\n        public List<string> Warnings { get; set; } = new();\n    }\n\n    public class CampaignDispatchPlanResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = \"en\";\n        public int PlaceholderCount { get; set; }\n\n        public int TotalRecipients { get; set; }\n        public int TotalApproxBytes { get; set; }\n\n        public DispatchThrottleDto Throttle { get; set; } = new();\n        public List<DispatchBatchDto> Batches { get; set; } = new();\n\n        public int WarningCount { get; set; }\n        public List<string> GlobalWarnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDryRunDto.cs",
      "sha256": "eb3c8b6acf0bcc6f3ce31d5d3b62a9183655a8bdcef813406921403f8625371b",
      "language": "csharp",
      "size": 1530,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignDryRunRecipientResultDto\n    {\n        public Guid? ContactId { get; set; }\n        public string? ContactName { get; set; }\n        public string PhoneNumber { get; set; } = \"\";\n        public bool WouldSend { get; set; }\n        public List<string> Errors { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n\n        // Provider-shaped components (Meta/Pinnacle compatible)\n        public List<object> ProviderComponents { get; set; } = new();\n    }\n\n    public sealed class CampaignDryRunResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string CampaignType { get; set; } = \"\";\n        public string TemplateName { get; set; } = \"\";\n        public string? Language { get; set; }\n        public bool HasHeaderMedia { get; set; }\n        public int RequiredPlaceholders { get; set; }\n        public int ProvidedPlaceholders { get; set; }\n\n        public int RecipientsConsidered { get; set; }\n        public int WouldSendCount { get; set; }\n        public int ErrorCount { get; set; }\n\n        // Billability (best-effort estimate)\n        public bool EstimatedChargeable { get; set; } = true;\n        public string EstimatedConversationCategory { get; set; } = \"template_outbound\";\n        public List<string> Notes { get; set; } = new();\n\n        public List<CampaignDryRunRecipientResultDto> Results { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDryRunDtos.cs",
      "sha256": "3ed24bbc0f923a1d28720fad67c5d2c1d8065edfb882467e24b0669d00433711",
      "language": "csharp",
      "size": 1116,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignDryRunIssueDto\n    {\n        public Guid? RecipientId { get; set; }\n        public Guid? ContactId { get; set; }\n        public string Phone { get; set; } = string.Empty;\n\n        /// <summary>\n        /// error | warn\n        /// </summary>\n        public string Severity { get; set; } = \"error\";\n\n        public string Message { get; set; } = string.Empty;\n    }\n\n    public class CampaignDryRunResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = string.Empty;\n\n        /// <summary>\n        /// Placeholder count detected in the template (e.g., {{1}}, {{2}}, ...).\n        /// </summary>\n        public int PlaceholderCount { get; set; }\n\n        public int CheckedRecipients { get; set; }\n        public int ErrorCount { get; set; }\n        public int WarningCount { get; set; }\n\n        public List<CampaignDryRunIssueDto> Issues { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignDto.cs",
      "sha256": "bf33c6aa688063d8efd2734082713e23890bb97409bae31a5bc9d18c00ccd001",
      "language": "csharp",
      "size": 1223,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.Features.CampaignModule.DTOs;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignDto\n    {\n        public Guid Id { get; set; }\n\n        public string Name { get; set; }\n\n        public string MessageTemplate { get; set; }\n\n        public string? TemplateId { get; set; }\n        public string? MessageBody { get; set; }\n        public string? CampaignType { get; set; }\n\n        public string? Status { get; set; }\n\n        public string? ImageUrl { get; set; }\n\n        public string? ImageCaption { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n\n        public DateTime? ScheduledAt { get; set; }\n\n        public Guid? CtaId { get; set; }\n\n        public CtaPreviewDto? Cta { get; set; }\n\n        public List<CampaignButtonDto> MultiButtons { get; set; } = new();\n\n        public Guid? CTAFlowConfigId { get; set; }\n        public string? CTAFlowName { get; set; }\n    }\n\n    // 📦 Embedded DTO for CTA preview (title + button text only)\n    public class CtaPreviewDto\n    {\n        public string Title { get; set; } = string.Empty;\n\n        public string ButtonText { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignMaterializationDtos.cs",
      "sha256": "8764d77154e31907654114e66ffc6eb0c83f456db58b64632a1df0a92a139b8e",
      "language": "csharp",
      "size": 2077,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class ButtonResolutionDto\n    {\n        public string ButtonText { get; set; } = string.Empty;\n        public string? RawTemplateValue { get; set; } // e.g. \"https://x.com/{{1}}?q={{2}}\"\n        public string? ResolvedUrl { get; set; }\n        public List<string> UsedPlaceholders { get; set; } = new(); // e.g. [\"{{1}}\",\"{{2}}\"]\n        public List<string> MissingArguments { get; set; } = new(); // e.g. [\"{{2}}\"]\n        public List<string> Notes { get; set; } = new();\n    }\n\n    public class TemplateParamResolutionDto\n    {\n        public int Index { get; set; } // 1-based placeholder index from template ({{1}}, {{2}}, ...)\n        public string? Value { get; set; }\n        public string SourceType { get; set; } = string.Empty; // AudienceColumn | Static | Expression\n        public string? SourceKey { get; set; } // column name when SourceType = AudienceColumn\n        public bool IsMissing { get; set; }\n        public string? Note { get; set; }\n    }\n\n    public class MaterializedRecipientDto\n    {\n        public Guid? RecipientId { get; set; }      // when using CampaignRecipients\n        public Guid? ContactId { get; set; }\n        public string? Phone { get; set; }\n\n        public List<TemplateParamResolutionDto> Parameters { get; set; } = new();\n        public List<ButtonResolutionDto> Buttons { get; set; } = new();\n\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public class CampaignMaterializeResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = string.Empty;\n        public string Language { get; set; } = string.Empty;\n        public int PlaceholderCount { get; set; }\n\n        public int ReturnedCount { get; set; }\n        public int ErrorCount { get; set; }\n        public int WarningCount { get; set; }\n\n        public List<MaterializedRecipientDto> Rows { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignMaterializeDtos.cs",
      "sha256": "b0877006311fb95066d695b7004e7b9ac971424f049675ca95d2e24fbbbcced6",
      "language": "csharp",
      "size": 2046,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CampaignMaterializeRequestDto\n    {\n        [Required] public Guid CsvBatchId { get; set; }\n\n        /// <summary>\n        /// Optional explicit mapping: token -> CSV header name or \"constant:Value\".\n        /// If null/empty, we’ll try loading saved mappings; if none exist, we fall back to header==token.\n        /// </summary>\n        public Dictionary<string, string>? Mappings { get; set; }\n\n        /// <summary>\n        /// If not provided, we will try common headers like phone, mobile, whatsapp, msisdn.\n        /// </summary>\n        public string? PhoneField { get; set; }\n\n        public bool NormalizePhones { get; set; } = true;\n        public bool Deduplicate { get; set; } = true;\n\n        /// <summary>Preview only first N rows; 0 or null means all.</summary>\n        public int? Limit { get; set; } = 200;\n\n        /// <summary>When true, materialized rows are persisted to Audience + CampaignRecipients.</summary>\n        public bool Persist { get; set; } = false;\n\n        /// <summary>Required when Persist = true.</summary>\n        public string? AudienceName { get; set; }\n    }\n\n    public sealed class MaterializedRowDto\n    {\n        public int RowIndex { get; set; }\n        public string? Phone { get; set; }\n        public Dictionary<string, string> Variables { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n\n    public sealed class CampaignMaterializeResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public Guid CsvBatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int MaterializedCount { get; set; }\n        public int SkippedCount { get; set; }\n        public Guid? AudienceId { get; set; } // when persisted\n        public List<MaterializedRowDto> Preview { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignPreviewDto.cs",
      "sha256": "ebe80e7f7af1dd5e800a15177ed1305cff9c9b04a8a9b5c000a8afc3de02d1c5",
      "language": "csharp",
      "size": 1547,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignPreviewRequestDto\n    {\n        // Optional: preview using a specific recipient’s contact info\n        public Guid? ContactId { get; set; }\n    }\n\n    public class CampaignPreviewResponseDto\n    {\n        public Guid CampaignId { get; set; }\n        public string TemplateName { get; set; } = \"\";\n        public string Language { get; set; } = \"en_US\";\n        public int PlaceholderCount { get; set; }\n\n        public string BodyPreview { get; set; } = \"\";\n        public List<string> MissingParams { get; set; } = new();  // e.g. [\"{{2}} required but not supplied\"]\n\n        public bool HasHeaderMedia { get; set; }\n        public string? HeaderType { get; set; } // IMAGE/VIDEO/DOCUMENT (if you later persist)\n\n        public List<ButtonPreviewDto> Buttons { get; set; } = new();\n    }\n\n    public class ButtonPreviewDto\n    {\n        public int Index { get; set; }            // 0..2\n        public string Text { get; set; } = \"\";\n        public string Type { get; set; } = \"URL\"; // Meta types\n        public bool IsDynamic { get; set; }       // needs parameter\n        public string? TemplateParamBase { get; set; } // e.g. \"/r/{{1}}\"\n        public string? CampaignValue { get; set; } // what user set in campaign (for dynamic)\n        public string? TokenParam { get; set; }    // what we’d send when base has {{1}}\n        public string? FinalUrlPreview { get; set; } // full tracked URL preview\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignRecipientDto.cs",
      "sha256": "028557690cc0247c25a5db36100a674f3a36f1d96ac0eba571a51fd3aa57febe",
      "language": "csharp",
      "size": 756,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignRecipientDto\n    {\n        public Guid Id { get; set; }\n\n        public Guid? ContactId { get; set; }\n        public string ContactName { get; set; }\n        public string ContactPhone { get; set; }\n\n        public string Status { get; set; }\n        public DateTime? SentAt { get; set; }\n\n        // 🔁 Advanced Fields (for analytics & future automation)\n        public string? BotId { get; set; }\n        public string? MessagePreview { get; set; }\n        public string? ClickedCTA { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public bool IsAutoTagged { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignRetryDtos.cs",
      "sha256": "f6d2dd143ecf14f40ec9b5d30aad7ad83309e99f5aab199c117f31dce552d68f",
      "language": "csharp",
      "size": 539,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignRetryResultDto\n    {\n        public Guid CampaignId { get; set; }\n        public int ConsideredFailed { get; set; }\n        public int Retried { get; set; }\n        public int Skipped { get; set; }  // e.g., duplicates, already succeeded, or filtered out\n        public List<Guid> RecipientIdsSample { get; set; } = new(); // up to 20 IDs for quick inspection\n        public string? Note { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignSummaryDto.cs",
      "sha256": "e425735df2c030aa13e5b046f7039f9796104b05b3ec998e039ab1d7eb40b0e0",
      "language": "csharp",
      "size": 687,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignSummaryDto\n    {\n        public Guid Id { get; set; }\n        public string? Name { get; set; }\n        public string? Status { get; set; }\n        public DateTime? ScheduledAt { get; set; }\n        public DateTime CreatedAt { get; set; }\n        public int Delivered { get; set; }\n        public int Read { get; set; }\n\n        public string? ImageUrl { get; set; } // ✅ Add this\n        public string? ImageCaption { get; set; } // ✅ Add this\n        public string? CtaTitle { get; set; } // Optional: For CTA info\n        public int RecipientCount { get; set; } // Optional: To show 0/10 etc\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CampaignVariableMapDto.cs",
      "sha256": "09ea689514db078a870217be4fac18f0168d401c0cc23df1d1e9a96099feaa5e",
      "language": "csharp",
      "size": 936,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CampaignVariableMapDto\n    {\n        public Guid CampaignId { get; set; }\n        public List<CampaignVariableMapItemDto> Items { get; set; } = new();\n    }\n\n    public class CampaignVariableMapItemDto\n    {\n        // Matches your normalized model fields\n        public string Component { get; set; } = \"\";   // \"body\", \"header\", \"button:url:1\"\n        public int Index { get; set; }                // 1..N\n\n        public string SourceType { get; set; } = \"Static\"; // ContactField | CsvColumn | Static | Expression\n        public string? SourceKey { get; set; }             // \"name\" / CSV header, etc.\n        public string? StaticValue { get; set; }\n        public string? Expression { get; set; }\n        public string? DefaultValue { get; set; }\n        public bool IsRequired { get; set; } = false;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchListItemDto.cs",
      "sha256": "a3ecc66b83ee911be585b7fc50285b27717bedb0f0d6a709ee1532a5116f338a",
      "language": "csharp",
      "size": 501,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Lightweight projection for listing recent CSV batches.\n    /// </summary>\n    public sealed class CsvBatchListItemDto\n    {\n        public Guid BatchId { get; set; }\n        public string? FileName { get; set; }\n        public int RowCount { get; set; }\n        public string Status { get; set; } = \"ready\"; // ready | ingesting | failed | complete\n        public DateTime CreatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchRowsPageDto.cs",
      "sha256": "f884ce43dea32e9316e6d9c44036d937745a81ce2f82ea1da5625cdcd446f6a9",
      "language": "csharp",
      "size": 481,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    /// <summary>\n    /// Paged slice of CSV rows for previewing a batch.\n    /// </summary>\n    public sealed class CsvBatchRowsPageDto\n    {\n        public Guid BatchId { get; set; }\n        public int TotalRows { get; set; }\n        public int Skip { get; set; }\n        public int Take { get; set; }\n        public List<CsvRowSampleDto> Rows { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/CsvBatchValidationDtos.cs",
      "sha256": "ad1652fd6b89c2d226dd44e051a9b9c5311e7db7d377de150c8dafcd4e454bd2",
      "language": "csharp",
      "size": 1541,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class CsvBatchValidationRequestDto\n    {\n        /// <summary>Explicit phone column to use; if null we'll try to auto-detect.</summary>\n        public string? PhoneField { get; set; }\n\n        /// <summary>Normalize phones (strip punctuation/leading zeros; add 91 for 10-digit local).</summary>\n        public bool NormalizePhones { get; set; } = true;\n\n        /// <summary>Report duplicates after normalization.</summary>\n        public bool Deduplicate { get; set; } = true;\n\n        /// <summary>Headers that must exist in the CSV.</summary>\n        public List<string>? RequiredHeaders { get; set; }\n\n        /// <summary>How many problematic rows to include in the response samples.</summary>\n        public int SampleSize { get; set; } = 20;\n    }\n\n    public sealed class CsvBatchValidationResultDto\n    {\n        public Guid BatchId { get; set; }\n        public int TotalRows { get; set; }\n\n        public string? PhoneField { get; set; }\n\n        public int MissingPhoneCount { get; set; }\n        public int DuplicatePhoneCount { get; set; }\n\n        public List<string> MissingRequiredHeaders { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n\n        /// <summary>Sample of problematic rows (missing phone / dup / other).</summary>\n        public List<CsvRowSampleDto> ProblemSamples { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/FlowListItemDto.cs",
      "sha256": "3121c1e145f2d4fd8f1f4978f314782f0afa5d7be9ffe7be6709cfc04af7d068",
      "language": "csharp",
      "size": 246,
      "content": "namespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class FlowListItemDto\n    {\n        public Guid Id { get; set; }\n        public string FlowName { get; set; } = string.Empty;\n        public bool IsPublished { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/OutboundCampaignJobCreateDto.cs",
      "sha256": "31ade95e7e39a78f5fd669bc7ce9d887c7c004acd05e3e44eb0a6e487b837bd4",
      "language": "csharp",
      "size": 613,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Queueing.DTOs\n{\n    /// <summary>\n    /// Minimal job creation payload for outbound campaign sends.\n    /// The worker will hydrate the template parameters from CampaignRecipient.\n    /// </summary>\n    public sealed class OutboundCampaignJobCreateDto\n    {\n        public Guid BusinessId { get; set; }\n        public Guid CampaignId { get; set; }\n        public Guid CampaignRecipientId { get; set; }\n\n        /// <summary>Deduplication key. The queue should drop duplicates with the same key.</summary>\n        public string? IdempotencyKey { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/OutboundCampaignJobDto.cs",
      "sha256": "3f95f27a03d9cf5a08d649a168cd9cf34b1e790c060f74411eb1cc8dd981f190",
      "language": "csharp",
      "size": 649,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class OutboundCampaignJobDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid CampaignId { get; set; }\n\n        public string Status { get; set; } = \"queued\"; // queued | running | succeeded | failed | canceled\n        public int Attempt { get; set; }\n        public int MaxAttempts { get; set; }\n\n        public DateTimeOffset? NextAttemptAt { get; set; }\n        public string? LastError { get; set; }\n\n        public DateTime CreatedAt { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/Requests/CsvBatchUploadForm.cs",
      "sha256": "31e21b0a508910a830966b0aa791e6ca80e872c95f1621bac998386f956b38da",
      "language": "csharp",
      "size": 385,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing Microsoft.AspNetCore.Http;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs.Requests\n{\n    // Swagger-safe wrapper for multipart upload\n    public sealed class CsvBatchUploadForm\n    {\n        public Guid? AudienceId { get; set; }\n\n        [Required]\n        public IFormFile File { get; set; } = default!;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/SendJobDtos.cs",
      "sha256": "6e46d4af7214847bbbb20aad58770f26f7885d22c06b9fd7934ba21449e5e25f",
      "language": "csharp",
      "size": 1907,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public enum SendJobState\n    {\n        Pending = 0,\n        Running = 1,\n        Succeeded = 2,\n        Failed = 3,\n        Canceled = 4,\n        Partial = 5\n    }\n\n    public class SendJobStartRequestDto\n    {\n        public bool Force { get; set; } = false;     // allow send even if dry-run has errors (logged loudly)\n        public int Limit { get; set; } = 2000;       // cap on planned recipients\n    }\n\n    public class SendJobStartResponseDto\n    {\n        public Guid JobId { get; set; }\n        public Guid CampaignId { get; set; }\n        public string Message { get; set; } = \"Send job queued.\";\n    }\n\n    public class SendJobBatchResultDto\n    {\n        public int BatchNumber { get; set; }\n        public int Count { get; set; }\n        public int Success { get; set; }\n        public int Failed { get; set; }\n        public int Skipped { get; set; }\n        public string Notes { get; set; } = string.Empty;\n        public int OffsetSeconds { get; set; }\n    }\n\n    public class SendJobStatusDto\n    {\n        public Guid JobId { get; set; }\n        public Guid CampaignId { get; set; }\n        public SendJobState State { get; set; }\n        public DateTimeOffset CreatedAt { get; set; }\n        public DateTimeOffset? StartedAt { get; set; }\n        public DateTimeOffset? CompletedAt { get; set; }\n\n        public int PlannedBatches { get; set; }\n        public int CompletedBatches { get; set; }\n\n        public int PlannedRecipients { get; set; }\n        public int SentSuccess { get; set; }\n        public int SentFailed { get; set; }\n        public int Skipped { get; set; }\n\n        public List<SendJobBatchResultDto> Batches { get; set; } = new();\n        public List<string> Warnings { get; set; } = new();\n        public List<string> Errors { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/DTOs/VideoTemplateMessageDto.cs",
      "sha256": "d46c45dcc1d7b4109a51ea465c89038fe205538ef0d02d55804421de868b6bbb",
      "language": "csharp",
      "size": 631,
      "content": "// Features/CampaignModule/DTOs/VideoTemplateMessageDto.cs\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public sealed class VideoTemplateMessageDto\n    {\n        public string RecipientNumber { get; set; } = \"\";\n        public string TemplateName { get; set; } = \"\";\n        public string LanguageCode { get; set; } = \"en_US\";\n\n        // URL for the video header (HTTPS)\n        public string? HeaderVideoUrl { get; set; }\n\n        public List<string> TemplateParameters { get; set; } = new();\n        public List<CampaignButtonDto> ButtonParameters { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Helpers/IVariableResolver.cs",
      "sha256": "f956c04fe5689e3e6613e4d68e1e7dd8ead05b4dd82944fddaffbda5fce24ede",
      "language": "csharp",
      "size": 316,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.Helpers\n{\n    public interface IVariableResolver\n    {\n        Dictionary<string, string> ResolveVariables(\n            IReadOnlyDictionary<string, string> rowData,\n            IReadOnlyDictionary<string, string>? mappings);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Helpers/VariableResolver.cs",
      "sha256": "3933572c1fb60c82a9c9040df8c0f47b8dddc4404e3e30bc379e7c5f504b12f6",
      "language": "csharp",
      "size": 1359,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.Helpers\n{\n    public sealed class VariableResolver : IVariableResolver\n    {\n        public Dictionary<string, string> ResolveVariables(\n            IReadOnlyDictionary<string, string> rowData,\n            IReadOnlyDictionary<string, string>? mappings)\n        {\n            var result = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            if (mappings == null || mappings.Count == 0)\n            {\n                foreach (var kv in rowData)\n                    result[kv.Key.Trim()] = kv.Value?.Trim() ?? string.Empty;\n                return result;\n            }\n\n            foreach (var (token, srcRaw) in mappings)\n            {\n                if (string.IsNullOrWhiteSpace(token)) continue;\n\n                var src = srcRaw?.Trim() ?? string.Empty;\n                if (src.StartsWith(\"constant:\", StringComparison.OrdinalIgnoreCase))\n                {\n                    result[token] = src.Substring(\"constant:\".Length).Trim();\n                    continue;\n                }\n\n                if (rowData.TryGetValue(src, out var v) && v != null)\n                    result[token] = v.Trim();\n                else\n                    result[token] = string.Empty;\n            }\n\n            return result;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/Audience.cs",
      "sha256": "9ab5c5898df2acc74abe3fffe97a37d0de79df0d455be0e3dec1a8a7ee4061c8",
      "language": "csharp",
      "size": 1187,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Logical grouping of recipients (often tied to a CsvBatch).\n    /// A campaign can materialize recipients from one Audience.\n    /// </summary>\n    public class Audience\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        [Required, MaxLength(160)]\n        public string Name { get; set; } = \"Untitled Audience\";\n\n        [MaxLength(512)]\n        public string? Description { get; set; }  // useful in UI\n               \n        public Guid? CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }\n\n        public Guid? CsvBatchId { get; set; }\n        public CsvBatch? CsvBatch { get; set; }\n\n        public bool IsDeleted { get; set; } = false;\n\n        public Guid? CreatedByUserId { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n\n        public DateTime? UpdatedAt { get; set; }   // audit\n\n        public ICollection<AudienceMember> Members { get; set; } = new List<AudienceMember>();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/AudienceMember.cs",
      "sha256": "9d7b99694c279cd7bd36310ea787ed4c4ee781e20167060799d281170358f6da",
      "language": "csharp",
      "size": 1615,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// A single member of an Audience. May or may not be linked to a Contact.\n    /// </summary>\n    public class AudienceMember\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid AudienceId { get; set; }\n        public Audience Audience { get; set; } = null!;\n\n        // 🆕 explicit tenant for fast filtering & safety\n        [Required] public Guid BusinessId { get; set; }\n\n        /// <summary>Optional CRM link; null for non-CRM rows until promotion</summary>\n        public Guid? ContactId { get; set; }\n\n        [MaxLength(64)]\n        public string? PhoneRaw { get; set; }\n\n        [MaxLength(32)]\n        public string? PhoneE164 { get; set; }\n\n        [MaxLength(160)]\n        public string? Name { get; set; }\n\n        [MaxLength(256)]\n        public string? Email { get; set; }   // 🆕\n\n        /// <summary>Additional attributes from CSV row (json)</summary>\n        public string? AttributesJson { get; set; } // keep name as-is\n\n        /// <summary>True if an “auto-created” CRM contact; subject to retention</summary>\n        public bool IsTransientContact { get; set; } = false;\n\n        public bool IsDeleted { get; set; } = false;  // 🆕\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime? UpdatedAt { get; set; }      // 🆕\n        public DateTime? PromotedAt { get; set; }     // when transient → durable Contact\n        public Guid? CreatedByUserId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/Campaign.cs",
      "sha256": "6222399d39b9093c105f9478e9ec864ee48bf5475d197f853ea72b6c23658508",
      "language": "csharp",
      "size": 3304,
      "content": "using System;\nusing System.Collections.Generic;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\nusing xbytechat.api.Features.CTAManagement.Models;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CTAFlowBuilder.Models; // 🆕 Import for CTAFlowConfig\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class Campaign\n    {\n        public Guid Id { get; set; }\n\n        // 🔗 Business info\n        public Guid BusinessId { get; set; }\n        public Business Business { get; set; }\n        public Guid? CampaignId { get; set; }\n        public Campaign? SourceCampaign { get; set; }\n\n        // 📋 Core campaign details\n        public string Name { get; set; }\n        public string MessageTemplate { get; set; }\n        public string? TemplateId { get; set; } // ✅ Meta-approved template ID\n\n        [Column(TypeName = \"text\")]\n        public string? MessageBody { get; set; } // ✅ Final resolved WhatsApp message body\n\n        public string? FollowUpTemplateId { get; set; }\n        public string? CampaignType { get; set; } // text, template, cta\n\n        // 🔘 CTA tracking (optional)\n        public Guid? CtaId { get; set; }\n        public CTADefinition? Cta { get; set; }\n\n        // 🆕 Link to Flow Config (optional)\n        public Guid? CTAFlowConfigId { get; set; }\n       // [ForeignKey(nameof(CTAFlowConfigId))]\n        public CTAFlowConfig? CTAFlowConfig { get; set; }\n\n        public DateTime? ScheduledAt { get; set; }\n        public string Status { get; set; } = \"Draft\"; // Draft, Scheduled, Sent\n\n        // 👤 Metadata\n        public string? CreatedBy { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // 🗑️ Soft delete support\n        public bool IsDeleted { get; set; } = false;\n        public DateTime? DeletedAt { get; set; }\n        public string? DeletedBy { get; set; }\n\n        // 👥 Recipient relationship\n        public ICollection<CampaignRecipient> Recipients { get; set; }\n\n        // 📊 Logs\n        public ICollection<CampaignSendLog> SendLogs { get; set; } = new List<CampaignSendLog>();\n        public ICollection<MessageStatusLog> MessageStatusLogs { get; set; }\n\n        public string? ImageUrl { get; set; }\n        public string? ImageCaption { get; set; }\n        public string? TemplateParameters { get; set; }\n\n        public ICollection<CampaignButton> MultiButtons { get; set; } = new List<CampaignButton>();\n\n        public ICollection<MessageLog> MessageLogs { get; set; } = new List<MessageLog>();\n\n        public string? Provider { get; set; }            // UPPERCASE only\n        public string? PhoneNumberId { get; set; }\n\n        public string? TemplateSchemaSnapshot { get; set; }\n\n        public ICollection<CampaignVariableMap> VariableMaps { get; set; } = new List<CampaignVariableMap>();\n\n        public Guid? AudienceId { get; set; }\n        public ICollection<Audience> Audiences { get; set; } = new List<Audience>();\n\n        public string? VideoUrl { get; set; }\n        public string? DocumentUrl { get; set; }\n    }\n}\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignButton.cs",
      "sha256": "bfca22e0aed3117f3be8b3712de4a7b229991bc3c4b02bdb1f17e43709991977",
      "language": "csharp",
      "size": 654,
      "content": "using System;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignButton\n    {\n        public Guid Id { get; set; }\n\n        public Guid CampaignId { get; set; } // 🔗 Foreign key\n        public Campaign Campaign { get; set; }\n\n        public string Title { get; set; } = string.Empty; // Button Text (e.g. Buy Now)\n        public string Type { get; set; } = \"url\"; // Type: url, quick_reply, call, etc.\n        public string Value { get; set; } = string.Empty; // Target URL or payload\n\n        public int Position { get; set; } // Button order (1–3)\n        public bool IsFromTemplate { get; set; } = false;\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignFlowOverride.cs",
      "sha256": "c4ee719e7601cfb0eb6d67fbba7e11cbd4a57ad5be58dd84f72beead08d88370",
      "language": "csharp",
      "size": 798,
      "content": "using System.ComponentModel.DataAnnotations.Schema;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignFlowOverride\n    {\n        [Key]\n        public Guid Id { get; set; }\n\n        [Required]\n        public Guid CampaignId { get; set; }\n\n        [Required]\n        [MaxLength(100)]\n        public string TemplateName { get; set; } = string.Empty;\n\n        [Required]\n        [MaxLength(50)]\n        public string ButtonText { get; set; } = string.Empty;\n\n        public string? OverrideNextTemplate { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n\n        [ForeignKey(\"CampaignId\")]\n        public Campaign? Campaign { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignRecipient.cs",
      "sha256": "99ad2bdaa441c049d3dc34f0ba39d88a7cd9ff1b61b193a26887e0ff4c7ebe3c",
      "language": "csharp",
      "size": 4259,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.DataAnnotations.Schema;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.BusinessModule.Models;\nusing xbytechat.api.Features.CampaignTracking.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    public class CampaignRecipient\n    {\n        public Guid Id { get; set; }\n\n        public Guid CampaignId { get; set; }\n        public Campaign? Campaign { get; set; }   // nav is optional at runtime\n\n        public Guid? ContactId { get; set; }      // ← optional FK\n        public Contact? Contact { get; set; }\n\n        public string Status { get; set; } = \"Pending\"; // Pending, Sent, Delivered, Failed, Replied\n        public DateTime? SentAt { get; set; }\n\n        public string? BotId { get; set; }\n        public string? MessagePreview { get; set; }\n        public string? ClickedCTA { get; set; }\n        public string? CategoryBrowsed { get; set; }\n        public string? ProductBrowsed { get; set; }\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n\n        public bool IsAutoTagged { get; set; } = false;\n\n        // Logs\n        public ICollection<CampaignSendLog> SendLogs { get; set; } = new List<CampaignSendLog>();\n\n        public Guid BusinessId { get; set; }\n        public Business? Business { get; set; }\n\n        public Guid? AudienceMemberId { get; set; }\n        public AudienceMember? AudienceMember { get; set; } = null!;\n\n        [Column(TypeName = \"jsonb\")]\n        public string? ResolvedParametersJson { get; set; }\n\n        [Column(TypeName = \"jsonb\")]\n        public string? ResolvedButtonUrlsJson { get; set; }\n\n        public string? IdempotencyKey { get; set; }\n        public DateTime? MaterializedAt { get; set; }\n    }\n}\n\n\n//using System;\n//using System.Collections.Generic;\n//using xbytechat.api.CRM.Models;\n//using xbytechat.api.Features.BusinessModule.Models;\n//using xbytechat.api.Features.CampaignTracking.Models;\n\n//namespace xbytechat.api.Features.CampaignModule.Models\n//{\n//    public class CampaignRecipient\n//    {\n//        public Guid Id { get; set; }\n\n//        public Guid CampaignId { get; set; }\n//        public Campaign Campaign { get; set; }\n\n//        public Guid? ContactId { get; set; }\n//        public Contact Contact { get; set; }\n\n//        public string Status { get; set; } = \"Pending\"; // Pending, Sent, Delivered, Failed, Replied\n//        public DateTime? SentAt { get; set; }\n\n//        public string? BotId { get; set; } // Multi-bot support\n//        public string? MessagePreview { get; set; } // Final message sent\n//        public string? ClickedCTA { get; set; } // Track CTA clicked like \"BuyNow\"\n//        public string? CategoryBrowsed { get; set; } // e.g., Ads\n//        public string? ProductBrowsed { get; set; } // e.g., Product name\n//        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n\n//        public bool IsAutoTagged { get; set; } = false; // Flag for automation-based tagging\n\n//        // ✅ NEW: One-to-many link to detailed logs (message attempts, delivery tracking)\n//        public ICollection<CampaignSendLog> SendLogs { get; set; }\n\n//        public Guid BusinessId { get; set; }  // ✅ Add this line\n//        public Business Business { get; set; } = null!; // if navigation is needed\n\n//        // If this recipient originated from an Audience upload (CSV), link it here\n//        public Guid? AudienceMemberId { get; set; }\n//        // Resolved template parameters for this recipient (body/header placeholders)\n//        // Example: [\"Nicola\",\"500OFF\"]\n//        public string? ResolvedParametersJson { get; set; }\n\n//        // Resolved final URLs for buttons (index-aligned: 0,1,2)\n//        // Example: [\"https://lnk.xbyte/r/abc\", \"https://lnk.xbyte/r/def\"]\n//        public string? ResolvedButtonUrlsJson { get; set; }\n\n//        // An idempotency fingerprint for the specific send to this recipient\n//        // (e.g., SHA256(CampaignId|PhoneE164|TemplateName|ResolvedParametersJson|ResolvedButtonUrlsJson))\n//        public string? IdempotencyKey { get; set; }\n\n//        // When this recipient was materialized (frozen) and ready to dispatch\n//        public DateTime? MaterializedAt { get; set; }\n\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CampaignVariableMap.cs",
      "sha256": "c20c9a369db1d26855d7c1f75e480de9e892b21cc63635b31220904e75f0194b",
      "language": "csharp",
      "size": 2019,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Maps a template placeholder to a data source for a specific campaign.\n    /// Examples of Component:\n    ///   \"body\", \"header\", \"button:url:1\"\n    /// Index is 1-based ({{1}}, {{2}}, ...).\n    /// </summary>\n    public class CampaignVariableMap\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid CampaignId { get; set; }\n        public Campaign Campaign { get; set; } = null!;\n\n        /// <summary> \"body\" | \"header\" | \"button:url:1\" </summary>\n        [Required, MaxLength(64)]\n        public string Component { get; set; } = null!;\n\n        /// <summary> 1..N (corresponds to {{index}}) </summary>\n        [Required]\n        public int Index { get; set; }\n\n        /// <summary>\n        /// ContactField | CsvColumn | Static | Expression\n        /// </summary>\n        [Required, MaxLength(32)]\n        public string SourceType { get; set; } = null!;\n\n        /// <summary>\n        /// If SourceType == ContactField → \"name\",\"phone\",\"email\",...\n        /// If SourceType == CsvColumn → CSV header name.\n        /// Otherwise null.\n        /// </summary>\n        [MaxLength(128)]\n        public string? SourceKey { get; set; }\n\n        /// <summary>Used when SourceType == Static</summary>\n        public string? StaticValue { get; set; }\n\n        /// <summary>Optional expression (mini DSL) for computed values</summary>\n        public string? Expression { get; set; }\n\n        /// <summary>Fallback when source is empty/invalid</summary>\n        public string? DefaultValue { get; set; }\n\n        /// <summary>If true, missing value = validation error in dry-run</summary>\n        public bool IsRequired { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public Guid? CreatedByUserId { get; set; }\n        public Guid BusinessId { get; set; }  // denormalized for ownership checks\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvBatch.cs",
      "sha256": "9ab2036813c02e1428373fb89419b490fe5c4f4a0279eb40c5c2e5b8d87398cd",
      "language": "csharp",
      "size": 1513,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Represents a single CSV upload (file) for a business.\n    /// Stores headers and basic metadata; rows live in CsvRow.\n    /// </summary>\n    public class CsvBatch\n    {\n        [Key] public Guid Id { get; set; }\n\n        [Required] public Guid BusinessId { get; set; }\n\n        public Guid? AudienceId { get; set; }\n        /// <summary>Original filename, if available</summary>\n        [MaxLength(256)]\n        public string? FileName { get; set; }\n\n      \n        /// <summary>Comma-separated or JSON array of headers (we’ll map to jsonb via DbContext)</summary>\n        public string? HeadersJson { get; set; }\n\n        /// <summary>SHA256 (or similar) of file contents for dedupe</summary>\n        [MaxLength(128)]\n        public string? Checksum { get; set; }\n\n        /// <summary>Total rows parsed (including headerless lines after validation)</summary>\n        public int RowCount { get; set; }\n\n        /// <summary>Total rows skipped due to validation</summary>\n        public int SkippedCount { get; set; }\n\n        [MaxLength(32)]\n        public string Status { get; set; } = \"ready\"; // ready | ingesting | failed | complete\n\n        public string? ErrorMessage { get; set; }\n\n        public Guid? CreatedByUserId { get; set; }\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvBatchDtos.cs",
      "sha256": "8a302f82fd2cec1db09b6ef343902b803d507900620ea83b8e551b3e59d620c3",
      "language": "csharp",
      "size": 1008,
      "content": "using System;\nusing System.Collections.Generic;\n\nnamespace xbytechat.api.Features.CampaignModule.DTOs\n{\n    public class CsvBatchUploadResultDto\n    {\n        public Guid BatchId { get; set; }\n        public Guid? AudienceId { get; set; }           // <-- nullable: matches CsvBatch.AudienceId (Guid?)\n        public int RowCount { get; set; }\n        public List<string> Headers { get; set; } = new();\n        public string Message { get; set; } = \"CSV batch created.\";\n        public string FileName { get; set; } = string.Empty;\n    }\n\n    public class CsvBatchInfoDto\n    {\n        public Guid BatchId { get; set; }\n        public Guid? AudienceId { get; set; }           // <-- nullable\n        public int RowCount { get; set; }\n        public List<string> Headers { get; set; } = new();\n        public DateTime CreatedAt { get; set; }\n    }\n\n    public class CsvRowSampleDto\n    {\n        public int RowIndex { get; set; }\n        public Dictionary<string, string?> Data { get; set; } = new();\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/CsvRow.cs",
      "sha256": "26dc0e4b4ef801544a8e3935a243f3cb34507713dc1561f9cf08cd7895b316ba",
      "language": "csharp",
      "size": 1816,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// One parsed CSV row. Data stored as JSON (key = header, value = cell).\n    /// RowIndex is 0-based (first data row = 0) to match streaming ingest.\n    /// </summary>\n    public class CsvRow\n    {\n        [Key] public Guid Id { get; set; }\n\n        /// <summary>Tenant scoping for fast filters</summary>\n        [Required] public Guid BusinessId { get; set; }\n\n        /// <summary>FK to CsvBatch.Id</summary>\n        [Required] public Guid BatchId { get; set; }\n        public CsvBatch Batch { get; set; } = null!;\n\n        /// <summary>0-based row number within the batch</summary>\n        [Required]\n        public int RowIndex { get; set; }\n\n        /// <summary>Raw phone, exactly as uploaded (optional convenience)</summary>\n        [MaxLength(64)]\n        public string? PhoneRaw { get; set; }\n\n        /// <summary>Normalized phone in E.164 (+&lt;country&gt;&lt;number&gt;)</summary>\n        [MaxLength(32)]\n        public string? PhoneE164 { get; set; }\n\n        /// <summary>JSON of the row: {\"header\":\"value\", ...}</summary>\n        public string RowJson { get; set; } = \"{}\";\n\n        /// <summary>\n        /// Back-compat shim for code that uses DataJson.\n        /// Not mapped to its own column; simply forwards to RowJson.\n        /// </summary>\n        [NotMapped]\n        public string? DataJson\n        {\n            get => RowJson;\n            set => RowJson = value ?? \"{}\";\n        }\n\n        /// <summary>If invalid at ingest/validation time, store reason here</summary>\n        public string? ValidationError { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Models/OutboundCampaignJob.cs",
      "sha256": "d9575f6ce2eee26b028d3f7d233b75faafc1be91456fee92b9d19a78ff0bf0e2",
      "language": "csharp",
      "size": 1507,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.CampaignModule.Models\n{\n    /// <summary>\n    /// Queue item to send a whole campaign. Worker will call CampaignService to send.\n    /// </summary>\n    public class OutboundCampaignJob\n    {\n        [Key]\n        public Guid Id { get; set; } = Guid.NewGuid();\n\n        [Required]\n        public Guid BusinessId { get; set; }\n\n        [Required]\n        public Guid CampaignId { get; set; }\n\n        /// <summary>\n        /// queued | running | succeeded | failed\n        /// </summary>\n        [MaxLength(32)]\n        public string Status { get; set; } = \"queued\";\n\n        /// <summary>\n        /// Number of send attempts performed.\n        /// </summary>\n        public int Attempt { get; set; } = 0;\n\n        /// <summary>\n        /// Max attempts before we mark failed.\n        /// </summary>\n        public int MaxAttempts { get; set; } = 5;\n\n        /// <summary>\n        /// When this job becomes eligible for pickup (for backoff).\n        /// </summary>\n        public DateTimeOffset NextAttemptAt { get; set; } = DateTimeOffset.UtcNow;\n\n        /// <summary>\n        /// Last error string (truncated in service).\n        /// </summary>\n        [MaxLength(4000)]\n        public string? LastError { get; set; }\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignDispatcher.cs",
      "sha256": "e23c54c8a6e2d72b8aea5617873775c82e4e57a4faa9a888d341f52ba779d485",
      "language": "csharp",
      "size": 9629,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n// DO NOT import a different interface namespace; the interface is in this same namespace.\nusing xbytechat.api.Features.Queueing.DTOs;     // OutboundCampaignJobCreateDto\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Picks materialized recipients (MaterializedAt != null) in a stable order,\n    /// filters to \"ready\" statuses, and enqueues send jobs via your outbound queue.\n    /// </summary>\n    public sealed class CampaignDispatcher : ICampaignDispatcher\n    {\n        private readonly AppDbContext _db;\n        private readonly IOutboundCampaignQueueService _queue; // interface is in this same namespace\n\n        // If you use enums, map these accordingly.\n        private static readonly string[] ReadyStatuses = { \"Pending\", \"Ready\" };\n\n        public CampaignDispatcher(AppDbContext db, IOutboundCampaignQueueService queue)\n        {\n            _db = db;\n            _queue = queue;\n        }\n\n        //public async Task<CampaignDispatchResponseDto> DispatchAsync(\n        //    Guid businessId,\n        //    Guid campaignId,\n        //    string mode,\n        //    int count,\n        //    CancellationToken ct = default)\n        //{\n        //    if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n        //    if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required.\");\n\n        //    mode = (mode ?? \"canary\").Trim().ToLowerInvariant();\n        //    if (mode != \"canary\" && mode != \"full\") mode = \"canary\";\n        //    if (count <= 0) count = 25;\n\n        //    // 1) Sanity: ownership\n        //    var owns = await _db.Campaigns.AsNoTracking()\n        //        .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n        //    if (!owns) throw new UnauthorizedAccessException(\"Campaign not found or not owned by this business.\");\n\n        //    // 2) Base recipients query (materialized + ready)\n        //    var baseQuery = _db.CampaignRecipients.AsNoTracking()\n        //        .Where(r => r.BusinessId == businessId\n        //                 && r.CampaignId == campaignId\n        //                 && r.MaterializedAt != null\n        //                 && ReadyStatuses.Contains(r.Status));\n\n        //    // 3) Stable order: oldest materialized first; then Id as tiebreaker\n        //    baseQuery = baseQuery.OrderBy(r => r.MaterializedAt).ThenBy(r => r.Id);\n\n        //    // 4) Select candidates (slightly over-select; queue dedupes)\n        //    var desired = mode == \"canary\" ? count : int.MaxValue;\n        //    var take = Math.Min(desired * 2, 5000);\n        //    var candidates = await baseQuery.Take(take).ToListAsync(ct);\n\n        //    // --- Build queue jobs ---\n        //    var jobs = new List<OutboundCampaignJobCreateDto>(candidates.Count);\n        //    foreach (var r in candidates)\n        //    {\n        //        jobs.Add(new OutboundCampaignJobCreateDto\n        //        {\n        //            BusinessId = businessId,\n        //            CampaignId = campaignId,\n        //            CampaignRecipientId = r.Id,\n        //            IdempotencyKey = r.IdempotencyKey\n        //        });\n        //    }\n\n        //    // 5) Enqueue (no-op adapter will just count)\n        //    var enqueued = await _queue.EnqueueBulkAsync(jobs, ct);\n\n        //    // --- Prepare response ---\n\n        //    // Fetch phones for the sample (phone is on AudienceMember, not CampaignRecipient)\n        //    var memberIds = candidates\n        //        .Where(r => r.AudienceMemberId.HasValue)\n        //        .Select(r => r.AudienceMemberId!.Value)\n        //        .Distinct()\n        //        .ToList();\n\n        //    var phoneByMemberId = await _db.AudiencesMembers.AsNoTracking()\n        //        .Where(m => m.BusinessId == businessId && memberIds.Contains(m.Id))\n        //        .Select(m => new { m.Id, m.PhoneE164 })\n        //        .ToDictionaryAsync(x => x.Id, x => x.PhoneE164, ct);\n\n        //    var resp = new CampaignDispatchResponseDto\n        //    {\n        //        CampaignId = campaignId,\n        //        Mode = mode,\n        //        RequestedCount = count,\n        //        SelectedCount = candidates.Count,\n        //        EnqueuedCount = enqueued,\n        //        Sample = candidates\n        //            .Take(10)\n        //            .Select(r => new DispatchedRecipientDto\n        //            {\n        //                RecipientId = r.Id,\n        //                Phone = (r.AudienceMemberId.HasValue &&\n        //                         phoneByMemberId.TryGetValue(r.AudienceMemberId.Value, out var p))\n        //                            ? p\n        //                            : null,\n        //                Status = r.Status,\n        //                MaterializedAt = r.MaterializedAt,\n        //                IdempotencyKey = r.IdempotencyKey\n        //            })\n        //            .ToList()\n        //    };\n\n        //    if (mode == \"full\")\n        //    {\n        //        resp.Warnings.Add(\"Full dispatch requested; rate limiting/backoff is enforced by the worker/queue.\");\n        //    }\n\n        //    Log.Information(\"Dispatch queued {@Summary}\", new\n        //    {\n        //        businessId,\n        //        campaignId,\n        //        mode,\n        //        requested = count,\n        //        selected = candidates.Count,\n        //        enqueued\n        //    });\n\n        //    return resp;\n        //}\n\n        public async Task<CampaignDispatchResponseDto> DispatchAsync(\n    Guid businessId,\n    Guid campaignId,\n    string mode,\n    int count,\n    CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required.\");\n\n            mode = (mode ?? \"canary\").Trim().ToLowerInvariant();\n            if (mode != \"canary\" && mode != \"full\") mode = \"canary\";\n            if (count <= 0) count = 25;\n\n            var owns = await _db.Campaigns.AsNoTracking()\n                .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n            if (!owns) throw new UnauthorizedAccessException(\"Campaign not found or not owned by this business.\");\n\n            var baseQuery = _db.CampaignRecipients.AsNoTracking()\n                .Where(r => r.BusinessId == businessId\n                         && r.CampaignId == campaignId\n                         && r.MaterializedAt != null\n                         && ReadyStatuses.Contains(r.Status))\n                .OrderBy(r => r.MaterializedAt).ThenBy(r => r.Id);\n\n            var desired = mode == \"canary\" ? count : int.MaxValue;\n            var take = Math.Min(desired * 2, 5000);\n            var candidates = await baseQuery.Take(take).ToListAsync(ct);\n\n            var jobs = new List<OutboundCampaignJobCreateDto>(candidates.Count);\n            foreach (var r in candidates)\n            {\n                jobs.Add(new OutboundCampaignJobCreateDto\n                {\n                    BusinessId = businessId,\n                    CampaignId = campaignId,\n                    CampaignRecipientId = r.Id,\n                    IdempotencyKey = r.IdempotencyKey\n                });\n            }\n            var enqueued = await _queue.EnqueueBulkAsync(jobs, ct);\n\n            // ---- CHANGED: AudienceMemberId is Guid (non-nullable)\n            //var memberIds = candidates\n            //    .Select(r => r.AudienceMemberId)\n            //    .Distinct()\n            //    .ToHashSet(); // perf for Contains\n\n            var memberIds = candidates\n    .Where(r => r.AudienceMemberId.HasValue)\n    .Select(r => r.AudienceMemberId!.Value)\n    .Distinct()\n    .ToHashSet();\n\n            var phoneByMemberId = await _db.AudiencesMembers   // or _db.AudiencesMembers if that's your DbSet\n      .AsNoTracking()\n      .Where(m => m.BusinessId == businessId && memberIds.Contains(m.Id))\n      .Select(m => new { m.Id, m.PhoneE164 })\n      .ToDictionaryAsync(x => x.Id, x => x.PhoneE164, ct);\n\n            var resp = new CampaignDispatchResponseDto\n            {\n                CampaignId = campaignId,\n                Mode = mode,\n                RequestedCount = count,\n                SelectedCount = candidates.Count,\n                EnqueuedCount = enqueued,\n                Sample = candidates\n                .Take(10)\n                .Select(r => new DispatchedRecipientDto\n                {\n                    RecipientId = r.Id,\n                    Phone = (r.AudienceMemberId.HasValue &&\n                             phoneByMemberId.TryGetValue(r.AudienceMemberId.Value, out var p))\n                                ? p\n                                : null,\n                    Status = r.Status,\n                    MaterializedAt = r.MaterializedAt,\n                    IdempotencyKey = r.IdempotencyKey\n                })\n                .ToList()\n            };\n\n            if (mode == \"full\")\n                resp.Warnings.Add(\"Full dispatch requested; rate limiting/backoff is enforced by the worker/queue.\");\n\n            Log.Information(\"Dispatch queued {@Summary}\", new { businessId, campaignId, mode, requested = count, selected = candidates.Count, enqueued });\n            return resp;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignDispatchPlannerService.cs",
      "sha256": "fe613afed24f76c48409b379b1e82e36e259c41afe57aacb1122ace6dff1ea83",
      "language": "csharp",
      "size": 8973,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignDispatchPlannerService\n    {\n        /// <summary>\n        /// Build a read-only dispatch plan: batches, offsets, size estimates, and throttle summary.\n        /// No messages are sent and no DB writes are performed.\n        /// </summary>\n        Task<CampaignDispatchPlanResultDto> PlanAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default);\n    }\n\n    /// <summary>\n    /// Computes batch plan from materialized rows with simple throttling:\n    /// - Derives batch size and per-minute cap from Business.Plan (fallback defaults).\n    /// - Slices rows into batches and schedules offsets (seconds) so per-minute cap is respected.\n    /// - Approximates payload size per row/batch for sanity checks.\n    /// </summary>\n    public class CampaignDispatchPlannerService : ICampaignDispatchPlannerService\n    {\n        private readonly AppDbContext _db;\n        private readonly ICampaignMaterializationService _materializer;\n\n        public CampaignDispatchPlannerService(AppDbContext db, ICampaignMaterializationService materializer)\n        {\n            _db = db;\n            _materializer = materializer;\n        }\n\n        public async Task<CampaignDispatchPlanResultDto> PlanAsync(Guid businessId, Guid campaignId, int limit = 2000, CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"CampaignId is required.\");\n\n            // Load campaign shell for meta\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct)\n                ?? throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Materialize (reuses Step 2.11) — read-only\n            var mat = await _materializer.MaterializeAsync(businessId, campaignId, limit, ct);\n\n            // Business plan & provider heuristics (non-fatal if missing)\n            var biz = await _db.Businesses\n                .AsNoTracking()\n                .FirstOrDefaultAsync(b => b.Id == businessId, ct);\n\n            // var planName = (biz?.Plan ?? \"Basic\").Trim();\n            var planName = (biz == null\n     ? \"Basic\"\n     : (biz.Plan?.ToString() ?? \"Basic\")\n ).Trim();\n            var provider = (campaign.Provider ?? \"Auto\").Trim(); // if you snapshot provider on Campaign; otherwise \"Auto\"\n\n            // Throttle rules (sane defaults; adjust to your real plan matrix if available)\n            var (maxBatch, perMinute) = GetThrottleForPlan(planName);\n\n            var result = new CampaignDispatchPlanResultDto\n            {\n                CampaignId = campaignId,\n                TemplateName = mat.TemplateName,\n                Language = mat.Language,\n                PlaceholderCount = mat.PlaceholderCount,\n                TotalRecipients = mat.Rows.Count,\n                Throttle = new DispatchThrottleDto\n                {\n                    Plan = planName,\n                    Provider = provider,\n                    MaxBatchSize = maxBatch,\n                    MaxPerMinute = perMinute\n                }\n            };\n\n            if (mat.Rows.Count == 0)\n            {\n                result.GlobalWarnings.Add(\"No recipients available to plan. Ensure audience or campaign recipients exist.\");\n                result.WarningCount = result.GlobalWarnings.Count;\n                return result;\n            }\n\n            // Approx size per row (naive): sum of parameter lengths + resolved button urls + a small fixed header cost\n            var approxBytesPerRow = new List<int>(mat.Rows.Count);\n            foreach (var row in mat.Rows)\n            {\n                var paramBytes = row.Parameters.Sum(p => (p.Value?.Length ?? 0));\n                var btnBytes = row.Buttons.Sum(b => (b.ResolvedUrl?.Length ?? 0) + (b.ButtonText?.Length ?? 0));\n                // add a tiny constant for template envelope; tweak if you maintain captions/text\n                var approx = (paramBytes + btnBytes + 64);\n                approxBytesPerRow.Add(approx);\n            }\n\n            result.TotalApproxBytes = approxBytesPerRow.Sum();\n\n            // Build batches by MaxBatchSize\n            var batches = new List<DispatchBatchDto>();\n            var total = mat.Rows.Count;\n            var batchCount = (int)Math.Ceiling(total / (double)maxBatch);\n\n            // Schedule offsets constrained by MaxPerMinute:\n            // At most 'perMinute' messages may start within any 60-second window.\n            // Strategy: bucket batches into \"minutes\", each minute can hold floor(perMinute / maxBatch) full batches.\n            var batchesPerMinute = Math.Max(1, perMinute / Math.Max(1, maxBatch));\n            if (batchesPerMinute == 0) batchesPerMinute = 1; // guard\n\n            var offsetMinutes = 0;\n            var slotInMinute = 0;\n            int globalIdx = 0;\n\n            for (int b = 0; b < batchCount; b++)\n            {\n                var startIndex = b * maxBatch;\n                var take = Math.Min(maxBatch, total - startIndex);\n\n                var slicePhones = new List<string?>(take);\n                var sliceRecipientIds = new List<Guid?>(take);\n                var sliceApprox = 0;\n\n                for (int i = 0; i < take; i++)\n                {\n                    var row = mat.Rows[startIndex + i];\n                    slicePhones.Add(row.Phone);\n                    sliceRecipientIds.Add(row.RecipientId);\n                    sliceApprox += approxBytesPerRow[startIndex + i];\n                }\n\n                var batch = new DispatchBatchDto\n                {\n                    BatchNumber = b + 1,\n                    StartIndex = startIndex,\n                    Count = take,\n                    ApproxBytes = sliceApprox,\n                    RecipientIds = sliceRecipientIds,\n                    Phones = slicePhones,\n                    OffsetSeconds = offsetMinutes * 60\n                };\n\n                // Notes for the curious\n                if (slicePhones.Any(p => string.IsNullOrWhiteSpace(p)))\n                    batch.Notes.Add(\"Some rows missing phone; those will fail at send-time unless corrected.\");\n                if (sliceApprox / Math.Max(1, take) > 2000)\n                    batch.Notes.Add(\"Average payload per row is large; provider truncation risk.\");\n\n                batches.Add(batch);\n\n                // advance slot & minute window\n                slotInMinute++;\n                if (slotInMinute >= batchesPerMinute)\n                {\n                    slotInMinute = 0;\n                    offsetMinutes++;\n                }\n\n                globalIdx += take;\n            }\n\n            result.Batches = batches;\n            result.Throttle.ComputedBatches = batches.Count;\n            // Estimated minutes: ceil(total recipients / perMinute)\n            result.Throttle.EstimatedMinutes = (int)Math.Ceiling(total / (double)Math.Max(1, perMinute));\n\n            // Warnings\n            if (perMinute < 30) result.Throttle.Warnings.Add(\"Low per-minute limit; delivery may be slow for large audiences.\");\n            if (result.TotalApproxBytes > 5_000_000) result.GlobalWarnings.Add(\"Plan size is large (>5MB). Consider splitting the audience.\");\n\n            result.WarningCount =\n                result.GlobalWarnings.Count +\n                result.Throttle.Warnings.Count +\n                result.Batches.Sum(bh => bh.Notes.Count);\n\n            Log.Information(\"Dispatch plan computed {@PlanSummary}\",\n                new\n                {\n                    campaignId,\n                    businessId,\n                    mat.TemplateName,\n                    mat.Language,\n                    totalRecipients = result.TotalRecipients,\n                    batches = result.Batches.Count,\n                    perMinute,\n                    maxBatch,\n                    estMinutes = result.Throttle.EstimatedMinutes\n                });\n\n            return result;\n        }\n\n        private static (int maxBatch, int perMinute) GetThrottleForPlan(string planName)\n        {\n            // Conservative defaults; align with your real billing/plan matrix when available.\n            switch ((planName ?? \"\").Trim().ToLowerInvariant())\n            {\n                case \"advanced\":\n                    return (100, 600);\n                case \"smart\":\n                    return (50, 300);\n                case \"basic\":\n                default:\n                    return (25, 120);\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignDryRunService.cs",
      "sha256": "7951a4dbf036d9ec05750278c322b32b635d8135cb7a51d75748e0ac3f1a0d0a",
      "language": "csharp",
      "size": 9184,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Shared.utility;\nusing xbytechat.api.WhatsAppSettings.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// Dry-run validator for campaigns. Checks template existence, parameter counts,\n    /// dynamic button placeholders, and recipient phone presence/shape.\n    /// </summary>\n    public class CampaignDryRunService : ICampaignDryRunService\n    {\n        private readonly AppDbContext _db;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n\n        private static readonly Regex PlaceholderRe = new(@\"\\{\\{\\s*(\\d+)\\s*\\}\\}\", RegexOptions.Compiled);\n\n        public CampaignDryRunService(AppDbContext db, IWhatsAppTemplateFetcherService templateFetcher)\n        {\n            _db = db;\n            _templateFetcher = templateFetcher;\n        }\n\n        public async Task<CampaignDryRunResultDto> ValidateAsync(\n            Guid businessId,\n            Guid campaignId,\n            int limit = 200,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required.\");\n\n            // Load campaign + recipients(+contacts) + variable maps + buttons (read-only)\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .Include(c => c.MultiButtons)\n                .Include(c => c.VariableMaps)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n\n            if (campaign == null)\n                throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Recipients (contact needed for phone)\n            var recipients = await _db.CampaignRecipients\n                .AsNoTracking()\n                .Include(r => r.Contact)\n                .Where(r => r.CampaignId == campaignId && r.BusinessId == businessId)\n                .OrderBy(r => r.UpdatedAt)\n                .Take(limit)\n                .ToListAsync(ct);\n\n            // Determine template name (prefer TemplateId → MessageTemplate) and fetch metadata\n            var templateName = (campaign.TemplateId ?? campaign.MessageTemplate ?? \"\").Trim();\n            if (string.IsNullOrWhiteSpace(templateName))\n            {\n                // No template at all — return result with a single global error across all recipients\n                return BuildResult(\n                    campaignId,\n                    templateName: \"\",\n                    language: \"en_US\",\n                    placeholderCount: 0,\n                    recipients: recipients,\n                    globalError: \"Template name is missing on campaign.\"\n                );\n            }\n\n            var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n            if (meta == null)\n            {\n                return BuildResult(\n                    campaignId,\n                    templateName,\n                    language: \"en_US\",\n                    placeholderCount: 0,\n                    recipients: recipients,\n                    globalError: $\"Template '{templateName}' not found for business.\"\n                );\n            }\n\n            var language = (meta.Language ?? \"en_US\").Trim();\n            var placeholderCount = Math.Max(0, meta.PlaceholderCount);\n\n            // Campaign-stored parameters: if supplied, compare counts\n            var storedParams = TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters);\n            bool paramCountMismatch = storedParams.Count > 0 && storedParams.Count != placeholderCount;\n\n            // Validate buttons for dynamic placeholders ({{n}})\n            var dynamicButtonIssues = new List<string>();\n            var buttonPlaceholdersNeeded = new HashSet<int>();\n\n            foreach (var b in (campaign.MultiButtons ?? Enumerable.Empty<CampaignButton>()))\n            {\n                var value = b.Value ?? \"\";\n                foreach (Match m in PlaceholderRe.Matches(value))\n                {\n                    if (int.TryParse(m.Groups[1].Value, out var n))\n                    {\n                        buttonPlaceholdersNeeded.Add(n);\n                    }\n                }\n            }\n\n            foreach (var n in buttonPlaceholdersNeeded)\n            {\n                if (storedParams.Count > 0 && (n < 1 || n > storedParams.Count))\n                {\n                    dynamicButtonIssues.Add($\"Button needs placeholder {{%{n}%}} but campaign parameters only provide {storedParams.Count} value(s).\");\n                }\n                if (placeholderCount > 0 && (n < 1 || n > placeholderCount))\n                {\n                    dynamicButtonIssues.Add($\"Button needs placeholder {{%{n}%}} but template defines only {placeholderCount} placeholder(s).\");\n                }\n            }\n\n            // Build per-recipient issues\n            var issues = new List<CampaignDryRunIssueDto>();\n            foreach (var r in recipients)\n            {\n                var phone = r.Contact?.PhoneNumber?.Trim();\n\n                if (string.IsNullOrWhiteSpace(phone))\n                {\n                    issues.Add(new CampaignDryRunIssueDto\n                    {\n                        RecipientId = r.Id,\n                        ContactId = r.ContactId,\n                        Phone = phone,\n                        Severity = \"error\",\n                        Message = \"Phone is missing.\"\n                    });\n                }\n                else if (!IsLikelyPhone(phone))\n                {\n                    issues.Add(new CampaignDryRunIssueDto\n                    {\n                        RecipientId = r.Id,\n                        ContactId = r.ContactId,\n                        Phone = phone,\n                        Severity = \"warning\",\n                        Message = \"Phone format looks unusual.\"\n                    });\n                }\n            }\n\n            // Add global-ish issues once (we’ll attribute them to a null recipient)\n            if (paramCountMismatch)\n            {\n                issues.Add(new CampaignDryRunIssueDto\n                {\n                    Severity = \"warning\",\n                    Message = $\"Placeholder count mismatch: template expects {placeholderCount}, campaign provided {storedParams.Count}.\",\n                });\n            }\n\n            foreach (var bi in dynamicButtonIssues.Distinct())\n            {\n                issues.Add(new CampaignDryRunIssueDto\n                {\n                    Severity = \"error\",\n                    Message = bi\n                });\n            }\n\n            var result = new CampaignDryRunResultDto\n            {\n                CampaignId = campaignId,\n                TemplateName = templateName,\n                Language = language,\n                PlaceholderCount = placeholderCount,\n                CheckedRecipients = recipients.Count,\n                Issues = issues,\n                ErrorCount = issues.Count(i => string.Equals(i.Severity, \"error\", StringComparison.OrdinalIgnoreCase)),\n                WarningCount = issues.Count(i => string.Equals(i.Severity, \"warning\", StringComparison.OrdinalIgnoreCase)),\n            };\n\n            Log.Information(\"Dry-run completed for Campaign {CampaignId} (biz {BusinessId}) → {Errors} errors, {Warnings} warnings over {Checked} recipients\",\n                campaignId, businessId, result.ErrorCount, result.WarningCount, result.CheckedRecipients);\n\n            return result;\n        }\n\n        private static CampaignDryRunResultDto BuildResult(\n            Guid campaignId,\n            string templateName,\n            string language,\n            int placeholderCount,\n            List<CampaignRecipient> recipients,\n            string globalError)\n        {\n            var issues = new List<CampaignDryRunIssueDto>\n            {\n                new CampaignDryRunIssueDto\n                {\n                    Severity = \"error\",\n                    Message = globalError\n                }\n            };\n\n            return new CampaignDryRunResultDto\n            {\n                CampaignId = campaignId,\n                TemplateName = templateName,\n                Language = language,\n                PlaceholderCount = placeholderCount,\n                CheckedRecipients = recipients.Count,\n                Issues = issues,\n                ErrorCount = issues.Count,\n                WarningCount = 0\n            };\n        }\n\n        private static bool IsLikelyPhone(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return false;\n            var digits = s.Count(char.IsDigit);\n            return digits >= 10 && digits <= 15;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignMaterializationService.cs",
      "sha256": "b58fa41286a66c300d53a0970a190a27616e1f35418a2bf573222fded88b4670",
      "language": "csharp",
      "size": 20907,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.WhatsAppSettings.Services; // ensure namespace matches your project\nusing xbytechat.api.Features.MessageManagement.Services;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.WhatsAppSettings.DTOs; // IUrlBuilderService\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    \n\n    /// <summary>\n    /// Read-only “compiler” that materializes template params and button URLs per recipient.\n    /// Mirrors the live send behavior (no dispatch, no DB writes).\n    /// </summary>\n    public sealed class CampaignMaterializationService : ICampaignMaterializationService\n    {\n        private readonly AppDbContext _db;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n        private readonly IUrlBuilderService _urlBuilderService;\n\n        private static readonly Regex PlaceholderRe = new(@\"\\{\\{\\s*(\\d+)\\s*\\}\\}\", RegexOptions.Compiled);\n\n        public CampaignMaterializationService(\n            AppDbContext db,\n            IWhatsAppTemplateFetcherService templateFetcher,\n            IUrlBuilderService urlBuilderService)\n        {\n            _db = db;\n            _templateFetcher = templateFetcher;\n            _urlBuilderService = urlBuilderService;\n        }\n\n        public async Task<CampaignMaterializeResultDto> MaterializeAsync(\n            Guid businessId,\n            Guid campaignId,\n            int limit = 200,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required\");\n            if (limit <= 0) limit = 200;\n\n            // Load campaign + variable maps + buttons + recipients (+ contacts)\n            var campaign = await _db.Campaigns\n                .AsNoTracking()\n                .Include(c => c.VariableMaps)\n                .Include(c => c.MultiButtons)\n                .Include(c => c.Recipients).ThenInclude(r => r.Contact)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n\n            if (campaign == null)\n                throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Resolve template meta from snapshot/params; fallback to live\n            var meta = await ResolveTemplateMetaAsync(campaign, businessId, ct);\n            var templateName = meta.TemplateName;\n            var language = meta.Language;\n            var placeholderCount = meta.PlaceholderCount;\n\n            if (string.IsNullOrWhiteSpace(templateName))\n                throw new InvalidOperationException(\"Campaign does not have a resolvable template name.\");\n\n            // Try to fetch provider button meta (for dynamic URL detection & alignment)\n            TemplateMetadataDto? liveMeta = null;\n            try\n            {\n                liveMeta = await _templateFetcher.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n            }\n            catch (Exception ex)\n            {\n                Log.Warning(ex, \"Template fetch failed during materialization for {Template}\", templateName);\n            }\n\n            var result = new CampaignMaterializeResultDto\n            {\n                CampaignId = campaignId,\n                TemplateName = templateName,\n                Language = language,\n                PlaceholderCount = placeholderCount\n            };\n\n            var varMaps = (campaign.VariableMaps ?? new List<CampaignVariableMap>())\n                .Where(m => m.CampaignId == campaignId)\n                .ToList();\n\n            var recipients = (campaign.Recipients ?? new List<CampaignRecipient>())\n                .OrderBy(r => r.UpdatedAt)\n                .Take(limit)\n                .ToList();\n\n            // order buttons by Position (then by their original index) to align with template button index\n            var orderedButtons = (campaign.MultiButtons ?? new List<CampaignButton>())\n                .Select((b, idx) => new { Btn = b, idx })\n                .OrderBy(x => (int?)x.Btn.Position ?? int.MaxValue)\n                .ThenBy(x => x.idx)\n                .Select(x => x.Btn)\n                .ToList();\n\n            foreach (var r in recipients)\n            {\n                var row = new MaterializedRecipientDto\n                {\n                    RecipientId = r.Id,\n                    ContactId = r.ContactId,\n                    Phone = NormalizePhone(r?.Contact?.PhoneNumber)\n                };\n\n                // Parameters 1..N via variable maps (Static/Default/Expression placeholder)\n                for (int idx = 1; idx <= placeholderCount; idx++)\n                {\n                    var map = varMaps.FirstOrDefault(m => m.Index == idx);\n                    if (map == null)\n                    {\n                        row.Parameters.Add(new TemplateParamResolutionDto\n                        {\n                            Index = idx,\n                            Value = null,\n                            IsMissing = true,\n                            SourceType = \"Unmapped\",\n                            Note = \"No variable map for this placeholder.\"\n                        });\n                        continue;\n                    }\n\n                    var (value, isMissing, note) = ResolveValue(map, r);\n                    row.Parameters.Add(new TemplateParamResolutionDto\n                    {\n                        Index = idx,\n                        Value = value,\n                        IsMissing = isMissing,\n                        SourceType = map.SourceType ?? string.Empty,\n                        SourceKey = map.SourceKey\n                    });\n\n                    if (!string.IsNullOrWhiteSpace(note))\n                        row.Warnings.Add($\"{{{{{idx}}}}}: {note}\");\n                }\n\n                // Buttons: mirror live send behavior for dynamic URL buttons (index 0..2)\n                if (liveMeta?.ButtonParams != null && liveMeta.ButtonParams.Count > 0 && orderedButtons.Count > 0)\n                {\n                    var total = Math.Min(3, Math.Min(orderedButtons.Count, liveMeta.ButtonParams.Count));\n\n                    for (int i = 0; i < total; i++)\n                    {\n                        var metaBtn = liveMeta.ButtonParams[i];\n                        var subType = (metaBtn.SubType ?? \"url\").ToLowerInvariant();\n                        var metaParam = metaBtn.ParameterValue?.Trim();\n\n                        var br = new ButtonResolutionDto\n                        {\n                            ButtonText = orderedButtons[i]?.Title ?? string.Empty,\n                            RawTemplateValue = orderedButtons[i]?.Value\n                        };\n\n                        // We only handle dynamic URL buttons here (consistent with send logic)\n                        if (!string.Equals(subType, \"url\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            br.Notes.Add(\"Non-URL button (no dynamic resolution).\");\n                            row.Buttons.Add(br);\n                            continue;\n                        }\n\n                        var isDynamic = !string.IsNullOrWhiteSpace(metaParam) && metaParam.Contains(\"{{\");\n                        if (!isDynamic)\n                        {\n                            br.Notes.Add(\"Static URL button (no parameters required by template).\");\n                            row.Buttons.Add(br);\n                            continue;\n                        }\n\n                        var btn = orderedButtons[i];\n                        var btnType = (btn?.Type ?? \"URL\").ToUpperInvariant();\n                        if (!string.Equals(btnType, \"URL\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            br.Notes.Add($\"Template expects a dynamic URL at index {i}, but campaign button type is '{btn?.Type}'.\");\n                            row.Buttons.Add(br);\n                            continue;\n                        }\n\n                        var valueRaw = btn?.Value?.Trim();\n                        if (string.IsNullOrWhiteSpace(valueRaw))\n                        {\n                            br.Notes.Add($\"Template requires a dynamic URL at index {i}, but campaign button value is empty.\");\n                            br.MissingArguments.Add(\"{{1}}\");\n                            row.Buttons.Add(br);\n                            continue;\n                        }\n\n                        // optional phone substitution into destination\n                        var phone = row.Phone ?? \"\";\n                        var encodedPhone = Uri.EscapeDataString(phone);\n\n                        var resolvedDestination = valueRaw.Contains(\"{{1}}\")\n                            ? valueRaw.Replace(\"{{1}}\", encodedPhone)\n                            : valueRaw;\n\n                        // normalize/validate URL (allow tel:, wa:, wa.me links)\n                        try\n                        {\n                            resolvedDestination = NormalizeAbsoluteUrlOrThrowForButton(resolvedDestination, btn!.Title ?? $\"Button {i + 1}\", i);\n                        }\n                        catch (Exception ex)\n                        {\n                            br.Notes.Add($\"Destination invalid: {ex.Message}\");\n                            row.Buttons.Add(br);\n                            continue;\n                        }\n\n                        // Build both styles and pick based on template absolute base rule\n                        var fakeSendLogId = Guid.NewGuid(); // preview-only tokenization\n                        var fullTrackedUrl = _urlBuilderService.BuildTrackedButtonUrl(\n                            fakeSendLogId, i, btn!.Title, resolvedDestination);\n\n                        var tokenParam = BuildTokenParam(fakeSendLogId, i, btn.Title, resolvedDestination);\n\n                        var templateHasAbsoluteBase = LooksLikeAbsoluteBaseUrlWithPlaceholder(metaParam);\n                        var valueToSend = templateHasAbsoluteBase ? tokenParam : fullTrackedUrl;\n\n                        br.UsedPlaceholders.Add(\"{{1}}\"); // meta indicates dynamic\n                        br.ResolvedUrl = valueToSend;\n                        row.Buttons.Add(br);\n                    }\n                }\n                else\n                {\n                    // no dynamic buttons in template\n                }\n\n                // Basic phone sanity\n                if (string.IsNullOrWhiteSpace(row.Phone))\n                    row.Errors.Add(\"Phone is missing.\");\n                else if (!IsLikelyPhone(row.Phone))\n                    row.Warnings.Add(\"Phone format looks unusual.\");\n\n                result.Rows.Add(row);\n            }\n\n            result.ReturnedCount = result.Rows.Count;\n            result.ErrorCount = result.Rows.Sum(r => r.Errors.Count);\n            result.WarningCount = result.Rows.Sum(r => r.Warnings.Count)\n                                  + result.Rows.Sum(r => r.Parameters.Count(p => p.IsMissing));\n\n            Log.Information(\"Campaign materialization computed {@Summary}\",\n                new\n                {\n                    campaignId,\n                    businessId,\n                    result.ReturnedCount,\n                    result.ErrorCount,\n                    result.WarningCount,\n                    result.PlaceholderCount,\n                    result.TemplateName,\n                    result.Language\n                });\n\n            return result;\n        }\n\n        // --- Helpers (mirror your send logic where relevant) ---\n\n        private static (string? value, bool isMissing, string? note) ResolveValue(\n            CampaignVariableMap map,\n            CampaignRecipient recipient)\n        {\n            var source = (map.SourceType ?? \"\").Trim();\n\n            switch (source)\n            {\n                case \"Static\":\n                    {\n                        var v = map.StaticValue;\n                        var missing = string.IsNullOrWhiteSpace(v) && map.IsRequired;\n                        return (v, missing, missing ? \"Required static value missing.\" : null);\n                    }\n\n                case \"Expression\":\n                    {\n                        // no eval engine; use DefaultValue if provided\n                        var v = map.DefaultValue;\n                        var note = \"Expression present; no evaluation engine configured. Used DefaultValue.\";\n                        var missing = string.IsNullOrWhiteSpace(v) && map.IsRequired;\n                        return (v, missing, missing ? \"Required expression result missing (no default provided).\" : note);\n                    }\n\n                case \"AudienceColumn\":\n                    {\n                        // Current CampaignRecipient shape doesn't carry Audience/CSV row data.\n                        // If you later link AudienceMember.AttributesJson here, resolve from it.\n                        var v = map.DefaultValue;\n                        var missing = string.IsNullOrWhiteSpace(v) && map.IsRequired;\n                        return (v, missing, \"Audience/CSV source not available on CampaignRecipient; used DefaultValue.\");\n                    }\n\n                default:\n                    {\n                        var v = map.DefaultValue;\n                        var missing = string.IsNullOrWhiteSpace(v) && map.IsRequired;\n                        return (v, missing, missing ? \"Unrecognized mapping type and no default.\" : \"Unrecognized mapping type; used DefaultValue.\");\n                    }\n            }\n        }\n\n        private static string NormalizePhone(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return \"\";\n            var p = raw.Trim();\n            if (!p.StartsWith(\"+\")) p = \"+\" + new string(p.Where(char.IsDigit).ToArray());\n            return p;\n        }\n\n        private static bool IsLikelyPhone(string? s)\n        {\n            if (string.IsNullOrWhiteSpace(s)) return false;\n            var digits = s.Count(char.IsDigit);\n            return digits >= 10 && digits <= 15;\n        }\n\n        private static string NormalizeAbsoluteUrlOrThrowForButton(string input, string buttonTitle, int buttonIndex)\n        {\n            if (string.IsNullOrWhiteSpace(input))\n                throw new ArgumentException($\"Destination is required for button '{buttonTitle}' (index {buttonIndex}).\");\n\n            var cleaned = new string(input.Trim().Where(c => !char.IsControl(c)).ToArray());\n            if (cleaned.Length == 0)\n                throw new ArgumentException($\"Destination is required for button '{buttonTitle}' (index {buttonIndex}).\");\n\n            // Accept tel: / wa: / wa.me deep links\n            if (cleaned.StartsWith(\"tel:\", StringComparison.OrdinalIgnoreCase) ||\n                cleaned.StartsWith(\"wa:\", StringComparison.OrdinalIgnoreCase) ||\n                cleaned.StartsWith(\"https://wa.me/\", StringComparison.OrdinalIgnoreCase))\n            {\n                return cleaned;\n            }\n\n            if (Uri.TryCreate(cleaned, UriKind.Absolute, out var uri) &&\n                (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                 uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase)))\n            {\n                return uri.ToString();\n            }\n\n            throw new ArgumentException(\n                $\"Destination must be an absolute http/https/tel/wa URL for button '{buttonTitle}' (index {buttonIndex}). Got: '{input}'\");\n        }\n\n        private static bool LooksLikeAbsoluteBaseUrlWithPlaceholder(string? templateUrl)\n        {\n            if (string.IsNullOrWhiteSpace(templateUrl)) return false;\n            var s = templateUrl.Trim();\n            if (!s.Contains(\"{{\")) return false;\n            var probe = s.Replace(\"{{1}}\", \"x\").Replace(\"{{0}}\", \"x\");\n            return Uri.TryCreate(probe, UriKind.Absolute, out var abs) &&\n                   (abs.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                    abs.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase));\n        }\n\n        private string BuildTokenParam(Guid campaignSendLogId, int buttonIndex, string? buttonTitle, string destinationUrlAbsolute)\n        {\n            var full = _urlBuilderService.BuildTrackedButtonUrl(campaignSendLogId, buttonIndex, buttonTitle, destinationUrlAbsolute);\n            var pos = full.LastIndexOf(\"/r/\", StringComparison.OrdinalIgnoreCase);\n            return (pos >= 0) ? full[(pos + 3)..] : full;\n        }\n\n        private sealed record ResolvedTemplateMeta(string TemplateName, string Language, int PlaceholderCount);\n\n        // ...inside CampaignMaterializationService class\n\n        private static int CountPlaceholders(string? text)\n        {\n            if (string.IsNullOrWhiteSpace(text)) return 0;\n            // matches {{1}}, {{ 2 }}, etc.\n            return Regex.Matches(text, @\"\\{\\{\\s*\\d+\\s*\\}\\}\").Count;\n        }\n\n        private async Task<ResolvedTemplateMeta> ResolveTemplateMetaAsync(\n            Campaign campaign,\n            Guid businessId,\n            CancellationToken ct)\n        {\n            string templateName = string.Empty;\n            string language = \"en\";\n            int placeholderCount = 0;\n\n            // 1) Snapshot first (if stored)\n            if (!string.IsNullOrWhiteSpace(campaign.TemplateSchemaSnapshot))\n            {\n                try\n                {\n                    using var doc = JsonDocument.Parse(campaign.TemplateSchemaSnapshot);\n                    var root = doc.RootElement;\n\n                    if (root.TryGetProperty(\"name\", out var n) && n.ValueKind == JsonValueKind.String)\n                        templateName = n.GetString() ?? string.Empty;\n\n                    if (root.TryGetProperty(\"language\", out var l) && l.ValueKind == JsonValueKind.String)\n                        language = l.GetString() ?? \"en\";\n\n                    if (root.TryGetProperty(\"placeholderCount\", out var pc) && pc.TryGetInt32(out var snapCount))\n                        placeholderCount = snapCount;\n                }\n                catch { /* non-fatal */ }\n            }\n\n            // 2) Prefer stored TemplateParameters count if present\n            if (!string.IsNullOrWhiteSpace(campaign.TemplateParameters))\n            {\n                try\n                {\n                    var arr = JsonSerializer.Deserialize<List<string>>(campaign.TemplateParameters) ?? new();\n                    placeholderCount = Math.Max(placeholderCount, arr.Count);\n                }\n                catch { /* ignore bad param JSON */ }\n            }\n\n            // 3) If name still missing, use MessageTemplate as canonical name (fall back to TemplateId)\n            if (string.IsNullOrWhiteSpace(templateName))\n                templateName = campaign.MessageTemplate ?? campaign.TemplateId ?? string.Empty;\n\n            // 4) Fallback to live metadata if essentials missing\n            if (placeholderCount <= 0 || string.IsNullOrWhiteSpace(templateName))\n            {\n                try\n                {\n                    var live = await _templateFetcher.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n                    if (live != null)\n                    {\n                        if (string.IsNullOrWhiteSpace(templateName) && !string.IsNullOrWhiteSpace(live.Name))\n                            templateName = live.Name!;\n                        if (!string.IsNullOrWhiteSpace(live.Language))\n                            language = live.Language!;\n\n                        // Your TemplateMetadataDto exposes PlaceholderCount and Body (no .Parameters)\n                        var liveCount = live.PlaceholderCount > 0\n                            ? live.PlaceholderCount\n                            : CountPlaceholders(live.Body);\n\n                        placeholderCount = Math.Max(placeholderCount, liveCount);\n                    }\n                }\n                catch (Exception ex)\n                {\n                    Log.Warning(ex, \"Live template meta fetch failed for {Template}/{Lang}\", templateName, language);\n                }\n            }\n\n            if (string.IsNullOrWhiteSpace(language)) language = \"en\";\n            if (placeholderCount < 0) placeholderCount = 0;\n\n            return new ResolvedTemplateMeta(templateName, language, placeholderCount);\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignMaterializer.cs",
      "sha256": "fe42a0c15b5bff77574cea20263a21868a0f07a8a4f465629a32ef129b8ab294",
      "language": "csharp",
      "size": 24005,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Security.Cryptography;\nusing System.Text;\nusing System.Text.Json;\nusing System.Text.RegularExpressions;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Helpers;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    /// <summary>\n    /// CSV-based materializer:\n    /// - Dry-run: validates + resolves variables/phones (no writes)\n    /// - Persist: creates Audience + AudienceMembers + CampaignRecipients with\n    ///   ResolvedParametersJson, ResolvedButtonUrlsJson, IdempotencyKey, MaterializedAt.\n    /// </summary>\n    public sealed class CampaignMaterializer : ICampaignMaterializer\n    {\n        private readonly AppDbContext _db;\n        private readonly IVariableResolver _resolver;\n\n        // Common phone header candidates (case-insensitive)\n        private static readonly string[] PhoneHeaderCandidates =\n        {\n            \"phone\", \"mobile\", \"whatsapp\", \"msisdn\", \"whatsapp_number\", \"contact\", \"contact_number\"\n        };\n\n        public CampaignMaterializer(AppDbContext db, IVariableResolver resolver)\n        {\n            _db = db;\n            _resolver = resolver;\n        }\n        // === NEW: infer mappings when FE did not send or sent partial mappings =========\n        private static Dictionary<string, string> BuildAutoMappingsFromRow(\n            IDictionary<string, string> rowDict,\n            int requiredBodySlots // 0 if unknown\n        )\n        {\n            // We will map to the variable keys your IVariableResolver expects:\n            //  - \"{{1}}\" -> CSV column name\n            //  - \"header.text_paramN\" -> CSV column\n            //  - \"buttonN.url_param\"  -> CSV column\n            var map = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            // 1) body: parameter1..N  -> {{1}}..{{N}}\n            // If N unknown, infer by scanning parameter\\d+ in row headers\n            int n = requiredBodySlots > 0\n                ? requiredBodySlots\n                : rowDict.Keys.Select(k =>\n                {\n                    var m = System.Text.RegularExpressions.Regex.Match(k, @\"^parameter(\\d+)$\", RegexOptions.IgnoreCase);\n                    return m.Success ? int.Parse(m.Groups[1].Value) : 0;\n                }).DefaultIfEmpty(0).Max();\n\n            for (int i = 1; i <= n; i++)\n            {\n                var csvHeader = rowDict.Keys.FirstOrDefault(k => string.Equals(k, $\"parameter{i}\", StringComparison.OrdinalIgnoreCase));\n                if (!string.IsNullOrWhiteSpace(csvHeader))\n                    map[$\"{{{{{i}}}}}\"] = csvHeader; // -> {{i}}\n            }\n\n            // 2) header text variables: headerparaN -> header.text_paramN\n            foreach (var kv in rowDict)\n            {\n                var m = System.Text.RegularExpressions.Regex.Match(kv.Key, @\"^headerpara(\\d+)$\", RegexOptions.IgnoreCase);\n                if (m.Success)\n                {\n                    var slot = int.Parse(m.Groups[1].Value);\n                    map[$\"header.text_param{slot}\"] = kv.Key;\n                }\n            }\n\n            // 3) dynamic URL buttons: buttonparaN -> buttonN.url_param\n            foreach (var kv in rowDict)\n            {\n                var m = System.Text.RegularExpressions.Regex.Match(kv.Key, @\"^buttonpara(\\d+)$\", RegexOptions.IgnoreCase);\n                if (m.Success)\n                {\n                    var pos = int.Parse(m.Groups[1].Value);\n                    if (pos >= 1 && pos <= 3)\n                        map[$\"button{pos}.url_param\"] = kv.Key;\n                }\n            }\n\n            return map;\n        }\n\n        // === NEW: read the template’s body placeholder count for strict enforcement ====\n        private async Task<int> GetRequiredBodySlotsAsync(Guid businessId, Guid campaignId, CancellationToken ct)\n        {\n            // Try reading campaign -> template name and then WhatsAppTemplates.PlaceholderCount\n            var data = await _db.Campaigns\n                .AsNoTracking()\n                .Where(c => c.Id == campaignId && c.BusinessId == businessId)\n                .Select(c => new { c.MessageTemplate, c.TemplateId })\n                .FirstOrDefaultAsync(ct);\n\n            var templateName = !string.IsNullOrWhiteSpace(data?.TemplateId)\n                ? data!.TemplateId!\n                : (data?.MessageTemplate ?? string.Empty);\n\n            if (string.IsNullOrWhiteSpace(templateName))\n                return 0;\n\n            // Use the most recent active row\n            var tpl = await _db.WhatsAppTemplates\n                .AsNoTracking()\n                .Where(t => t.BusinessId == businessId && t.IsActive && t.Name == templateName)\n                .OrderByDescending(t => t.UpdatedAt > t.CreatedAt ? t.UpdatedAt : t.CreatedAt)\n                .FirstOrDefaultAsync(ct);\n\n            return tpl?.PlaceholderCount ?? 0;\n        }\n\n        // === NEW: ensure body params are complete; return null when missing ============\n        private static string[]? EnsureBodyParamsComplete(string[] bodyParams, int requiredSlots, out List<string> missing)\n        {\n            missing = new List<string>();\n            if (requiredSlots <= 0) return bodyParams; // nothing to enforce\n\n            // Resize to requiredSlots\n            var arr = new string[requiredSlots];\n            for (int i = 0; i < requiredSlots; i++)\n            {\n                var v = (i < bodyParams.Length ? bodyParams[i] : string.Empty) ?? string.Empty;\n                arr[i] = v;\n                if (string.IsNullOrWhiteSpace(v))\n                    missing.Add($\"{{{{{i + 1}}}}}\");\n            }\n\n            if (missing.Count > 0)\n                return null;\n\n            return arr;\n        }\n\n        // File: Features/CampaignModule/Services/CampaignMaterializer.cs\n        // Method: CreateAsync(...)\n        // NOTE: This version is identical to yours except we pull `requiredBodySlots` ONCE before the foreach.\n        //       Everything else remains the same (including the enforcement you added).\n\n        public async Task<CampaignCsvMaterializeResponseDto> CreateAsync(\n            Guid businessId,\n            Guid campaignId,\n            CampaignCsvMaterializeRequestDto request,\n            CancellationToken ct = default)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"Invalid campaign id.\");\n            if (request is null) throw new ArgumentNullException(nameof(request));\n            if (request.CsvBatchId == Guid.Empty) throw new ArgumentException(\"CsvBatchId is required.\");\n            if (request.Persist && string.IsNullOrWhiteSpace(request.AudienceName))\n                throw new ArgumentException(\"AudienceName is required when Persist=true.\");\n\n            // Campaign ownership check\n            var owns = await _db.Campaigns\n                .AsNoTracking()\n                .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId, ct);\n            if (!owns) throw new UnauthorizedAccessException(\"Campaign not found or not owned by this business.\");\n\n            // Load CSV rows for the batch\n            var rowsQuery = _db.CsvRows\n                .AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.BatchId == request.CsvBatchId)\n                .OrderBy(r => r.RowIndex);\n\n            var totalRows = await rowsQuery.CountAsync(ct);\n            var csvRows = (request.Limit.HasValue && request.Limit.Value > 0)\n                ? await rowsQuery.Take(request.Limit.Value).ToListAsync(ct)\n                : await rowsQuery.ToListAsync(ct);\n\n            var resp = new CampaignCsvMaterializeResponseDto\n            {\n                CampaignId = campaignId,\n                CsvBatchId = request.CsvBatchId,\n                TotalRows = totalRows\n            };\n\n            // Build header set to help autodetect phone field\n            var headerSet = new HashSet<string>(StringComparer.OrdinalIgnoreCase);\n            foreach (var r in csvRows)\n            {\n                foreach (var k in JsonToDict(r.DataJson).Keys)\n                    headerSet.Add(k);\n            }\n\n            // Mapping precedence: request → fallback header==token\n            var effectiveMappings = request.Mappings ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n            // Determine phone field\n            var phoneField = request.PhoneField;\n            if (string.IsNullOrWhiteSpace(phoneField))\n                phoneField = PhoneHeaderCandidates.FirstOrDefault(headerSet.Contains);\n\n            if (string.IsNullOrWhiteSpace(phoneField))\n                resp.Warnings.Add(\"No phone field provided or detected; rows without phone will be skipped.\");\n\n            // 🔎 Pull required body slots ONCE (avoid N queries)\n            var requiredBodySlots = await GetRequiredBodySlotsAsync(businessId, campaignId, ct);\n\n            var seenPhones = new HashSet<string>(StringComparer.Ordinal);\n            var preview = resp.Preview; // alias\n\n            foreach (var row in csvRows)\n            {\n                ct.ThrowIfCancellationRequested();\n\n                var rowDict = JsonToDict(row.DataJson);\n                var m = new CsvMaterializedRowDto { RowIndex = row.RowIndex };\n\n                // 🧭 effective mappings: request.Mappings OR auto-infer from row\n                var mappingsToUse =\n                    (effectiveMappings != null && effectiveMappings.Count > 0)\n                        ? new Dictionary<string, string>(effectiveMappings, StringComparer.OrdinalIgnoreCase)\n                        : BuildAutoMappingsFromRow(rowDict, requiredBodySlots);\n\n                // Variables for template (canonicalized by resolver)\n                m.Variables = _resolver.ResolveVariables(rowDict, mappingsToUse);\n\n                // Phone selection\n                string? phone = null;\n                if (!string.IsNullOrWhiteSpace(phoneField))\n                {\n                    rowDict.TryGetValue(phoneField, out phone);\n                }\n                else\n                {\n                    foreach (var cand in PhoneHeaderCandidates)\n                        if (rowDict.TryGetValue(cand, out phone) && !string.IsNullOrWhiteSpace(phone))\n                            break;\n                }\n\n                phone = NormalizePhoneMaybe(phone, request.NormalizePhones);\n                m.Phone = phone;\n\n                if (string.IsNullOrWhiteSpace(m.Phone))\n                {\n                    m.Errors.Add(\"Missing phone\");\n                    resp.SkippedCount++;\n                    continue;\n                }\n\n                if (request.Deduplicate && !seenPhones.Add(m.Phone))\n                {\n                    m.Errors.Add(\"Duplicate phone (deduped)\");\n                    resp.SkippedCount++;\n                    continue;\n                }\n\n                // 🔒 Enforce required body placeholders BEFORE adding to preview\n                var prelimBodyParams = BuildBodyParamArrayFromVariables(\n                    m.Variables ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase));\n\n                var enforced = EnsureBodyParamsComplete(prelimBodyParams, requiredBodySlots, out var missingSlots);\n                if (enforced == null)\n                {\n                    // at least one required slot missing → skip this row\n                    m.Errors.Add($\"Missing body parameters: {string.Join(\", \", missingSlots)}\");\n                    resp.SkippedCount++;\n                    continue;\n                }\n\n                // (Optional) keep for troubleshooting:\n                // m.DebugBodyParams = enforced;\n\n                preview.Add(m);\n            }\n\n            resp.MaterializedCount = preview.Count;\n\n            // Persist if requested\n            if (request.Persist && resp.MaterializedCount > 0)\n            {\n                var audienceId = await PersistAudienceAndRecipientsAsync(\n                    businessId, campaignId, request.AudienceName!, preview, ct);\n\n                resp.AudienceId = audienceId;\n            }\n\n            return resp;\n        }\n\n\n\n        // ---------- Persistence ----------\n        // NEW: reusable helper (body {{n}} → string[])\n        // NEW: reusable helper (body {{n}} / parameterN / body.N → string[])\n        private static string[] BuildBodyParamArrayFromVariables(IDictionary<string, string> vars)\n        {\n            var pairs = new List<(int idx, string val)>();\n\n            foreach (var kv in vars)\n            {\n                var k = kv.Key ?? string.Empty;\n                var v = kv.Value ?? string.Empty;\n\n                // 1) body.N\n                if (k.StartsWith(\"body.\", StringComparison.OrdinalIgnoreCase))\n                {\n                    if (int.TryParse(k.AsSpan(\"body.\".Length), out var n) && n > 0)\n                        pairs.Add((n, v));\n                    continue;\n                }\n\n                // 2) parameterN (FE mapping keys)\n                if (k.StartsWith(\"parameter\", StringComparison.OrdinalIgnoreCase))\n                {\n                    if (int.TryParse(k.AsSpan(\"parameter\".Length), out var n) && n > 0)\n                        pairs.Add((n, v));\n                    continue;\n                }\n\n                // 3) {{N}} (auto-mapper tokens)\n                // match exactly {{  number  }}\n                var m = System.Text.RegularExpressions.Regex.Match(k, @\"^\\{\\{\\s*(\\d+)\\s*\\}\\}$\");\n                if (m.Success && int.TryParse(m.Groups[1].Value, out var t) && t > 0)\n                {\n                    pairs.Add((t, v));\n                    continue;\n                }\n            }\n\n            if (pairs.Count == 0) return Array.Empty<string>();\n\n            var max = pairs.Max(p => p.idx);\n            var arr = new string[max];\n            for (int i = 0; i < max; i++) arr[i] = string.Empty;\n            foreach (var (idx, val) in pairs) arr[idx - 1] = val ?? string.Empty;\n            return arr;\n        }\n\n        // CampaignMaterializer.cs  — replace the whole method\n        private async Task<Guid> PersistAudienceAndRecipientsAsync(\n            Guid businessId,\n            Guid campaignId,\n            string audienceName,\n            List<CsvMaterializedRowDto> rows,\n            CancellationToken ct)\n        {\n            await using var tx = await _db.Database.BeginTransactionAsync(ct);\n            try\n            {\n                var now = DateTime.UtcNow;\n\n                var audience = new Audience\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    Name = audienceName,\n                    CreatedAt = now,\n                    UpdatedAt = now\n                };\n                _db.Audiences.Add(audience);\n\n                // --- local helpers --------------------------------------------------\n                static string[] BuildBodyParamArray(IDictionary<string, string> vars)\n                {\n                    // Accept both \"body.N\" and \"parameterN\"\n                    var pairs = new List<(int idx, string val)>();\n\n                    foreach (var kv in vars)\n                    {\n                        var k = kv.Key;\n\n                        // body.N\n                        if (k.StartsWith(\"body.\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (int.TryParse(k.AsSpan(\"body.\".Length), out var n) && n > 0)\n                                pairs.Add((n, kv.Value ?? string.Empty));\n                            continue;\n                        }\n\n                        // parameterN (compat)\n                        if (k.StartsWith(\"parameter\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            if (int.TryParse(k.AsSpan(\"parameter\".Length), out var n) && n > 0)\n                                pairs.Add((n, kv.Value ?? string.Empty));\n                        }\n                    }\n\n                    if (pairs.Count == 0) return Array.Empty<string>();\n\n                    var max = pairs.Max(p => p.idx);\n                    var arr = new string[max];\n                    for (int i = 0; i < max; i++) arr[i] = string.Empty;\n                    foreach (var (idx, val) in pairs) arr[idx - 1] = val ?? string.Empty;\n                    return arr;\n                }\n\n                static Dictionary<string, string> BuildHeaderAndButtonVars(IDictionary<string, string> vars)\n                {\n                    // We store non-body keys in ResolvedButtonUrlsJson (generic bag):\n                    // - header.image_url / header.video_url / header.document_url\n                    // - header.text.N\n                    // - button{1..3}.url_param\n                    var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n                    foreach (var kv in vars)\n                    {\n                        var k = kv.Key;\n                        var v = kv.Value ?? string.Empty;\n\n                        // header media urls\n                        if (k.StartsWith(\"header.\", StringComparison.OrdinalIgnoreCase) &&\n                           (k.EndsWith(\"_url\", StringComparison.OrdinalIgnoreCase) ||\n                            k.EndsWith(\".url\", StringComparison.OrdinalIgnoreCase)))\n                        {\n                            dict[k] = v;\n                            continue;\n                        }\n\n                        // header text placeholders: header.text.N\n                        if (k.StartsWith(\"header.text.\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            var tail = k.Substring(\"header.text.\".Length);\n                            if (int.TryParse(tail, out var n) && n > 0)\n                                dict[k] = v;\n                            continue;\n                        }\n\n                        // URL button param variants → normalize to .url_param\n                        if (k.StartsWith(\"button\", StringComparison.OrdinalIgnoreCase))\n                        {\n                            var normKey = k\n                                .Replace(\".url.param\", \".url_param\", StringComparison.OrdinalIgnoreCase)\n                                .Replace(\".urlparam\", \".url_param\", StringComparison.OrdinalIgnoreCase);\n\n                            if (normKey.EndsWith(\".url_param\", StringComparison.OrdinalIgnoreCase))\n                                dict[normKey] = v;\n                        }\n                    }\n\n                    return dict;\n                }\n                // --------------------------------------------------------------------\n\n                foreach (var r in rows)\n                {\n                    if (string.IsNullOrWhiteSpace(r.Phone))\n                        continue; // safety; missing phone rows were already filtered\n\n                    // Try to link to an existing Contact by normalized phone\n                    Guid? contactId = await _db.Contacts\n                        .Where(c => c.BusinessId == businessId && c.PhoneNumber == r.Phone)\n                        .Select(c => (Guid?)c.Id)\n                        .FirstOrDefaultAsync(ct);\n\n                    var variables = r.Variables ?? new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n\n                    // Keep full variable map on AudienceMember for export/debug\n                    var attributesJson = JsonSerializer.Serialize(variables);\n\n                    // Shapes expected by sender:\n                    var bodyParams = BuildBodyParamArray(variables);            // string[] for {{1}}..{{N}}\n                    var headerAndButtons = BuildHeaderAndButtonVars(variables); // dict for header.* + button*.url_param\n\n                    var resolvedParamsJson = JsonSerializer.Serialize(bodyParams);\n                    var resolvedButtonsJson = JsonSerializer.Serialize(headerAndButtons);\n\n                    // Idempotency: include both body params and header/button vars\n                    var idemPayload = JsonSerializer.Serialize(new { p = bodyParams, b = headerAndButtons });\n                    var idempotencyKey = ComputeIdempotencyKey(campaignId, r.Phone, idemPayload);\n\n                    var member = new AudienceMember\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        AudienceId = audience.Id,\n                        ContactId = contactId,                 // stays null if no match\n                        PhoneE164 = r.Phone,                   // normalized earlier\n                        AttributesJson = attributesJson,\n                        IsTransientContact = !contactId.HasValue,\n                        CreatedAt = now,\n                        UpdatedAt = now\n                    };\n                    _db.AudiencesMembers.Add(member);\n\n                    var recipient = new CampaignRecipient\n                    {\n                        Id = Guid.NewGuid(),\n                        BusinessId = businessId,\n                        CampaignId = campaignId,\n                        AudienceMemberId = member.Id,\n                        IdempotencyKey = idempotencyKey,\n                        ResolvedParametersJson = resolvedParamsJson,   // string[] (body)\n                        ResolvedButtonUrlsJson = resolvedButtonsJson,  // dict (header + buttons)\n                        MaterializedAt = now,\n                        Status = \"Pending\",\n                        UpdatedAt = now\n                    };\n\n                    if (contactId.HasValue)\n                        recipient.ContactId = contactId.Value;\n\n                    _db.CampaignRecipients.Add(recipient);\n                }\n\n                await _db.SaveChangesAsync(ct);\n                await tx.CommitAsync(ct);\n                return audience.Id;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Materialize persist failed\");\n                await tx.RollbackAsync(ct);\n                throw;\n            }\n        }\n\n\n        // ---------- Utils ----------\n        private static Dictionary<string, string> JsonToDict(string? json)\n        {\n            var dict = new Dictionary<string, string>(StringComparer.OrdinalIgnoreCase);\n            if (string.IsNullOrWhiteSpace(json)) return dict;\n\n            using var doc = JsonDocument.Parse(json);\n            if (doc.RootElement.ValueKind != JsonValueKind.Object) return dict;\n            foreach (var p in doc.RootElement.EnumerateObject())\n                dict[p.Name] = p.Value.ValueKind == JsonValueKind.Null ? \"\" : p.Value.ToString();\n\n            return dict;\n        }\n\n        private static string? NormalizePhoneMaybe(string? raw, bool normalize)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var trimmed = raw.Trim();\n            if (!normalize) return trimmed;\n\n            // naive E.164-lite cleanup; swap for your real normalizer later\n            var digits = Regex.Replace(trimmed, \"[^0-9]\", \"\");\n            digits = digits.TrimStart('0');\n\n            // Heuristic for India: add 91 if 10-digit local\n            if (digits.Length == 10) digits = \"91\" + digits;\n\n            return digits.Length >= 10 ? digits : trimmed;\n        }\n\n        private static string ComputeIdempotencyKey(Guid campaignId, string phone, string parametersJson)\n        {\n            var raw = $\"{campaignId}|{phone}|{parametersJson}\";\n            using var sha = SHA256.Create();\n            var bytes = sha.ComputeHash(Encoding.UTF8.GetBytes(raw));\n            return Convert.ToHexString(bytes);\n        }\n    }\n}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignPreviewService.cs",
      "sha256": "7b76cfe39ba8ab8167b8c7ac8883bb99f48d1714cfd45b9d0cbfc5f4e3e8f93f",
      "language": "csharp",
      "size": 11517,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog; // ✅ use Serilog like the rest of your services\nusing xbytechat.api;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.WhatsAppSettings.DTOs;\nusing xbytechat_api.WhatsAppSettings.Services;\nusing xbytechat.api.CRM.Models;\nusing xbytechat.api.Features.Tracking.Services;\nusing xbytechat.api.Shared.utility;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public interface ICampaignPreviewService\n    {\n        Task<CampaignPreviewResponseDto> PreviewAsync(Guid businessId, Guid campaignId, Guid? contactId);\n    }\n\n    public class CampaignPreviewService : ICampaignPreviewService\n    {\n        private readonly AppDbContext _db;\n        private readonly IWhatsAppTemplateFetcherService _templateFetcher;\n        private readonly IUrlBuilderService _urlBuilder;\n\n        public CampaignPreviewService(\n            AppDbContext db,\n            IWhatsAppTemplateFetcherService templateFetcher,\n            IUrlBuilderService urlBuilder)\n        {\n            _db = db;\n            _templateFetcher = templateFetcher;\n            _urlBuilder = urlBuilder;\n        }\n\n        public async Task<CampaignPreviewResponseDto> PreviewAsync(Guid businessId, Guid campaignId, Guid? contactId)\n        {\n            try\n            {\n                Log.Information(\"🧪 Preview start | biz={BusinessId} campaign={CampaignId} contactId={ContactId}\",\n                    businessId, campaignId, contactId);\n\n                var campaign = await _db.Campaigns\n                    .Include(c => c.MultiButtons)\n                    .Include(c => c.Recipients).ThenInclude(r => r.Contact)\n                    .FirstOrDefaultAsync(c => c.Id == campaignId && c.BusinessId == businessId);\n\n                if (campaign == null)\n                {\n                    Log.Warning(\"❌ Preview aborted: campaign not found | biz={BusinessId} campaign={CampaignId}\",\n                        businessId, campaignId);\n                    throw new InvalidOperationException(\"Campaign not found.\");\n                }\n\n                // Resolve template name (respect flow entry if any)\n                var templateName = await ResolveStartTemplateName(businessId, campaign);\n                Log.Information(\"🔎 Preview resolved template | campaign={CampaignId} template={TemplateName}\",\n                    campaign.Id, templateName);\n\n                // Fetch template meta (body/buttons/lang/header)\n                var meta = await _templateFetcher.GetTemplateByNameAsync(businessId, templateName, includeButtons: true);\n                if (meta == null)\n                {\n                    Log.Warning(\"❌ Preview aborted: template metadata not found | biz={BusinessId} template={TemplateName}\",\n                        businessId, templateName);\n                    throw new InvalidOperationException(\"Template metadata not found.\");\n                }\n\n                // Prepare parameters/body\n                var parsedParams = TemplateParameterHelper.ParseTemplateParams(campaign.TemplateParameters);\n                var body = meta.Body ?? campaign.MessageTemplate ?? string.Empty;\n                var bodyPreview = TemplateParameterHelper.FillPlaceholders(body, parsedParams);\n\n                // Compute missing params (simple check: count vs supplied)\n                var missing = new List<string>();\n                if (meta.PlaceholderCount > 0)\n                {\n                    var supplied = parsedParams?.Count ?? 0;\n                    if (supplied < meta.PlaceholderCount)\n                    {\n                        for (int i = supplied + 1; i <= meta.PlaceholderCount; i++)\n                            missing.Add($\"{{{{{i}}}}} parameter is missing\");\n\n                        Log.Warning(\"⚠️ Preview found missing params | campaign={CampaignId} required={Required} supplied={Supplied}\",\n                            campaign.Id, meta.PlaceholderCount, supplied);\n                    }\n                }\n\n                // Choose contact for dynamic phone substitutions\n                var contact = await PickContactAsync(campaign, contactId);\n\n                // Buttons preview\n                var buttons = BuildButtonsPreview(campaign, meta, contact);\n\n                var result = new CampaignPreviewResponseDto\n                {\n                    CampaignId = campaign.Id,\n                    TemplateName = templateName,\n                    Language = meta.Language ?? \"en_US\",\n                    PlaceholderCount = meta.PlaceholderCount,\n                    BodyPreview = bodyPreview,\n                    MissingParams = missing,\n                    HasHeaderMedia = meta.HasImageHeader,\n                    HeaderType = meta.HasImageHeader ? \"IMAGE\" : null,\n                    Buttons = buttons\n                };\n\n                Log.Information(\"✅ Preview ready | campaign={CampaignId} template={TemplateName} placeholders={Count}\",\n                    campaign.Id, templateName, meta.PlaceholderCount);\n\n                return result;\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"🚨 Preview failed | biz={BusinessId} campaign={CampaignId}\", businessId, campaignId);\n                throw; // let controller shape the HTTP response (keeps consistency with your pattern)\n            }\n        }\n\n        // ---------- helpers ----------\n\n        private async Task<string> ResolveStartTemplateName(Guid businessId, Campaign campaign)\n        {\n            string selected = campaign.TemplateId ?? campaign.MessageTemplate ?? string.Empty;\n            if (!campaign.CTAFlowConfigId.HasValue || campaign.CTAFlowConfigId.Value == Guid.Empty)\n                return selected;\n\n            var flow = await _db.CTAFlowConfigs\n                .Include(f => f.Steps).ThenInclude(s => s.ButtonLinks)\n                .FirstOrDefaultAsync(f => f.Id == campaign.CTAFlowConfigId.Value\n                                        && f.BusinessId == businessId\n                                        && f.IsActive);\n\n            if (flow == null || flow.Steps == null || flow.Steps.Count == 0)\n                return selected;\n\n            var incoming = new HashSet<Guid>(flow.Steps\n                .SelectMany(s => s.ButtonLinks)\n                .Where(l => l.NextStepId.HasValue)\n                .Select(l => l.NextStepId!.Value));\n\n            var entry = flow.Steps.OrderBy(s => s.StepOrder)\n                                  .FirstOrDefault(s => !incoming.Contains(s.Id));\n\n            return string.IsNullOrWhiteSpace(entry?.TemplateToSend) ? selected : entry!.TemplateToSend!;\n        }\n\n        private async Task<Contact?> PickContactAsync(Campaign campaign, Guid? requestedContactId)\n        {\n            if (requestedContactId.HasValue)\n            {\n                var specific = campaign.Recipients?.FirstOrDefault(r => r.ContactId == requestedContactId)?.Contact;\n                if (specific != null) return specific;\n\n                // allow direct lookup if not in recipients yet\n                return await _db.Contacts.FirstOrDefaultAsync(c =>\n                    c.Id == requestedContactId.Value && c.BusinessId == campaign.BusinessId);\n            }\n\n            // fallback: first recipient’s contact\n            return campaign.Recipients?.FirstOrDefault()?.Contact;\n        }\n\n        private List<ButtonPreviewDto> BuildButtonsPreview(Campaign campaign, TemplateMetadataDto meta, Contact? contact)\n        {\n            var result = new List<ButtonPreviewDto>();\n            var campaignButtons = campaign.MultiButtons?\n                .OrderBy(b => b.Position)\n                .Take(3)\n                .ToList() ?? new List<CampaignButton>();\n\n            var templateButtons = meta.ButtonParams ?? new List<ButtonMetadataDto>();\n            var total = Math.Min(3, Math.Min(campaignButtons.Count, templateButtons.Count));\n\n            for (int i = 0; i < total; i++)\n            {\n                var tplBtn = templateButtons[i];\n                var campBtn = campaignButtons[i];\n\n                var subType = (tplBtn.SubType ?? \"url\").ToLowerInvariant();\n                var baseParam = tplBtn.ParameterValue?.Trim();\n                var isDynamic = subType == \"url\" && !string.IsNullOrWhiteSpace(baseParam) && baseParam.Contains(\"{{\");\n\n                string? token = null;\n                string? previewUrl = null;\n                string? campaignValue = campBtn.Value?.Trim();\n\n                if (isDynamic && string.IsNullOrWhiteSpace(campaignValue))\n                {\n                    Log.Warning(\"⚠️ Preview: dynamic URL button without campaign value | campaign={CampaignId} idx={Index} label={Label}\",\n                        campaign.Id, i, tplBtn.Text ?? campBtn.Title ?? \"\");\n                }\n\n                if (isDynamic && !string.IsNullOrWhiteSpace(campaignValue))\n                {\n                    // optional phone substitution\n                    var phone = NormalizePhone(contact?.PhoneNumber);\n                    var replaced = campaignValue.Contains(\"{{1}}\")\n                        ? campaignValue.Replace(\"{{1}}\", Uri.EscapeDataString(phone ?? \"\"))\n                        : campaignValue;\n\n                    // Build tracked URL using a synthetic id (only for preview)\n                    var fakeLogId = Guid.NewGuid();\n                    var tracked = _urlBuilder.BuildTrackedButtonUrl(fakeLogId, i, campBtn.Title, NormalizeAbsoluteUrl(replaced));\n                    previewUrl = tracked;\n\n                    // extract token after \"/r/\"\n                    token = ExtractToken(tracked);\n                }\n\n                result.Add(new ButtonPreviewDto\n                {\n                    Index = i,\n                    Text = tplBtn.Text ?? campBtn.Title ?? \"\",\n                    Type = tplBtn.Type ?? \"URL\",\n                    IsDynamic = isDynamic,\n                    TemplateParamBase = baseParam,\n                    CampaignValue = campaignValue,\n                    TokenParam = token,\n                    FinalUrlPreview = previewUrl\n                });\n            }\n\n            return result;\n        }\n\n        private static string? NormalizePhone(string? raw)\n        {\n            if (string.IsNullOrWhiteSpace(raw)) return null;\n            var s = raw.Trim();\n            if (!s.StartsWith(\"+\")) s = \"+\" + new string(s.Where(char.IsDigit).ToArray());\n            return s;\n        }\n\n        private static string NormalizeAbsoluteUrl(string input)\n        {\n            // allow tel:/wa: for preview, but tracking expects http(s); if not absolute http(s), keep as-is.\n            if (Uri.TryCreate(input, UriKind.Absolute, out var uri) &&\n                (uri.Scheme.Equals(Uri.UriSchemeHttp, StringComparison.OrdinalIgnoreCase) ||\n                 uri.Scheme.Equals(Uri.UriSchemeHttps, StringComparison.OrdinalIgnoreCase)))\n            {\n                return uri.ToString();\n            }\n            return input;\n        }\n\n        private static string? ExtractToken(string fullTrackedUrl)\n        {\n            var pos = fullTrackedUrl.LastIndexOf(\"/r/\", StringComparison.OrdinalIgnoreCase);\n            if (pos < 0) return null;\n            var token = fullTrackedUrl[(pos + 3)..];\n            return string.IsNullOrWhiteSpace(token) ? null : token;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignRecipientService.cs",
      "sha256": "3e199694bbe770521c2d3b8b5e58770ed0390d9bc2b2c845e26d4806a41c1ea7",
      "language": "csharp",
      "size": 8095,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public class CampaignRecipientService : ICampaignRecipientService\n    {\n        private readonly AppDbContext _context;\n\n        public CampaignRecipientService(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        // 🔍 Get a single recipient by ID\n        public async Task<CampaignRecipientDto?> GetByIdAsync(Guid id)\n        {\n            return await _context.CampaignRecipients\n                .Include(r => r.Contact)\n                .Where(r => r.Id == id)\n                .Select(r => new CampaignRecipientDto\n                {\n                    Id = r.Id,\n                    ContactId = r.ContactId,\n                    ContactName = r.Contact.Name,\n                    ContactPhone = r.Contact.PhoneNumber,\n                    Status = r.Status,\n                    SentAt = r.SentAt\n                })\n                .FirstOrDefaultAsync();\n        }\n\n        // 📦 Get all recipients of a specific campaign\n        public async Task<List<CampaignRecipientDto>> GetByCampaignIdAsync(Guid campaignId)\n        {\n            return await _context.CampaignRecipients\n                .Include(r => r.Contact)\n                .Where(r => r.CampaignId == campaignId)\n                .Select(r => new CampaignRecipientDto\n                {\n                    Id = r.Id,\n                    ContactId = r.ContactId,\n                    ContactName = r.Contact.Name,\n                    ContactPhone = r.Contact.PhoneNumber,\n                    Status = r.Status,\n                    SentAt = r.SentAt\n                })\n                .ToListAsync();\n        }\n\n        // ✏️ Update status of a specific recipient\n        public async Task<bool> UpdateStatusAsync(Guid recipientId, string newStatus)\n        {\n            var recipient = await _context.CampaignRecipients.FindAsync(recipientId);\n            if (recipient == null) return false;\n\n            recipient.Status = newStatus;\n            recipient.UpdatedAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n        // 💬 Track customer reply or CTA\n        // 🗣️ Track customer reply on a recipient\n        public async Task<bool> TrackReplyAsync(Guid recipientId, string replyText)\n        {\n            var recipient = await _context.CampaignRecipients.FindAsync(recipientId);\n            if (recipient == null) return false;\n\n            recipient.ClickedCTA = replyText;\n            recipient.UpdatedAt = DateTime.UtcNow;\n\n            await _context.SaveChangesAsync();\n            return true;\n        }\n\n\n        // 🔎 Global recipient search across all campaigns\n        // 🔍 Search recipients by optional status or keyword\n        public async Task<List<CampaignRecipientDto>> SearchRecipientsAsync(string status = null, string keyword = null)\n        {\n            var query = _context.CampaignRecipients\n                .Include(r => r.Contact)\n                .AsQueryable();\n\n            if (!string.IsNullOrEmpty(status))\n                query = query.Where(r => r.Status == status);\n\n            if (!string.IsNullOrEmpty(keyword))\n                query = query.Where(r =>\n                    r.Contact.Name.Contains(keyword) ||\n                    r.Contact.PhoneNumber.Contains(keyword)\n                );\n\n            return await query\n                .Select(r => new CampaignRecipientDto\n                {\n                    Id = r.Id,\n                    ContactId = r.ContactId,\n                    ContactName = r.Contact.Name,\n                    ContactPhone = r.Contact.PhoneNumber,\n                    Status = r.Status,\n                    SentAt = r.SentAt\n                })\n                .ToListAsync();\n        }\n\n        //public async Task AssignContactsToCampaignAsync(Guid campaignId, List<Guid> contactIds)\n        //{\n        //    var campaign = await _context.Campaigns\n        //        .AsNoTracking()\n        //        .FirstOrDefaultAsync(c => c.Id == campaignId);\n\n        //    if (campaign == null)\n        //        throw new Exception(\"Campaign not found.\");\n\n        //    var businessId = campaign.BusinessId;\n\n        //    var existing = await _context.CampaignRecipients\n        //        .Where(r => r.CampaignId == campaignId && contactIds.Contains(r.ContactId))\n        //        .Select(r => r.ContactId)\n        //        .ToListAsync();\n\n        //    var newRecipients = contactIds\n        //        .Where(id => !existing.Contains(id))\n        //        .Select(contactId => new CampaignRecipient\n        //        {\n        //            Id = Guid.NewGuid(),\n        //            CampaignId = campaignId,\n        //            ContactId = contactId,\n        //            BusinessId = businessId, // ✅ required\n        //            Status = \"Pending\",\n        //            SentAt = DateTime.UtcNow,\n        //            UpdatedAt = DateTime.UtcNow,\n        //            IsAutoTagged = false\n        //        }).ToList();\n\n        //    if (newRecipients.Any())\n        //    {\n        //        await _context.CampaignRecipients.AddRangeAsync(newRecipients);\n        //        await _context.SaveChangesAsync();\n        //    }\n        //}\n\n        public async Task AssignContactsToCampaignAsync(Guid campaignId, List<Guid> contactIds)\n        {\n            var campaign = await _context.Campaigns\n                .AsNoTracking()\n                .FirstOrDefaultAsync(c => c.Id == campaignId);\n\n            if (campaign == null)\n                throw new Exception(\"Campaign not found.\");\n\n            var businessId = campaign.BusinessId;\n            var now = DateTime.UtcNow;\n\n            // 1) Sanitize inputs (no duplicates, no Guid.Empty)\n            var contactIdsClean = (contactIds ?? new List<Guid>())\n                .Where(id => id != Guid.Empty)\n                .Distinct()\n                .ToList();\n\n            if (contactIdsClean.Count == 0)\n                return;\n\n            // 2) Ensure all contacts belong to the same business (tenant safety)\n            var validContactIds = await _context.Contacts\n                .Where(c => c.BusinessId == businessId && contactIdsClean.Contains(c.Id))\n                .Select(c => c.Id)\n                .ToListAsync();\n\n            if (validContactIds.Count == 0)\n                return;\n\n            // 3) Find existing recipients for this campaign (ContactId is Guid?)\n            var existingContactIds = await _context.CampaignRecipients\n                .Where(r => r.CampaignId == campaignId\n                            && r.ContactId.HasValue\n                            && validContactIds.Contains(r.ContactId.Value))\n                .Select(r => r.ContactId!.Value) // project to non-nullable Guid\n                .ToListAsync();\n\n            // 4) Create recipients only for truly new contacts\n            var newContactIds = validContactIds.Except(existingContactIds).ToList();\n            if (newContactIds.Count == 0)\n                return;\n\n            var newRecipients = newContactIds.Select(contactId => new CampaignRecipient\n            {\n                Id = Guid.NewGuid(),\n                CampaignId = campaignId,\n                BusinessId = businessId,\n                ContactId = contactId,         // non-null Guid\n                Status = \"Pending\",\n                // This is *assignment/materialization*, not send:\n                MaterializedAt = now,\n                SentAt = null,                 // leave null until actually sent\n                UpdatedAt = now,\n                IsAutoTagged = false\n                // AudienceMemberId/IdempotencyKey/etc. if your flow sets them here\n            }).ToList();\n\n            await _context.CampaignRecipients.AddRangeAsync(newRecipients);\n            await _context.SaveChangesAsync();\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignRetryService.cs",
      "sha256": "0e4a2ec463e21ef4eb537bc3ae1cae0e54f3c9282b73bfb666017834dab474f2",
      "language": "csharp",
      "size": 4212,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.DTOs;\nusing xbytechat.api.Features.CampaignModule.Models;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n \n    public sealed class CampaignRetryService : ICampaignRetryService\n    {\n        private readonly AppDbContext _db;\n        private readonly CampaignService _campaignService; // use concrete to reach batch method\n\n        public CampaignRetryService(AppDbContext db, ICampaignService campaignService)\n        {\n            _db = db;\n            // We know our concrete implementation exposes the batch entry.\n            _campaignService = (CampaignService)campaignService;\n        }\n\n        public async Task<CampaignRetryResultDto> RetryFailedAsync(Guid businessId, Guid campaignId, int limit = 200)\n        {\n            if (businessId == Guid.Empty) throw new UnauthorizedAccessException(\"Invalid business id.\");\n            if (campaignId == Guid.Empty) throw new ArgumentException(\"campaignId is required\");\n            if (limit <= 0) limit = 200;\n\n            var exists = await _db.Campaigns\n                .AsNoTracking()\n                .AnyAsync(c => c.Id == campaignId && c.BusinessId == businessId && !c.IsDeleted);\n            if (!exists) throw new KeyNotFoundException(\"Campaign not found.\");\n\n            // Most recent log per recipient, keep only those whose latest is Failed\n            var failedQuery =\n                from log in _db.CampaignSendLogs.AsNoTracking()\n                where log.BusinessId == businessId && log.CampaignId == campaignId\n                group log by log.RecipientId into g\n                let last = g.OrderByDescending(x => x.CreatedAt).First()\n                where last.SendStatus == \"Failed\"\n                select new { RecipientId = last.RecipientId }; // <-- Guid (non-nullable)\n\n            var failed = await failedQuery\n                .Select(x => x.RecipientId)   // <-- no .Value\n                .Distinct()\n                .Take(limit)\n                .ToListAsync();\n\n            var result = new CampaignRetryResultDto\n            {\n                CampaignId = campaignId,\n                ConsideredFailed = failed.Count\n            };\n\n            if (failed.Count == 0)\n            {\n                result.Note = \"No failed recipients found to retry.\";\n                return result;\n            }\n\n            // Filter out recipients whose latest log is Sent (paranoia/safety)\n            var latestOkQuery =\n                from log in _db.CampaignSendLogs.AsNoTracking()\n                where log.BusinessId == businessId && log.CampaignId == campaignId\n                group log by log.RecipientId into g\n                let last = g.OrderByDescending(x => x.CreatedAt).First()\n                where last.SendStatus == \"Sent\"\n                select new { RecipientId = last.RecipientId }; // Guid\n\n            var alreadyOk = await latestOkQuery\n                .Select(x => x.RecipientId)\n                .ToListAsync();\n\n            var toRetry = failed.Except(alreadyOk).ToList();\n            result.Skipped = failed.Count - toRetry.Count;\n\n            if (toRetry.Count == 0)\n            {\n                result.Note = \"All failed recipients appear to have a later successful send.\";\n                return result;\n            }\n\n            // Send the batch via canonical pipeline (freezing + idempotency safeguard)\n            var resp = await _campaignService.SendTemplateCampaignBatchAsync(campaignId, toRetry);\n\n            result.Retried = resp.Success ? toRetry.Count : 0;\n            result.Note = resp.Success ? \"Retry dispatched.\" : (\"Retry failed: \" + (resp.Message ?? \"Unknown error.\"));\n            result.RecipientIdsSample = toRetry.Take(20).ToList();\n\n            Log.Information(\"Campaign retry executed {@Retry}\", new\n            {\n                businessId,\n                campaignId,\n                consideredFailed = result.ConsideredFailed,\n                skipped = result.Skipped,\n                retried = result.Retried\n            });\n\n            return result;\n        }\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/CampaignModule/Services/CampaignService.BatchSend.cs",
      "sha256": "9d3785359f7dace6742cd0602183c331c17695aa9c1cbfb7346421d774cdaf0c",
      "language": "csharp",
      "size": 1876,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.CampaignModule.Models;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.CampaignModule.Services\n{\n    public partial class CampaignService\n    {\n        /// <summary>\n        /// Sends a text/template campaign to a given subset of recipient IDs (batch).\n        /// Leverages the same pipeline & idempotency you just implemented.\n        /// </summary>\n        public async Task<ResponseResult> SendTemplateCampaignBatchAsync(Guid campaignId, IEnumerable<Guid> recipientIds)\n        {\n            if (campaignId == Guid.Empty) return ResponseResult.ErrorInfo(\"Invalid campaign id.\");\n            var ids = recipientIds?.Where(id => id != Guid.Empty).Distinct().ToList() ?? new List<Guid>();\n            if (ids.Count == 0) return ResponseResult.ErrorInfo(\"No recipients to send in this batch.\");\n\n            var campaign = await _context.Campaigns\n                .Include(c => c.Recipients.Where(r => ids.Contains(r.Id))).ThenInclude(r => r.Contact)\n                .Include(c => c.MultiButtons)\n                .FirstOrDefaultAsync(c => c.Id == campaignId && !c.IsDeleted);\n\n            if (campaign == null) return ResponseResult.ErrorInfo(\"Campaign not found.\");\n            if (campaign.Recipients == null || campaign.Recipients.Count == 0)\n                return ResponseResult.ErrorInfo(\"No batch recipients matched this campaign.\");\n\n            // Reuse your existing method that sends a single campaign object with its recipients loaded.\n            // It already handles: provider resolution, template meta, freezing params/URLs,\n            // idempotency key, logs, and billing ingest.\n            return await SendTextTemplateCampaignAsync(campaign);\n        }\n    }\n}\n"
    }
  ]
}
