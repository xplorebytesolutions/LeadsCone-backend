{
  "name": "xbytechat-api/Features/Billing",
  "generatedAt": "2025-10-02 10:25:32 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppMetaWebhookController.cs",
      "sha256": "2557cea7249e3f7099e3fc3e53474acd46b9edd9419be5f82cfdd49113b5b629",
      "language": "csharp",
      "size": 2422,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/meta\")]\n    public class WhatsAppMetaWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppMetaWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n        private readonly IConfiguration _config;\n        public WhatsAppMetaWebhookController(ILogger<WhatsAppMetaWebhookController> log, IBillingIngestService ingest, IConfiguration config)\n        {\n            _log = log;\n            _ingest = ingest;\n            _config = config;\n        }\n\n        // Meta verification handshake\n        // GET /api/webhooks/whatsapp/meta?hub.mode=subscribe&hub.challenge=...&hub.verify_token=...&businessId=...\n        [HttpGet]\n        public IActionResult Verify([FromQuery(Name = \"hub.mode\")] string mode,\n                                    [FromQuery(Name = \"hub.challenge\")] string challenge,\n                                    [FromQuery(Name = \"hub.verify_token\")] string verifyToken,\n                                    [FromQuery] Guid? businessId = null)\n        {\n            var expected = _config[\"WhatsApp:MetaVerifyToken\"]; // optional; if empty we accept\n            if (!string.IsNullOrWhiteSpace(expected) && !string.Equals(expected, verifyToken))\n            {\n                _log.LogWarning(\"Meta webhook verify failed. Provided token does not match.\");\n                return Unauthorized();\n            }\n            _log.LogInformation(\"Meta webhook verified. BusinessId={BusinessId}\", businessId);\n            return Content(challenge ?? string.Empty, \"text/plain\");\n        }\n\n        // POST /api/webhooks/whatsapp/meta?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Meta webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"META_CLOUD\", payload);\n\n            return Ok();\n        }\n\n        // If you need GET verification for Meta webhook, add it here.\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Controllers/WhatsAppPinnacleWebhookController.cs",
      "sha256": "50c4e7ef562320331826b09fa5210313b19967296a61f89daf10e2e421b8bf73",
      "language": "csharp",
      "size": 1268,
      "content": "using System;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing xbytechat_api.Features.Billing.Services;\n\nnamespace xbytechat_api.Features.Billing.Controllers\n{\n    [ApiController]\n    [Route(\"api/webhooks/whatsapp/pinnacle\")]\n    public class WhatsAppPinnacleWebhookController : ControllerBase\n    {\n        private readonly ILogger<WhatsAppPinnacleWebhookController> _log;\n        private readonly IBillingIngestService _ingest;\n\n        public WhatsAppPinnacleWebhookController(\n            ILogger<WhatsAppPinnacleWebhookController> log,\n            IBillingIngestService ingest)\n        {\n            _log = log;\n            _ingest = ingest;\n        }\n\n        // POST /api/webhooks/whatsapp/pinnacle?businessId=...\n        [HttpPost]\n        public async Task<IActionResult> Post([FromQuery] Guid businessId)\n        {\n            using var reader = new StreamReader(Request.Body);\n            var payload = await reader.ReadToEndAsync();\n\n            _log.LogInformation(\"Pinnacle webhook payload ({Len} chars) for Biz {Biz}\", payload?.Length ?? 0, businessId);\n            await _ingest.IngestFromWebhookAsync(businessId, \"PINNACLE\", payload);\n\n            return Ok();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/DTOs/BillingSnapshotDto.cs",
      "sha256": "ccb71af46ccda4580bcf96c49ae7cab671224aa519eaaf63e561d2fa39d0eb26",
      "language": "csharp",
      "size": 534,
      "content": "using System.Collections.Generic;\n\nnamespace xbytechat_api.Features.Billing.DTOs\n{\n    public class BillingSnapshotDto\n    {\n        public int TotalMessages { get; set; }\n        public int ChargeableMessages { get; set; }\n        public int FreeMessages { get; set; }\n        public Dictionary<string, int> CountByCategory { get; set; } = new();    // marketing, utility, authentication, service, free_entry\n        public Dictionary<string, decimal> SpendByCurrency { get; set; } = new();// \"USD\" => 12.34, \"INR\" => 250.00\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/ExtrackAllFiles.bat",
      "sha256": "3d14ccc013b9fd82ff0759820acc71da52821878e664cb4daa9418062278e799",
      "language": "bat",
      "size": 922,
      "content": "@echo off\nREM This script will find all files and output their name and content into one file.\nREM The output file will be named [FolderName]_AllFileDump.txt.\n\nREM Get the current folder's name and set it as the output file name with the custom suffix\nfor %%I in (\"%cd%\") do set \"outputFile=%%~nI_AllFileDump.txt\"\n\nREM Clear the output file to start fresh\n> \"%outputFile%\" (echo Folder and File Content Report)\necho. >> \"%outputFile%\"\n\nREM Loop through all files in the current directory and subdirectories\nfor /R . %%F in (*.*) do (\n    echo ====================================================== >> \"%outputFile%\"\n    echo FILE: %%F >> \"%outputFile%\"\n    echo ====================================================== >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n    type \"%%F\" >> \"%outputFile%\" 2>nul\n    echo. >> \"%outputFile%\"\n    echo. >> \"%outputFile%\"\n)\n\necho Finished! All content has been extracted to %outputFile%"
    },
    {
      "path": "xbytechat-api/Features/Billing/Models/ProviderBillingEvent.cs",
      "sha256": "f923e2377733fecf0ad48ff39d28f1a6e1bbfe4e78f370748b864f1568285824",
      "language": "csharp",
      "size": 1179,
      "content": "using System;\n\nnamespace xbytechat_api.Features.Billing.Models\n{\n    public class ProviderBillingEvent\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n\n        // Link if we can; may be null if webhook arrives before we create MessageLog\n        public Guid? MessageLogId { get; set; }\n\n        public string Provider { get; set; } = \"\";          // \"Meta_cloud\", \"Pinnacle\"\n        public string EventType { get; set; } = \"\";         // \"conversation_started\", \"message_delivered\", \"pricing_update\", etc.\n\n        public string? ProviderMessageId { get; set; }      // \"wamid...\"\n        public string? ConversationId { get; set; }\n        public string? ConversationCategory { get; set; }\n        public bool? IsChargeable { get; set; }\n        public decimal? PriceAmount { get; set; }\n        public string? PriceCurrency { get; set; }\n\n        public string PayloadJson { get; set; } = \"\";       // original provider payload for audit\n        public DateTimeOffset OccurredAt { get; set; }      // when provider says it happened\n        public DateTimeOffset CreatedAt { get; set; } = DateTimeOffset.UtcNow;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingIngestService.cs",
      "sha256": "f177bd5d56a15388b982936d70b7e02fb7942499fd6ffcf777a634207b0c47ac",
      "language": "csharp",
      "size": 41481,
      "content": "using System;\nusing System.Linq;\nusing System.Text.Json;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\nusing Microsoft.Extensions.Logging;\nusing xbytechat.api; // AppDbContext\nusing xbytechat_api.Features.Billing.Models;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingIngestService : IBillingIngestService\n    {\n        private readonly AppDbContext _db;\n        private readonly ILogger<BillingIngestService> _log;\n\n        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n        {\n            _db = db;\n            _log = log;\n        }\n\n        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n        {\n            // Meta send usually returns only message ID; pricing lands via webhook.\n            // We still extract ProviderMessageId early to link later webhook updates.\n            try\n            {\n                using var doc = JsonDocument.Parse(rawResponseJson);\n                string? providerMessageId =\n                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) && msgs.ValueKind == JsonValueKind.Array && msgs.GetArrayLength() > 0\n                        ? msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null\n                    : doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString()\n                    : null;\n\n                var logRow = await _db.MessageLogs.FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n                if (logRow != null)\n                {\n                    logRow.Provider = provider;\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                        logRow.ProviderMessageId = providerMessageId;\n                }\n\n                // Store audit event\n                var ev = new ProviderBillingEvent\n                {\n                    BusinessId = businessId,\n                    MessageLogId = messageLogId,\n                    Provider = provider,\n                    EventType = \"send_response\",\n                    ProviderMessageId = providerMessageId,\n                    PayloadJson = rawResponseJson,\n                    OccurredAt = DateTimeOffset.UtcNow\n                };\n                _db.ProviderBillingEvents.Add(ev);\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Failed to ingest send response payload for business {biz}\", businessId);\n            }\n        }\n\n        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n        {\n            try\n            {\n                using var doc = JsonDocument.Parse(payloadJson);\n                var now = DateTimeOffset.UtcNow;\n\n                // Local idempotency guard:\n                // Consider an event \"existing\" if (BusinessId, Provider, EventType)\n                // matches and we have either the same ProviderMessageId OR (when absent) the same ConversationId.\n                Task<bool> ExistsAsync(string eventType, string? providerMessageId, string? conversationId)\n                {\n                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                    {\n                        return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                            x.BusinessId == businessId &&\n                            x.Provider == provider &&\n                            x.EventType == eventType &&\n                            x.ProviderMessageId == providerMessageId);\n                    }\n\n                    if (!string.IsNullOrWhiteSpace(conversationId))\n                    {\n                        return _db.ProviderBillingEvents.AsNoTracking().AnyAsync(x =>\n                            x.BusinessId == businessId &&\n                            x.Provider == provider &&\n                            x.EventType == eventType &&\n                            x.ConversationId == conversationId);\n                    }\n\n                    // No natural key available; let it through (DB unique index can still protect if present).\n                    return Task.FromResult(false);\n                }\n\n                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Typical Meta structure:\n                    // entry[].changes[].value.statuses[] with:\n                    //  - id (wamid)\n                    //  - status (sent / delivered / read / etc.)\n                    //  - timestamp (unix seconds, string or number)\n                    //  - conversation { id, expiration_timestamp }\n                    //  - pricing { billable, category, amount, currency }\n                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n                        foreach (var change in Enumerate(entry, \"changes\"))\n                        {\n                            if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n                            foreach (var st in Enumerate(value, \"statuses\"))\n                            {\n                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null;\n\n                                string? status = null;\n                                if (st.TryGetProperty(\"status\", out var statusEl) && statusEl.ValueKind == JsonValueKind.String)\n                                    status = statusEl.GetString()?.ToLowerInvariant();\n\n                                // OccurredAt from provider if present\n                                DateTimeOffset occurredAt = now;\n                                if (st.TryGetProperty(\"timestamp\", out var tsEl))\n                                {\n                                    if (tsEl.ValueKind == JsonValueKind.String && long.TryParse(tsEl.GetString(), out var tsLong))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsLong);\n                                    else if (tsEl.ValueKind == JsonValueKind.Number && tsEl.TryGetInt64(out var tsNum))\n                                        occurredAt = DateTimeOffset.FromUnixTimeSeconds(tsNum);\n                                }\n\n                                // Conversation info (Meta expires 24h after start)\n                                string? conversationId = null;\n                                DateTimeOffset? convStartedAt = null;\n                                if (st.TryGetProperty(\"conversation\", out var convEl) && convEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (convEl.TryGetProperty(\"id\", out var cidEl)) conversationId = cidEl.GetString();\n\n                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl))\n                                    {\n                                        long exp;\n                                        if (expEl.ValueKind == JsonValueKind.String && long.TryParse(expEl.GetString(), out var expStr))\n                                            exp = expStr;\n                                        else if (expEl.ValueKind == JsonValueKind.Number && expEl.TryGetInt64(out var expNum))\n                                            exp = expNum;\n                                        else\n                                            exp = 0;\n\n                                        if (exp > 0)\n                                        {\n                                            var expiration = DateTimeOffset.FromUnixTimeSeconds(exp);\n                                            convStartedAt = expiration.AddHours(-24);\n                                        }\n                                    }\n                                }\n\n                                // Pricing block (optional per status)\n                                string? category = null;\n                                bool? billable = null;\n                                decimal? amount = null;\n                                string? currency = null;\n\n                                if (st.TryGetProperty(\"pricing\", out var pEl) && pEl.ValueKind == JsonValueKind.Object)\n                                {\n                                    if (pEl.TryGetProperty(\"category\", out var catEl))\n                                        category = catEl.GetString()?.ToLowerInvariant();\n\n                                    if (pEl.TryGetProperty(\"billable\", out var bilEl) &&\n                                        (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False))\n                                        billable = bilEl.GetBoolean();\n\n                                    if (pEl.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n                                        amount = amtEl.GetDecimal();\n\n                                    if (pEl.TryGetProperty(\"currency\", out var curEl) && curEl.ValueKind == JsonValueKind.String)\n                                        currency = curEl.GetString();\n                                }\n\n                                // 1) Status event (sent/delivered/read...) — write once\n                                if (!string.IsNullOrWhiteSpace(status))\n                                {\n                                    var statusEventType = status; // store status as EventType\n                                    if (!await ExistsAsync(statusEventType, providerMessageId, conversationId))\n                                    {\n                                        _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                                        {\n                                            BusinessId = businessId,\n                                            Provider = provider,\n                                            EventType = statusEventType,\n                                            ProviderMessageId = providerMessageId,\n                                            ConversationId = conversationId,\n                                            ConversationCategory = category,\n                                            IsChargeable = billable,\n                                            PriceAmount = amount,\n                                            PriceCurrency = currency,\n                                            PayloadJson = payloadJson,\n                                            OccurredAt = occurredAt\n                                        });\n                                    }\n                                }\n\n                                // 2) Pricing update — write once\n                                bool hasAnyPricing = !string.IsNullOrWhiteSpace(category) || billable.HasValue || amount.HasValue || !string.IsNullOrWhiteSpace(currency);\n                                if (hasAnyPricing && !await ExistsAsync(\"pricing_update\", providerMessageId, conversationId))\n                                {\n                                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                                    {\n                                        BusinessId = businessId,\n                                        Provider = provider,\n                                        EventType = \"pricing_update\",\n                                        ProviderMessageId = providerMessageId,\n                                        ConversationId = conversationId,\n                                        ConversationCategory = category,\n                                        IsChargeable = billable,\n                                        PriceAmount = amount,\n                                        PriceCurrency = currency,\n                                        PayloadJson = payloadJson,\n                                        OccurredAt = occurredAt\n                                    });\n                                }\n\n                                // Keep MessageLog in sync (when linkable)\n                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                                if (logRow != null)\n                                {\n                                    logRow.Provider = provider;\n                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                        logRow.ProviderMessageId = providerMessageId;\n                                    if (!string.IsNullOrWhiteSpace(conversationId))\n                                        logRow.ConversationId = conversationId;\n                                    if (convStartedAt.HasValue)\n                                        logRow.ConversationStartedAt = convStartedAt;\n\n                                    if (billable.HasValue) logRow.IsChargeable = billable.Value;\n                                    if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n                                    if (amount.HasValue) logRow.PriceAmount = amount;\n                                    if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n                                }\n                            }\n                        }\n                }\n                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n                {\n                    // Scan for \"pricing\" nodes; try to infer message & conversation from parent context.\n                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n                    {\n                        string? category = pricing.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null;\n                        bool? billable = (pricing.TryGetProperty(\"billable\", out var bilEl) &&\n                                          (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False))\n                                          ? bilEl.GetBoolean() : (bool?)null;\n\n                        decimal? amount = null;\n                        if (pricing.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n                            amount = amtEl.GetDecimal();\n\n                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl) ? curEl.GetString() : null;\n\n                        var parent = TryGetParentObject(doc.RootElement, pricing);\n                        string? providerMessageId = TryGetString(parent, \"id\")\n                                                 ?? TryGetString(parent, \"message_id\")\n                                                 ?? TryGetString(parent, \"wamid\");\n                        string? conversationId = TryGetString(parent, \"conversation_id\")\n                                               ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n                        // Optional status in same parent\n                        string? status = TryGetString(parent, \"status\")?.ToLowerInvariant();\n\n                        // Pricing (deduped)\n                        if (!await ExistsAsync(\"pricing_update\", providerMessageId, conversationId))\n                        {\n                            _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = \"pricing_update\",\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            });\n                        }\n\n                        // Optional status (deduped)\n                        if (!string.IsNullOrWhiteSpace(status) && !await ExistsAsync(status, providerMessageId, conversationId))\n                        {\n                            _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                            {\n                                BusinessId = businessId,\n                                Provider = provider,\n                                EventType = status,\n                                ProviderMessageId = providerMessageId,\n                                ConversationId = conversationId,\n                                ConversationCategory = category,\n                                IsChargeable = billable,\n                                PriceAmount = amount,\n                                PriceCurrency = currency,\n                                PayloadJson = payloadJson,\n                                OccurredAt = now\n                            });\n                        }\n\n                        // Update MessageLog when linkable\n                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n                        if (logRow != null)\n                        {\n                            logRow.Provider = provider;\n                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n                                logRow.ProviderMessageId = providerMessageId;\n                            if (!string.IsNullOrWhiteSpace(conversationId))\n                                logRow.ConversationId = conversationId;\n\n                            if (billable.HasValue) logRow.IsChargeable = billable.Value;\n                            if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n                            if (amount.HasValue) logRow.PriceAmount = amount;\n                            if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n                        }\n                    }\n                }\n                else\n                {\n                    // Unknown provider; still store the raw event for audit (idempotency relaxed here)\n                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n                    {\n                        BusinessId = businessId,\n                        Provider = provider,\n                        EventType = \"unknown_provider_webhook\",\n                        PayloadJson = payloadJson,\n                        OccurredAt = now\n                    });\n                }\n\n                await _db.SaveChangesAsync();\n            }\n            catch (Exception ex)\n            {\n                _log.LogWarning(ex, \"Failed to ingest webhook payload for business {biz}\", businessId);\n            }\n        }\n\n        // -------- helpers --------\n        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n        {\n            if (!string.IsNullOrWhiteSpace(providerMessageId))\n            {\n                var byMsgId = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ProviderMessageId == providerMessageId);\n                if (byMsgId != null) return byMsgId;\n            }\n\n            if (!string.IsNullOrWhiteSpace(conversationId))\n            {\n                var byConv = await _db.MessageLogs\n                    .OrderByDescending(x => x.CreatedAt)\n                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ConversationId == conversationId);\n                if (byConv != null) return byConv;\n            }\n\n            return null;\n        }\n\n        // Enumerate array property safely\n        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n        {\n            if (root.ValueKind != JsonValueKind.Object) yield break;\n            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n            foreach (var x in arr.EnumerateArray()) yield return x;\n        }\n\n        // Breadth search for any property named `name` (unique name to avoid ambiguity)\n        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n        {\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n                        yield return p.Value;\n\n                    foreach (var x in JsonPathAll(p.Value, name))\n                        yield return x;\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var item in root.EnumerateArray())\n                    foreach (var x in JsonPathAll(item, name))\n                        yield return x;\n            }\n        }\n\n        // Very lightweight \"parent\" guess: look for an object in ancestry that contains the node reference (best-effort)\n        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n        {\n            // System.Text.Json doesn't expose parents. We accept best-effort by scanning objects containing 'pricing'\n            if (root.ValueKind == JsonValueKind.Object)\n            {\n                foreach (var p in root.EnumerateObject())\n                {\n                    if (p.Value.ValueKind == JsonValueKind.Object)\n                    {\n                        if (object.ReferenceEquals(p.Value, node)) return root;\n                        var cand = TryGetParentObject(p.Value, node);\n                        if (cand.HasValue) return cand;\n                    }\n                    else if (p.Value.ValueKind == JsonValueKind.Array)\n                    {\n                        foreach (var e in p.Value.EnumerateArray())\n                        {\n                            if (object.ReferenceEquals(e, node)) return root;\n                            var cand = TryGetParentObject(e, node);\n                            if (cand.HasValue) return cand;\n                        }\n                    }\n                }\n            }\n            else if (root.ValueKind == JsonValueKind.Array)\n            {\n                foreach (var e in root.EnumerateArray())\n                {\n                    var cand = TryGetParentObject(e, node);\n                    if (cand.HasValue) return cand;\n                }\n            }\n            return null;\n        }\n\n        private static string? TryGetString(JsonElement? obj, string name)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n        }\n\n        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n        {\n            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object) return null;\n            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Text.Json;\n//using System.Threading.Tasks;\n//using System.Collections.Generic;\n//using Microsoft.EntityFrameworkCore;\n//using Microsoft.Extensions.Logging;\n//using xbytechat.api; // AppDbContext\n//using xbytechat_api.Features.Billing.Models;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingIngestService : IBillingIngestService\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly ILogger<BillingIngestService> _log;\n\n//        public BillingIngestService(AppDbContext db, ILogger<BillingIngestService> log)\n//        {\n//            _db = db;\n//            _log = log;\n//        }\n\n//        public async Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson)\n//        {\n//            // Meta send usually returns only message ID; pricing lands via webhook.\n//            // We still extract ProviderMessageId early to link later webhook updates.\n//            try\n//            {\n//                using var doc = JsonDocument.Parse(rawResponseJson);\n//                string? providerMessageId =\n//                    doc.RootElement.TryGetProperty(\"messages\", out var msgs) && msgs.ValueKind == JsonValueKind.Array && msgs.GetArrayLength() > 0\n//                        ? msgs[0].TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null\n//                    : doc.RootElement.TryGetProperty(\"id\", out var idEl2) ? idEl2.GetString()\n//                    : null;\n\n//                var logRow = await _db.MessageLogs.FirstOrDefaultAsync(x => x.Id == messageLogId && x.BusinessId == businessId);\n//                if (logRow != null)\n//                {\n//                    logRow.Provider = provider;\n//                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                        logRow.ProviderMessageId = providerMessageId;\n//                }\n\n//                // Store audit event\n//                var ev = new ProviderBillingEvent\n//                {\n//                    BusinessId = businessId,\n//                    MessageLogId = messageLogId,\n//                    Provider = provider,\n//                    EventType = \"send_response\",\n//                    ProviderMessageId = providerMessageId,\n//                    PayloadJson = rawResponseJson,\n//                    OccurredAt = DateTimeOffset.UtcNow\n//                };\n//                _db.ProviderBillingEvents.Add(ev);\n\n//                await _db.SaveChangesAsync();\n//            }\n//            catch (Exception ex)\n//            {\n//                _log.LogWarning(ex, \"Failed to ingest send response payload for business {biz}\", businessId);\n//            }\n//        }\n\n//        public async Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson)\n//        {\n//            try\n//            {\n//                using var doc = JsonDocument.Parse(payloadJson);\n//                var now = DateTimeOffset.UtcNow;\n\n//                if (string.Equals(provider, \"META_CLOUD\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // Typical Meta structure:\n//                    // entry[].changes[].value.statuses[] with:\n//                    //  - id (wamid)\n//                    //  - pricing { billable, category, amount, currency }\n//                    //  - conversation { id, expiration_timestamp }\n//                    foreach (var entry in Enumerate(doc.RootElement, \"entry\"))\n//                    {\n//                        foreach (var change in Enumerate(entry, \"changes\"))\n//                        {\n//                            if (!change.TryGetProperty(\"value\", out var value)) continue;\n\n//                            foreach (var st in Enumerate(value, \"statuses\"))\n//                            {\n//                                string? providerMessageId = st.TryGetProperty(\"id\", out var idEl) ? idEl.GetString() : null;\n\n//                                string? category = st.TryGetProperty(\"pricing\", out var pEl) && pEl.ValueKind == JsonValueKind.Object\n//                                    ? pEl.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null\n//                                    : null;\n\n//                                bool? billable = st.TryGetProperty(\"pricing\", out var pEl2) && pEl2.ValueKind == JsonValueKind.Object\n//                                    ? pEl2.TryGetProperty(\"billable\", out var bilEl) && (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False)\n//                                        ? bilEl.GetBoolean() : (bool?)null\n//                                    : (bool?)null;\n\n//                                decimal? amount = null;\n//                                string? currency = null;\n//                                if (st.TryGetProperty(\"pricing\", out var pEl3) && pEl3.ValueKind == JsonValueKind.Object)\n//                                {\n//                                    if (pEl3.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n//                                        amount = amtEl.GetDecimal();\n//                                    if (pEl3.TryGetProperty(\"currency\", out var curEl))\n//                                        currency = curEl.GetString();\n//                                }\n\n//                                string? conversationId = null;\n//                                DateTimeOffset? convStartedAt = null;\n//                                if (st.TryGetProperty(\"conversation\", out var convEl) && convEl.ValueKind == JsonValueKind.Object)\n//                                {\n//                                    if (convEl.TryGetProperty(\"id\", out var cidEl))\n//                                        conversationId = cidEl.GetString();\n\n//                                    // expiration_timestamp is seconds; start time not directly given.\n//                                    if (convEl.TryGetProperty(\"expiration_timestamp\", out var expEl) && expEl.ValueKind == JsonValueKind.Number)\n//                                    {\n//                                        var exp = DateTimeOffset.FromUnixTimeSeconds(expEl.GetInt64());\n//                                        convStartedAt = exp.AddHours(-24);\n//                                    }\n//                                }\n\n//                                // Audit event\n//                                var ev = new ProviderBillingEvent\n//                                {\n//                                    BusinessId = businessId,\n//                                    Provider = provider,\n//                                    EventType = \"pricing_update\",\n//                                    ProviderMessageId = providerMessageId,\n//                                    ConversationId = conversationId,\n//                                    ConversationCategory = category,\n//                                    IsChargeable = billable,\n//                                    PriceAmount = amount,\n//                                    PriceCurrency = currency,\n//                                    PayloadJson = payloadJson,\n//                                    OccurredAt = now\n//                                };\n//                                _db.ProviderBillingEvents.Add(ev);\n\n//                                // Update MessageLog when possible\n//                                var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n//                                if (logRow != null)\n//                                {\n//                                    logRow.Provider = provider;\n//                                    if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                                        logRow.ProviderMessageId = providerMessageId;\n//                                    if (billable.HasValue) logRow.IsChargeable = billable.Value;\n//                                    if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n//                                    if (!string.IsNullOrWhiteSpace(conversationId)) logRow.ConversationId = conversationId;\n//                                    if (amount.HasValue) logRow.PriceAmount = amount;\n//                                    if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n//                                    if (convStartedAt.HasValue) logRow.ConversationStartedAt = convStartedAt;\n//                                }\n//                            }\n//                        }\n//                    }\n//                }\n//                else if (string.Equals(provider, \"PINNACLE\", StringComparison.OrdinalIgnoreCase))\n//                {\n//                    // Pinnacle payloads vary, but often include \"message_id\", \"conversation\" with id/category and \"pricing\".\n//                    // We'll scan the whole tree for any \"pricing\" objects, and attempt nearby fields for message id and conversation.\n//                    foreach (var pricing in JsonPathAll(doc.RootElement, \"pricing\"))\n//                    {\n//                        string? category = pricing.TryGetProperty(\"category\", out var catEl) ? catEl.GetString()?.ToLowerInvariant() : null;\n//                        bool? billable = pricing.TryGetProperty(\"billable\", out var bilEl) && (bilEl.ValueKind == JsonValueKind.True || bilEl.ValueKind == JsonValueKind.False)\n//                            ? bilEl.GetBoolean() : (bool?)null;\n\n//                        decimal? amount = null;\n//                        if (pricing.TryGetProperty(\"amount\", out var amtEl) && amtEl.ValueKind == JsonValueKind.Number)\n//                            amount = amtEl.GetDecimal();\n//                        string? currency = pricing.TryGetProperty(\"currency\", out var curEl) ? curEl.GetString() : null;\n\n//                        // Heuristics to pick neighbors in same object\n//                        var parent = TryGetParentObject(doc.RootElement, pricing);\n//                        string? providerMessageId = TryGetString(parent, \"id\")\n//                                                 ?? TryGetString(parent, \"message_id\")\n//                                                 ?? TryGetString(parent, \"wamid\");\n//                        string? conversationId = TryGetString(parent, \"conversation_id\")\n//                                               ?? TryGetNestedString(parent, \"conversation\", \"id\");\n\n//                        var ev = new ProviderBillingEvent\n//                        {\n//                            BusinessId = businessId,\n//                            Provider = provider,\n//                            EventType = \"pricing_update\",\n//                            ProviderMessageId = providerMessageId,\n//                            ConversationId = conversationId,\n//                            ConversationCategory = category,\n//                            IsChargeable = billable,\n//                            PriceAmount = amount,\n//                            PriceCurrency = currency,\n//                            PayloadJson = payloadJson,\n//                            OccurredAt = now\n//                        };\n//                        _db.ProviderBillingEvents.Add(ev);\n\n//                        var logRow = await FindMatchingMessageLog(businessId, providerMessageId, conversationId);\n//                        if (logRow != null)\n//                        {\n//                            logRow.Provider = provider;\n//                            if (!string.IsNullOrWhiteSpace(providerMessageId))\n//                                logRow.ProviderMessageId = providerMessageId;\n//                            if (billable.HasValue) logRow.IsChargeable = billable.Value;\n//                            if (!string.IsNullOrWhiteSpace(category)) logRow.ConversationCategory = category;\n//                            if (!string.IsNullOrWhiteSpace(conversationId)) logRow.ConversationId = conversationId;\n//                            if (amount.HasValue) logRow.PriceAmount = amount;\n//                            if (!string.IsNullOrWhiteSpace(currency)) logRow.PriceCurrency = currency;\n//                        }\n//                    }\n//                }\n//                else\n//                {\n//                    // Unknown provider; still store the raw event for audit\n//                    _db.ProviderBillingEvents.Add(new ProviderBillingEvent\n//                    {\n//                        BusinessId = businessId,\n//                        Provider = provider,\n//                        EventType = \"unknown_provider_webhook\",\n//                        PayloadJson = payloadJson,\n//                        OccurredAt = now\n//                    });\n//                }\n\n//                await _db.SaveChangesAsync();\n//            }\n//            catch (Exception ex)\n//            {\n//                _log.LogWarning(ex, \"Failed to ingest webhook payload for business {biz}\", businessId);\n//            }\n//        }\n\n//        // -------- helpers --------\n//        private async Task<MessageLog?> FindMatchingMessageLog(Guid businessId, string? providerMessageId, string? conversationId)\n//        {\n//            if (!string.IsNullOrWhiteSpace(providerMessageId))\n//            {\n//                var byMsgId = await _db.MessageLogs\n//                    .OrderByDescending(x => x.CreatedAt)\n//                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ProviderMessageId == providerMessageId);\n//                if (byMsgId != null) return byMsgId;\n//            }\n\n//            if (!string.IsNullOrWhiteSpace(conversationId))\n//            {\n//                var byConv = await _db.MessageLogs\n//                    .OrderByDescending(x => x.CreatedAt)\n//                    .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ConversationId == conversationId);\n//                if (byConv != null) return byConv;\n//            }\n\n//            return null;\n//        }\n\n//        // Enumerate array property safely\n//        private static IEnumerable<JsonElement> Enumerate(JsonElement root, string name)\n//        {\n//            if (root.ValueKind != JsonValueKind.Object) yield break;\n//            if (!root.TryGetProperty(name, out var arr) || arr.ValueKind != JsonValueKind.Array) yield break;\n//            foreach (var x in arr.EnumerateArray()) yield return x;\n//        }\n\n//        // Breadth search for any property named `name` (unique name to avoid ambiguity)\n//        private static IEnumerable<JsonElement> JsonPathAll(JsonElement root, string name)\n//        {\n//            if (root.ValueKind == JsonValueKind.Object)\n//            {\n//                foreach (var p in root.EnumerateObject())\n//                {\n//                    if (string.Equals(p.Name, name, StringComparison.OrdinalIgnoreCase))\n//                        yield return p.Value;\n\n//                    foreach (var x in JsonPathAll(p.Value, name))\n//                        yield return x;\n//                }\n//            }\n//            else if (root.ValueKind == JsonValueKind.Array)\n//            {\n//                foreach (var item in root.EnumerateArray())\n//                    foreach (var x in JsonPathAll(item, name))\n//                        yield return x;\n//            }\n//        }\n\n//        // Very lightweight \"parent\" guess: look for an object in ancestry that contains the node reference (best-effort)\n//        private static JsonElement? TryGetParentObject(JsonElement root, JsonElement node)\n//        {\n//            // System.Text.Json doesn't expose parents. We accept best-effort by scanning objects containing 'pricing'\n//            if (root.ValueKind == JsonValueKind.Object)\n//            {\n//                foreach (var p in root.EnumerateObject())\n//                {\n//                    if (p.Value.ValueKind == JsonValueKind.Object)\n//                    {\n//                        if (object.ReferenceEquals(p.Value, node)) return root;\n//                        var cand = TryGetParentObject(p.Value, node);\n//                        if (cand.HasValue) return cand;\n//                    }\n//                    else if (p.Value.ValueKind == JsonValueKind.Array)\n//                    {\n//                        foreach (var e in p.Value.EnumerateArray())\n//                        {\n//                            if (object.ReferenceEquals(e, node)) return root;\n//                            var cand = TryGetParentObject(e, node);\n//                            if (cand.HasValue) return cand;\n//                        }\n//                    }\n//                }\n//            }\n//            else if (root.ValueKind == JsonValueKind.Array)\n//            {\n//                foreach (var e in root.EnumerateArray())\n//                {\n//                    var cand = TryGetParentObject(e, node);\n//                    if (cand.HasValue) return cand;\n//                }\n//            }\n//            return null;\n//        }\n\n//        private static string? TryGetString(JsonElement? obj, string name)\n//        {\n//            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n//            return obj.Value.TryGetProperty(name, out var el) ? el.GetString() : null;\n//        }\n\n//        private static string? TryGetNestedString(JsonElement? obj, string name1, string name2)\n//        {\n//            if (!obj.HasValue || obj.Value.ValueKind != JsonValueKind.Object) return null;\n//            if (!obj.Value.TryGetProperty(name1, out var inner) || inner.ValueKind != JsonValueKind.Object) return null;\n//            return inner.TryGetProperty(name2, out var v) ? v.GetString() : null;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/BillingReadService.cs",
      "sha256": "0298676bbd8d96132ccbaf42ca893f76a03f769606106dfe82a6bed17982b5fc",
      "language": "csharp",
      "size": 7066,
      "content": "using System;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.EntityFrameworkCore;\n\nusing xbytechat.api;                               // AppDbContext\nusing xbytechat_api.Features.Billing.DTOs;         // BillingSnapshotDto\nusing xbytechat_api.Features.Billing.Models;       // ProviderBillingEvent (for _db.ProviderBillingEvents)\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public class BillingReadService : IBillingReadService\n    {\n        private readonly AppDbContext _db;\n        public BillingReadService(AppDbContext db) => _db = db;\n\n        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n        {\n            // Build inclusive [from..to] range in UTC\n            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n            // 1) Volume: total messages in the period (unchanged behavior)\n            var totalMessages = await _db.MessageLogs.AsNoTracking()\n                .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt)\n                .CountAsync();\n\n            // 2) Billing source of truth: pricing_update events in the period\n            //    (Only select small projection; we'll dedupe in-memory safely.)\n            var evRaw = await _db.ProviderBillingEvents.AsNoTracking()\n                .Where(e => e.BusinessId == businessId\n                            && e.EventType == \"pricing_update\"\n                            && e.OccurredAt >= fromDt && e.OccurredAt <= toDt)\n                .Select(e => new {\n                    e.Provider,\n                    e.ProviderMessageId,\n                    e.EventType,\n                    e.ConversationId,\n                    e.ConversationCategory,\n                    e.IsChargeable,\n                    e.PriceAmount,\n                    e.PriceCurrency\n                })\n                .ToListAsync();\n\n            // 2a) Defend against webhook replays (if DB unique index not yet deployed)\n            //     Deduplicate on Provider+ProviderMessageId+EventType to drop repeats of the same message event.\n            var evDedup = evRaw\n                .GroupBy(e => new { e.Provider, e.ProviderMessageId, e.EventType })\n                .Select(g => g.First())\n                .ToList();\n\n            // 2b) Group by conversation to compute window-level metrics\n            var convGroups = evDedup\n                .Where(e => !string.IsNullOrWhiteSpace(e.ConversationId))\n                .GroupBy(e => e.ConversationId!)\n                .ToList();\n\n            // Chargeable windows: any event in the conversation marked billable == true\n            var chargeableWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == true));\n\n            // Free windows: conversations explicitly marked billable == false and NOT marked true anywhere\n            var freeWindows = convGroups.Count(g => g.Any(x => x.IsChargeable == false) && !g.Any(x => x.IsChargeable == true));\n\n            // Count by category (per conversation, pick first non-empty category; default \"unknown\")\n            var countByCategory = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                var category = g.Select(x => x.ConversationCategory)\n                                .FirstOrDefault(s => !string.IsNullOrWhiteSpace(s))\n                                ?.ToLowerInvariant() ?? \"unknown\";\n                countByCategory[category] = countByCategory.TryGetValue(category, out var c) ? c + 1 : 1;\n            }\n\n            // Spend by currency: for each conversation, take the latest non-null amount (if any), then sum by currency\n            var spendByCurrency = new Dictionary<string, decimal>(StringComparer.OrdinalIgnoreCase);\n            foreach (var g in convGroups)\n            {\n                // Prefer an explicit currency on any event in the conversation\n                var amountWithCurrency = g.LastOrDefault(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency));\n                if (amountWithCurrency?.IsChargeable == true) // only count billable windows\n                {\n                    var cur = amountWithCurrency.PriceCurrency!.ToUpperInvariant();\n                    var amt = amountWithCurrency.PriceAmount!.Value;\n                    spendByCurrency[cur] = spendByCurrency.TryGetValue(cur, out var sum) ? sum + amt : amt;\n                }\n            }\n\n            // Compose DTO\n            var dto = new BillingSnapshotDto\n            {\n                TotalMessages = totalMessages,\n                // These two are now \"window\"-level metrics (conversations) – most accurate for billing with Meta.\n                ChargeableMessages = chargeableWindows,\n                FreeMessages = freeWindows,\n                CountByCategory = countByCategory,\n                SpendByCurrency = spendByCurrency\n            };\n\n            return dto;\n        }\n    }\n}\n\n\n//using System;\n//using System.Linq;\n//using System.Threading.Tasks;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api;\n//using xbytechat_api.Features.Billing.DTOs;\n\n//namespace xbytechat_api.Features.Billing.Services\n//{\n//    public class BillingReadService : IBillingReadService\n//    {\n//        private readonly AppDbContext _db;\n//        public BillingReadService(AppDbContext db) => _db = db;\n\n//        public async Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to)\n//        {\n//            var fromDt = from.ToDateTime(TimeOnly.MinValue, DateTimeKind.Utc);\n//            var toDt = to.ToDateTime(TimeOnly.MaxValue, DateTimeKind.Utc);\n\n//            var q = _db.MessageLogs.AsNoTracking()\n//                    .Where(x => x.BusinessId == businessId && x.CreatedAt >= fromDt && x.CreatedAt <= toDt);\n\n//            var list = await q.Select(x => new {\n//                x.IsChargeable,\n//                x.ConversationCategory,\n//                x.PriceAmount,\n//                x.PriceCurrency\n//            }).ToListAsync();\n\n//            var dto = new BillingSnapshotDto\n//            {\n//                TotalMessages = list.Count,\n//                ChargeableMessages = list.Count(x => x.IsChargeable == true),\n//                FreeMessages = list.Count(x => x.IsChargeable == false)\n//            };\n\n//            dto.CountByCategory = list\n//                .GroupBy(x => string.IsNullOrWhiteSpace(x.ConversationCategory) ? \"unknown\" : x.ConversationCategory!.ToLowerInvariant())\n//                .ToDictionary(g => g.Key, g => g.Count());\n\n//            dto.SpendByCurrency = list\n//                .Where(x => x.PriceAmount.HasValue && !string.IsNullOrWhiteSpace(x.PriceCurrency))\n//                .GroupBy(x => x.PriceCurrency!)\n//                .ToDictionary(g => g.Key, g => g.Sum(v => v.PriceAmount!.Value));\n\n//            return dto;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingIngestService.cs",
      "sha256": "8678a1ec3a5979b124caa81faa47d93d5ca21bd8c0d97bf35a8d55bb50824bdf",
      "language": "csharp",
      "size": 416,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingIngestService\n    {\n        Task IngestFromSendResponseAsync(Guid businessId, Guid messageLogId, string provider, string rawResponseJson);\n        Task IngestFromWebhookAsync(Guid businessId, string provider, string payloadJson);\n        \n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Billing/Services/IBillingReadService.cs",
      "sha256": "146ab2ebc0dea7d43cd6d050c51c28118cf4c7655b369657e198861aa6c9c3ca",
      "language": "csharp",
      "size": 306,
      "content": "using System;\nusing System.Threading.Tasks;\nusing xbytechat_api.Features.Billing.DTOs;\n\nnamespace xbytechat_api.Features.Billing.Services\n{\n    public interface IBillingReadService\n    {\n        Task<BillingSnapshotDto> GetBusinessBillingSnapshotAsync(Guid businessId, DateOnly from, DateOnly to);\n    }\n}\n"
    }
  ]
}
