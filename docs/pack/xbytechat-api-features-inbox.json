{
  "name": "xbytechat-api/Features/Inbox",
  "generatedAt": "2025-09-12 10:33:04 +00:00",
  "files": [
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/InboxController.cs",
      "sha256": "3d0e927289537b66319358696495d025ff3f9a5f6c17877f661a19cd1dec1f3e",
      "language": "csharp",
      "size": 9876,
      "content": "using Microsoft.AspNetCore.Mvc;\nusing System;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers;\nusing Microsoft.AspNetCore.Authorization;\nusing xbytechat.api.Shared;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.Hubs;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [ApiController]\n    [Route(\"api/inbox\")]\n    public class InboxController : ControllerBase\n    {\n        private readonly IInboxService _inboxService;\n        private readonly IHubContext<InboxHub> _hubContext; // ✅ for SignalR push\n        private readonly IUnreadCountService _unreadCountService;\n\n        public InboxController(\n            IInboxService inboxService,\n            IHubContext<InboxHub> hubContext,\n            IUnreadCountService unreadCountService)\n        {\n            _inboxService = inboxService;\n            _hubContext = hubContext;\n            _unreadCountService = unreadCountService;\n        }\n\n        /// <summary>\n        /// Send a new message from UI or system.\n        /// </summary>\n        [HttpPost(\"send\")]\n        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Message content is required.\");\n\n            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Receive a message from external source (e.g., WhatsApp webhook).\n        /// </summary>\n        [HttpPost(\"receive\")]\n        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n        {\n            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n                return BadRequest(\"Incoming message content is required.\");\n\n            // ✅ Ensure IDs are present\n            if (dto.BusinessId == Guid.Empty || dto.ContactId == Guid.Empty)\n                return BadRequest(\"BusinessId and ContactId are required.\");\n\n            // 1) Persist the inbound message\n            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n            // 2) Push the real-time message to everyone in this business\n            var groupName = $\"business_{dto.BusinessId}\";\n            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n            {\n                contactId = dto.ContactId,\n                messageContent = dto.MessageBody,  // ✅ aligned with frontend\n                from = dto.RecipientPhone,\n                status = \"Delivered\",\n                sentAt = DateTime.UtcNow,\n                isIncoming = true\n            });\n\n            // 3) Tell clients to refresh their own unread snapshot (per-user)\n            //    We cannot compute per-user unread here (no userId in webhook context),\n            //    so we emit a refresh signal that clients handle by calling GET /inbox/unread-counts.\n            await _hubContext.Clients.Group(groupName)\n                .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n\n            return Ok(result);\n        }\n\n        /// <summary>\n        /// Fetch message history between agent and customer using business token + contactId.\n        /// </summary>\n        [HttpGet(\"messages\")]\n        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n            return Ok(messages);\n        }\n\n        [HttpGet(\"conversation\")]\n        public async Task<IActionResult> GetConversation(\n            [FromQuery] Guid businessId,\n            [FromQuery] string userPhone,\n            [FromQuery] string contactPhone)\n        {\n            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n                return BadRequest(\"Invalid input.\");\n\n            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n            return Ok(messages);\n        }\n\n        [HttpPost(\"mark-read\")]\n        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n        {\n            if (contactId == Guid.Empty)\n                return BadRequest(\"ContactId is required.\");\n\n            var businessId = User.GetBusinessId();\n            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n            return Ok();\n        }\n\n        [HttpGet(\"unread-counts\")]\n        public async Task<IActionResult> GetUnreadCounts()\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == null || userId == null)\n                return Unauthorized();\n\n            var counts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n            return Ok(counts);\n        }\n    }\n}\n\n//using Microsoft.AspNetCore.Mvc;\n//using System;\n//using System.Threading.Tasks;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.Inbox.Services;\n//using xbytechat.api.Helpers;\n//using Microsoft.AspNetCore.Authorization;\n//using xbytechat.api.Shared;\n//using Microsoft.AspNetCore.SignalR;\n//using xbytechat.api.Features.Inbox.Hubs;\n//namespace xbytechat.api.Features.Inbox.Controllers\n//{\n//    [ApiController]\n//    [Route(\"api/inbox\")]\n//    public class InboxController : ControllerBase\n//    {\n//        private readonly IInboxService _inboxService;\n//        private readonly IHubContext<InboxHub> _hubContext; // ✅ for SignalR push\n//        private readonly IUnreadCountService _unreadCountService;\n//        public InboxController(IInboxService inboxService, IHubContext<InboxHub> hubContext, IUnreadCountService unreadCountService)\n//        {\n//            _inboxService = inboxService;\n//            _hubContext = hubContext;\n//            _unreadCountService = unreadCountService;   \n//        }\n\n//        /// <summary>\n//        /// Send a new message from UI or system.\n//        /// </summary>\n//        [HttpPost(\"send\")]\n//        public async Task<IActionResult> SendMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Message content is required.\");\n\n//            var result = await _inboxService.SaveOutgoingMessageAsync(dto);\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Receive a message from external source (e.g., WhatsApp webhook).\n//        /// </summary>\n//        [HttpPost(\"receive\")]\n//        public async Task<IActionResult> ReceiveMessage([FromBody] InboxMessageDto dto)\n//        {\n//            if (dto == null || string.IsNullOrWhiteSpace(dto.MessageBody))\n//                return BadRequest(\"Incoming message content is required.\");\n\n//            var result = await _inboxService.SaveIncomingMessageAsync(dto);\n\n//            // ✅ Also broadcast in real-time to clients in this business group\n//            var groupName = $\"business_{dto.BusinessId}\";\n//            await _hubContext.Clients.Group(groupName).SendAsync(\"ReceiveInboxMessage\", new\n//            {\n//                contactId = dto.ContactId,\n//                messageContent = dto.MessageBody,  // ✅ aligned with frontend\n//                from = dto.RecipientPhone,\n//                status = \"Delivered\",\n//                sentAt = DateTime.UtcNow,\n//                isIncoming = true\n//            });\n\n//            return Ok(result);\n//        }\n\n//        /// <summary>\n//        /// Fetch message history between agent and customer using business token + contactId.\n//        /// </summary>\n//        [HttpGet(\"messages\")]\n//        public async Task<IActionResult> GetMessagesByContact([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            var messages = await _inboxService.GetMessagesByContactAsync(businessId, contactId);\n//            return Ok(messages);\n//        }\n\n//        [HttpGet(\"conversation\")]\n//        public async Task<IActionResult> GetConversation(\n//            [FromQuery] Guid businessId,\n//            [FromQuery] string userPhone,\n//            [FromQuery] string contactPhone)\n//        {\n//            if (businessId == Guid.Empty || string.IsNullOrWhiteSpace(userPhone) || string.IsNullOrWhiteSpace(contactPhone))\n//                return BadRequest(\"Invalid input.\");\n\n//            var messages = await _inboxService.GetConversationAsync(businessId, userPhone, contactPhone);\n//            return Ok(messages);\n//        }\n\n//        [HttpPost(\"mark-read\")]\n//        public async Task<IActionResult> MarkMessagesAsRead([FromQuery] Guid contactId)\n//        {\n//            if (contactId == Guid.Empty)\n//                return BadRequest(\"ContactId is required.\");\n\n//            var businessId = User.GetBusinessId();\n//            await _inboxService.MarkMessagesAsReadAsync(businessId, contactId);\n//            return Ok();\n//        }\n\n\n//        [HttpGet(\"unread-counts\")]\n//        public async Task<IActionResult> GetUnreadCounts()\n//        {\n//            var businessId = User.GetBusinessId();\n//            var userId = User.GetUserId();\n\n//            if (businessId == null || userId == null)\n//                return Unauthorized();\n\n//            var counts = await _unreadCountService.GetUnreadCountsAsync(\n//                businessId, userId);\n\n//            return Ok(counts);\n//        }\n//    }\n//}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Controllers/QuickRepliesController.cs",
      "sha256": "af36e1fce52678fc893c61ffb94a31ad834c0b827a9d210433a6836fbad241fe",
      "language": "csharp",
      "size": 3632,
      "content": "using Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.Mvc;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Services;\nusing xbytechat.api.Helpers; // for User.GetBusinessId(), GetUserId()\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Controllers\n{\n    [Authorize]\n    [ApiController]\n    [Route(\"api/quick-replies\")]\n    public class QuickRepliesController : ControllerBase\n    {\n        private readonly IQuickReplyService _service;\n\n        public QuickRepliesController(IQuickReplyService service) => _service = service;\n\n        [HttpGet]\n        public async Task<IActionResult> GetAll([FromQuery] string? q = null,\n            [FromQuery] string scope = \"all\")\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n\n            if (businessId == null || userId == null) return Unauthorized();\n\n            bool includeBusiness = scope is \"all\" or \"business\";\n            bool includePersonal = scope is \"all\" or \"personal\";\n\n            var list = await _service.GetAllAsync(businessId, userId, q, includeBusiness, includePersonal);\n            return Ok(list);\n        }\n\n        [HttpPost]\n        public async Task<IActionResult> Create([FromBody] QuickReplyCreateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n            if (businessId == null || userId == null) return Unauthorized();\n\n            Log.Information(\"Create QuickReply requested by {@Actor}\", actor);\n            var result = await _service.CreateAsync(businessId, userId, actor, dto);\n            return Ok(result);\n        }\n\n        [HttpPut(\"{id:guid}\")]\n        public async Task<IActionResult> Update([FromRoute] Guid id, [FromBody] QuickReplyUpdateDto dto)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n            if (businessId == null || userId == null) return Unauthorized();\n\n            Log.Information(\"Update QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.UpdateAsync(businessId, userId, actor, id, dto);\n            return Ok(result);\n        }\n\n        [HttpPatch(\"{id:guid}/toggle\")]\n        public async Task<IActionResult> Toggle([FromRoute] Guid id, [FromQuery] bool active = true)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n            if (businessId == null || userId == null) return Unauthorized();\n\n            Log.Information(\"Toggle QuickReply {@QuickReplyId} -> {Active} by {@Actor}\", id, active, actor);\n            var result = await _service.ToggleActiveAsync(businessId, userId, actor, id, active);\n            return Ok(result);\n        }\n\n        [HttpDelete(\"{id:guid}\")]\n        public async Task<IActionResult> Delete([FromRoute] Guid id)\n        {\n            var businessId = User.GetBusinessId();\n            var userId = User.GetUserId();\n            var actor = User.Identity?.Name ?? userId.ToString() ?? \"system\";\n\n            if (businessId == null || userId == null) return Unauthorized();\n\n            Log.Information(\"Delete QuickReply {@QuickReplyId} by {@Actor}\", id, actor);\n            var result = await _service.DeleteAsync(businessId, userId, actor, id);\n            return Ok(result);\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/InboxMessageDto.cs",
      "sha256": "aef9beda43a0dc4f1c619514c3289f6c68a6daf10fe5cdd46ad13c474be29c0b",
      "language": "csharp",
      "size": 881,
      "content": "// 📄 File: Features/Inbox/DTOs/InboxMessageDto.cs\nusing System;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class InboxMessageDto\n    {\n        public Guid BusinessId { get; set; }\n        public string RecipientPhone { get; set; }\n        public string MessageBody { get; set; }\n        public Guid? ContactId { get; set; }\n        public Guid? CTAFlowStepId { get; set; }\n        public Guid? CTAFlowConfigId { get; set; }\n        public Guid? CampaignId { get; set; }\n        public string? CampaignName { get; set; }       // 🆕 To show in chat bubble\n        public string? RenderedBody { get; set; }\n\n        public bool IsIncoming { get; set; }            // 🆕 Needed for bubble side\n        public string Status { get; set; }              // 🆕 For message ticks\n        public DateTime SentAt { get; set; }            // 🆕 For timestamp\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/QuickReplyDtos.cs",
      "sha256": "90ec17a9a8c369db09ac8c28b8296c766c31ea78badd34e53397522a8bc08e00",
      "language": "csharp",
      "size": 1460,
      "content": "using System.ComponentModel.DataAnnotations;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    public sealed class QuickReplyDto\n    {\n        public Guid Id { get; set; }\n        public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }\n        public QuickReplyScope Scope { get; set; }\n        public string Title { get; set; } = string.Empty;\n        public string Body { get; set; } = string.Empty;\n        public string? TagsCsv { get; set; }\n        public string? Language { get; set; }\n        public bool IsActive { get; set; }\n        public DateTime UpdatedAt { get; set; }\n    }\n\n    public sealed class QuickReplyCreateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n    }\n\n    public sealed class QuickReplyUpdateDto\n    {\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }\n        public bool IsActive { get; set; } = true;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendInboxMessageDto.cs",
      "sha256": "1ad0e0e61748e9f9e1fab32e1fe533c57a6c8d586694e55aa5b531359804de90",
      "language": "csharp",
      "size": 462,
      "content": "using System;\nusing System.ComponentModel.DataAnnotations;\n\nnamespace xbytechat.api.Features.Inbox.DTOs\n{\n    /// <summary>\n    /// DTO sent from frontend when a user sends a new message.\n    /// </summary>\n    public class SendInboxMessageDto\n    {\n        [Required]\n        public Guid ContactId { get; set; }\n\n        [Required]\n        public string MessageBody { get; set; }\n\n        public string? MediaUrl { get; set; } // Optional image or file\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/SendMessageInputDto.cs",
      "sha256": "3c76bd2b5ce839064134b72aa2114c14c73a98109c680671f5e7c463867f221a",
      "language": "csharp",
      "size": 249,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class SendMessageInputDto\n    {\n        public Guid ContactId { get; set; } // 🔁 REMOVE the \"?\" (nullable) unless needed\n        public string Message { get; set; } = string.Empty;\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/DTOs/TextOnlyMessageSendDto.cs",
      "sha256": "2d322145a5e6410decb150b108c7d74a656201d9be027b99b02d1c261b4ed4fc",
      "language": "csharp",
      "size": 247,
      "content": "namespace xbytechat.api.Features.Inbox.DTOs\n{\n    public class TextOnlyMessageSendDto\n    {\n        public Guid BusinessId { get; set; }\n\n        public string RecipientNumber { get; set; }\n\n        public string TextContent { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Hubs/InboxHub.cs",
      "sha256": "aa347668506aecb58c141c9f226e810bc449891a2ea9fbd75d7611279ac3e716",
      "language": "csharp",
      "size": 12833,
      "content": "// 📄 xbytechat.api/Features/Inbox/InboxHub.cs\nusing Microsoft.AspNetCore.Authorization;\nusing Microsoft.AspNetCore.SignalR;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessagesEngine.DTOs;\nusing xbytechat.api.Features.MessagesEngine.Services;\nusing xbytechat.api.Shared;\nusing xbytechat.api.Models;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Features.Inbox.Services;\nusing System;\nusing System.Linq;\n\nnamespace xbytechat.api.Features.Inbox.Hubs\n{\n    [Authorize]\n    public class InboxHub : Hub\n    {\n        private readonly AppDbContext _db;\n        private readonly IMessageEngineService _messageService;\n        private readonly IUnreadCountService _unreadCountService;\n\n        public InboxHub(AppDbContext db, IMessageEngineService messageService, IUnreadCountService unreadCountService)\n        {\n            _db = db;\n            _messageService = messageService;\n            _unreadCountService = unreadCountService;\n        }\n\n        public override async Task OnConnectedAsync()\n        {\n            var businessId = Context.User.GetBusinessId(); // non-nullable Guid in your codebase\n\n            if (businessId == Guid.Empty)\n            {\n                Console.WriteLine(\"❌ InboxHub connect: missing BusinessId claim, skipping group join.\");\n                await base.OnConnectedAsync();\n                return;\n            }\n\n            var groupName = $\"business_{businessId}\";\n            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n            Console.WriteLine($\"✅ Connected to group: {groupName}\");\n\n            await base.OnConnectedAsync();\n        }\n\n        public override async Task OnDisconnectedAsync(Exception? exception)\n        {\n            var businessId = Context.User.GetBusinessId();\n            if (businessId != Guid.Empty)\n            {\n                var groupName = $\"business_{businessId}\";\n                try { await Groups.RemoveFromGroupAsync(Context.ConnectionId, groupName); } catch { /* no-op */ }\n                Console.WriteLine($\"⚪ Disconnected from group: {groupName} (conn: {Context.ConnectionId})\");\n            }\n\n            await base.OnDisconnectedAsync(exception);\n        }\n\n        public async Task SendMessageToContact(SendMessageInputDto dto)\n        {\n            Console.WriteLine(\"📩 Raw DTO payload:\");\n            Console.WriteLine($\"ContactId: {dto.ContactId}, Message: {dto.Message}\");\n\n            // Guid is non-nullable → compare to Guid.Empty\n            if (dto.ContactId == Guid.Empty || string.IsNullOrWhiteSpace(dto.Message))\n            {\n                Console.WriteLine(\"❌ Invalid contact or empty message.\");\n                return;\n            }\n\n            var businessId = Context.User.GetBusinessId();\n            var userId = Context.User.GetUserId();\n\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n            {\n                Console.WriteLine(\"❌ Missing BusinessId/UserId in hub context.\");\n                return;\n            }\n\n            // ✅ Lookup recipient phone number from Contact table\n            var contact = await _db.Contacts\n                .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n                .FirstOrDefaultAsync();\n\n            if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n            {\n                Console.WriteLine($\"❌ Contact not found or missing phone number. ContactId: {dto.ContactId}\");\n                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n                {\n                    contactId = dto.ContactId,\n                    messageContent = dto.Message,   // aligned with frontend\n                    from = userId,\n                    status = \"Failed\",\n                    error = \"Invalid contact\"\n                });\n                return;\n            }\n\n            // ✅ Prepare DTO for WhatsApp sending\n            var sendDto = new TextMessageSendDto\n            {\n                BusinessId = businessId,\n                ContactId = dto.ContactId,\n                RecipientNumber = contact.PhoneNumber,\n                TextContent = dto.Message\n            };\n\n            // 🚀 Send via WhatsApp API and save to MessageLogs\n            var result = await _messageService.SendTextDirectAsync(sendDto);\n\n            // ✅ Unified payload (outbound)\n            var inboxMessage = new\n            {\n                contactId = dto.ContactId,\n                messageContent = dto.Message,\n                from = userId,\n                status = result.Success ? \"Sent\" : \"Failed\",\n                sentAt = DateTime.UtcNow,\n                logId = result.LogId,\n                senderId = userId,\n                isIncoming = false\n            };\n\n            // Sender\n            await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n            // Others in business\n            var groupName = $\"business_{businessId}\";\n            await Clients.GroupExcept(groupName, Context.ConnectionId)\n                .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n        }\n\n        public async Task MarkAsRead(Guid contactId)\n        {\n            Console.WriteLine($\"🟢 MarkAsRead triggered for ContactId: {contactId}\");\n            var userId = Context.User.GetUserId();\n            var businessId = Context.User.GetBusinessId();\n\n            if (userId == Guid.Empty || businessId == Guid.Empty) return;\n\n            var now = DateTime.UtcNow;\n\n            // Upsert ContactRead\n            var readEntry = await _db.ContactReads\n                .FirstOrDefaultAsync(r => r.ContactId == contactId && r.UserId == userId);\n\n            if (readEntry == null)\n            {\n                _db.ContactReads.Add(new ContactRead\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    UserId = userId,\n                    LastReadAt = now\n                });\n            }\n            else\n            {\n                readEntry.LastReadAt = now;\n            }\n\n            await _db.SaveChangesAsync();\n\n            // Per-agent unread snapshot\n            var unreadCounts = await _unreadCountService.GetUnreadCountsAsync(businessId, userId);\n\n            var groupName = $\"business_{businessId}\";\n\n            // Send the caller their map…\n            await Clients.User(userId.ToString())\n                .SendAsync(\"UnreadCountChanged\", unreadCounts);\n\n            // …and signal others to refresh their own\n            await Clients.GroupExcept(groupName, Context.ConnectionId)\n                .SendAsync(\"UnreadCountChanged\", new { refresh = true });\n        }\n    }\n}\n\n\n//// 📄 xbytechat.api/Features/Inbox/InboxHub.cs\n\n//using Microsoft.AspNetCore.Authorization;\n//using Microsoft.AspNetCore.SignalR;\n//using xbytechat.api.Features.Inbox.DTOs;\n//using xbytechat.api.Features.MessagesEngine.DTOs;\n//using xbytechat.api.Features.MessagesEngine.Services;\n//using xbytechat.api.Shared;\n//using xbytechat.api.Models;\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api.Features.Inbox.Models;\n//using xbytechat.api.Features.Inbox.Services;\n\n//namespace xbytechat.api.Features.Inbox.Hubs\n//{\n//    [Authorize]\n//    public class InboxHub : Hub\n//    {\n//        private readonly AppDbContext _db;\n//        private readonly IMessageEngineService _messageService;\n//        private readonly IUnreadCountService _unreadCountService;\n//        public InboxHub(AppDbContext db, IMessageEngineService messageService, IUnreadCountService unreadCountService)\n//        {\n//            _db = db;\n//            _messageService = messageService;\n//            _unreadCountService = unreadCountService;\n//        }\n\n//        public override async Task OnConnectedAsync()\n//        {\n//            var businessId = Context.User.GetBusinessId();\n//            var groupName = $\"business_{businessId}\";\n\n//            await Groups.AddToGroupAsync(Context.ConnectionId, groupName);\n//            Console.WriteLine($\"✅ Connected to group: {groupName}\");\n\n//            await base.OnConnectedAsync();\n//        }\n\n//        public async Task SendMessageToContact(SendMessageInputDto dto)\n//        {\n//            Console.WriteLine(\"📩 Raw DTO payload:\");\n//            Console.WriteLine($\"ContactId: {dto.ContactId}, Message: {dto.Message}\");\n\n//            if (dto.ContactId == null || string.IsNullOrWhiteSpace(dto.Message))\n//            {\n//                Console.WriteLine(\"❌ Invalid contact or empty message.\");\n//                return;\n//            }\n\n//            var businessId = Context.User.GetBusinessId();\n//            var userId = Context.User.GetUserId();\n\n//            // ✅ Lookup recipient phone number from Contact table\n//            var contact = await _db.Contacts\n//                .Where(c => c.BusinessId == businessId && c.Id == dto.ContactId)\n//                .FirstOrDefaultAsync();\n\n//            if (contact == null || string.IsNullOrWhiteSpace(contact.PhoneNumber))\n//            {\n//                Console.WriteLine($\"❌ Contact not found or missing phone number. ContactId: {dto.ContactId}\");\n//                await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", new\n//                {\n//                    contactId = dto.ContactId,\n//                    messageContent = dto.Message,   // ✅ aligned with frontend\n//                    from = userId,\n//                    status = \"Failed\",\n//                    error = \"Invalid contact\"\n//                });\n//                return;\n//            }\n\n//            // ✅ Prepare DTO for WhatsApp sending\n//            var sendDto = new TextMessageSendDto\n//            {\n//                BusinessId = businessId,\n//                ContactId = dto.ContactId,\n//                RecipientNumber = contact.PhoneNumber,\n//                TextContent = dto.Message\n//            };\n\n//            // 🚀 Send via WhatsApp API and save to MessageLogs\n//            var result = await _messageService.SendTextDirectAsync(sendDto);\n\n//            // ✅ Construct unified message payload\n//            var inboxMessage = new\n//            {\n//                contactId = dto.ContactId,\n//                messageContent = dto.Message,     // ✅ aligned with frontend\n//                from = userId,\n//                status = result.Success ? \"Sent\" : \"Failed\",\n//                sentAt = DateTime.UtcNow,\n//                logId = result.LogId,\n//                senderId = userId,\n//                isIncoming = false\n//            };\n\n//            // ✅ Notify sender only\n//            await Clients.Caller.SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n\n//            // ✅ Notify others in group (for unread update)\n//            var groupName = $\"business_{businessId}\";\n//            await Clients.GroupExcept(groupName, Context.ConnectionId)\n//                .SendAsync(\"ReceiveInboxMessage\", inboxMessage);\n//        }\n\n\n//        public async Task MarkAsRead(Guid contactId)\n//        {\n//            Console.WriteLine($\"🟢 MarkAsRead triggered for ContactId: {contactId}\");\n//            var userId = Context.User?.GetUserId();\n//            var businessId = Context.User?.GetBusinessId();\n\n//            if (userId == null || businessId == null || businessId == Guid.Empty)\n//                return;\n\n//            var userGuid = userId.Value;\n//            var businessGuid = businessId.Value;\n//            var now = DateTime.UtcNow;\n\n//            // ✅ Insert or Update ContactRead\n//            var readEntry = await _db.ContactReads\n//                .FirstOrDefaultAsync(r => r.ContactId == contactId && r.UserId == userGuid);\n\n//            if (readEntry == null)\n//            {\n//                _db.ContactReads.Add(new ContactRead\n//                {\n//                    Id = Guid.NewGuid(),\n//                    BusinessId = businessGuid,\n//                    ContactId = contactId,\n//                    UserId = userGuid,\n//                    LastReadAt = now\n//                });\n//            }\n//            else\n//            {\n//                readEntry.LastReadAt = now;\n//            }\n\n//            await _db.SaveChangesAsync();\n\n//            // ✅ Use service for unread calculation\n//            var unreadCounts = await _unreadCountService.GetUnreadCountsAsync(businessGuid, userGuid);\n\n//            // ✅ Broadcast to user and group\n//            var groupName = $\"business_{businessGuid}\";\n//            await Clients.User(userGuid.ToString())\n//                .SendAsync(\"UnreadCountChanged\", unreadCounts);\n\n//            await Clients.GroupExcept(groupName, Context.ConnectionId)\n//                .SendAsync(\"UnreadCountChanged\", unreadCounts);\n//        }\n//    }\n//}\n\n\n\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ChatSessionState.cs",
      "sha256": "fa6184f30e1715455ee5b84ae75264c5cc2d46ed4f1721014141ed9036dfda64",
      "language": "csharp",
      "size": 500,
      "content": "namespace xbytechat.api.Features.Inbox.Models\n{\n    public class ChatSessionState\n    {\n        public Guid Id { get; set; } = Guid.NewGuid();\n        public Guid BusinessId { get; set; }\n        public Guid ContactId { get; set; }\n\n        public string Mode { get; set; } = \"automation\"; // values: \"automation\" | \"agent\"\n        public DateTime LastUpdatedAt { get; set; } = DateTime.UtcNow;\n\n        // Optional: track who switched the mode\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/ContactRead.cs",
      "sha256": "aa4dd9980bc6485cf1c4981bf7dfff84f32dcfbacc6c9dbc3be4ba0429c065c6",
      "language": "csharp",
      "size": 474,
      "content": "using System;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public class ContactRead\n    {\n        public Guid Id { get; set; }\n\n        // 🔗 FK to Contact\n        public Guid ContactId { get; set; }\n\n        // 🔗 FK to User (Agent)\n        public Guid UserId { get; set; }\n\n        // 📅 Last time this agent opened this contact's chat\n        public DateTime LastReadAt { get; set; } = DateTime.UtcNow;\n\n        public Guid BusinessId { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Models/QuickReply.cs",
      "sha256": "8b5cba0c3d3af40a8abf6fd445648c0671b6fb294489fcae8c2d8b438291e285",
      "language": "csharp",
      "size": 1180,
      "content": "using System.ComponentModel.DataAnnotations;\nusing System.ComponentModel.DataAnnotations.Schema;\n\nnamespace xbytechat.api.Features.Inbox.Models\n{\n    public enum QuickReplyScope { Personal = 0, Business = 2 }\n\n    [Table(\"QuickReplies\")]\n    public class QuickReply\n    {\n        [Key] public Guid Id { get; set; }\n        [Required] public Guid BusinessId { get; set; }\n        public Guid? OwnerUserId { get; set; }                // null for Business scope\n\n        [Required, MaxLength(120)] public string Title { get; set; } = string.Empty;\n        [Required] public string Body { get; set; } = string.Empty;\n\n        [MaxLength(240)] public string? TagsCsv { get; set; }\n        [MaxLength(8)] public string? Language { get; set; }   // e.g. \"en\", \"hi\"\n\n        public QuickReplyScope Scope { get; set; } = QuickReplyScope.Personal;\n        public bool IsActive { get; set; } = true;\n        public bool IsDeleted { get; set; } = false;\n\n        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;\n        public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;\n        public string? CreatedBy { get; set; }\n        public string? UpdatedBy { get; set; }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/IInboxRepository.cs",
      "sha256": "d057575abdee0fe95972b5dcfafa6e7637884f526bb108c43b06bbb1b2d2a5bd",
      "language": "csharp",
      "size": 839,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public interface IInboxRepository\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone);\n        Task AddMessageAsync(MessageLog message);\n        Task SaveChangesAsync();\n        Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Repositories/InboxRepository.cs",
      "sha256": "06153117fc580e3c5239560868ec16dd5f41d963a159eec8ad96f569afa9bb29",
      "language": "csharp",
      "size": 4226,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Repositories\n{\n    public class InboxRepository : IInboxRepository\n    {\n        private readonly AppDbContext _context;\n\n        public InboxRepository(AppDbContext context)\n        {\n            _context = context;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .Take(limit)\n                .ToListAsync();\n        }\n\n        public async Task<MessageLog?> GetLastMessageAsync(Guid businessId, string userPhone, string contactPhone)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            ((m.RecipientNumber == contactPhone && m.IsIncoming == false) ||\n                             (m.RecipientNumber == userPhone && m.IsIncoming == true)))\n                .OrderByDescending(m => m.CreatedAt)\n                .FirstOrDefaultAsync();\n        }\n\n        public async Task AddMessageAsync(MessageLog message)\n        {\n            await _context.MessageLogs.AddAsync(message);\n        }\n\n        public async Task SaveChangesAsync()\n        {\n            await _context.SaveChangesAsync();\n        }\n        public async Task<List<MessageLog>> GetMessagesByContactIdAsync(Guid businessId, Guid contactId)\n        {\n            return await _context.MessageLogs\n                 .Include(m => m.SourceCampaign)\n                .Where(m => m.BusinessId == businessId && m.ContactId == contactId)\n                .OrderBy(m => m.CreatedAt)\n                .ToListAsync();\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\" &&\n                            m.ContactId != null) // ✅ ensure not null\n                .GroupBy(m => m.ContactId!.Value) // ✅ safe cast to Guid\n                .Select(g => new { ContactId = g.Key, Count = g.Count() })\n                .ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            var unreadMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId &&\n                            m.ContactId == contactId &&\n                            m.IsIncoming &&\n                            m.Status != \"Read\")\n                .ToListAsync(); \n            foreach (var msg in unreadMessages)\n                msg.Status = \"Read\";\n\n            await _context.SaveChangesAsync();\n        }\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n                    var contactReads = await _context.ContactReads\n             .Where(r => r.UserId == userId)\n             .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n            // 🟢 Fetch from DB first (no logic yet)\n            var allMessages = await _context.MessageLogs\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .ToListAsync();\n\n            // 🧠 Now calculate in memory\n            var unreadCounts = allMessages\n                .GroupBy(m => m.ContactId!.Value)\n                .ToDictionary(\n                    g => g.Key,\n                    g => g.Count(m =>\n                        !contactReads.ContainsKey(g.Key) ||\n                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n                );\n\n\n            return unreadCounts;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/AgentAssignmentService.cs",
      "sha256": "de9062b213ba63cb8695f407ede5c9e8d52a589e0dc1c7a4c5c79fd243389e4e",
      "language": "csharp",
      "size": 1104,
      "content": "using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Logging;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class AgentAssignmentService : IAgentAssignmentService\n    {\n        private readonly ILogger<AgentAssignmentService> _logger;\n\n        public AgentAssignmentService(ILogger<AgentAssignmentService> logger)\n        {\n            _logger = logger;\n        }\n\n        public Task<bool> IsAgentAvailableAsync(Guid businessId)\n        {\n            // 🔧 TODO: Replace with real logic based on your agent pool\n            _logger.LogInformation(\"Checking if agent is available for business {BusinessId}\", businessId);\n            return Task.FromResult(true); // Assume always available for MVP\n        }\n\n        public Task AssignAgentToContactAsync(Guid businessId, Guid contactId)\n        {\n            // 🔧 TODO: Save agent-contact assignment to DB or notify a human agent\n            _logger.LogInformation(\"Assigning agent to contact {ContactId} for business {BusinessId}\", contactId, businessId);\n            return Task.CompletedTask;\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/ChatSessionStateService.cs",
      "sha256": "5c6672bd07d87501ca9d46e38085cbec03455bae6cc943c8b8df505a7c73808e",
      "language": "csharp",
      "size": 2964,
      "content": "using Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Features.AutoReplyBuilder.Models;\nusing xbytechat.api.Features.Inbox.Models;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class ChatSessionStateService : IChatSessionStateService\n    {\n        private readonly AppDbContext _db;\n\n        public ChatSessionStateService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        // ✅ Returns current chat mode: \"agent\" or \"auto\"\n        public async Task<string> GetChatModeAsync(Guid businessId, Guid contactId)\n        {\n            var session = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            return session?.Mode ?? \"auto\"; // Default to auto\n        }\n\n        // ✅ Switches to agent mode\n        public async Task SwitchToAgentModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"agent\");\n        }\n\n        // ✅ Switches to automation mode\n        public async Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId)\n        {\n            await UpsertChatModeAsync(businessId, contactId, \"auto\");\n        }\n\n        // ✅ Shared logic to insert or update session state\n        private async Task UpsertChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var existing = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(s => s.BusinessId == businessId && s.ContactId == contactId);\n\n            if (existing != null)\n            {\n                existing.Mode = mode;\n                existing.LastUpdatedAt = DateTime.UtcNow;\n            }\n            else\n            {\n                _db.ChatSessionStates.Add(new ChatSessionState\n                {\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                });\n            }\n\n            await _db.SaveChangesAsync();\n        }\n\n        public async Task SetChatModeAsync(Guid businessId, Guid contactId, string mode)\n        {\n            var state = await _db.ChatSessionStates\n                .FirstOrDefaultAsync(x => x.BusinessId == businessId && x.ContactId == contactId);\n\n            if (state == null)\n            {\n                // Insert new if not exists\n                state = new ChatSessionState\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    ContactId = contactId,\n                    Mode = mode,\n                    LastUpdatedAt = DateTime.UtcNow\n                };\n                _db.ChatSessionStates.Add(state);\n            }\n            else\n            {\n                state.Mode = mode;\n                state.LastUpdatedAt = DateTime.UtcNow;\n            }\n\n            await _db.SaveChangesAsync();\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IAgentAssignmentService.cs",
      "sha256": "1eae6f670d61efc4cd6f430a93cf7188c26a6d521ae49cd50ab926aa5bc027ee",
      "language": "csharp",
      "size": 286,
      "content": "using System;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IAgentAssignmentService\n    {\n        Task<bool> IsAgentAvailableAsync(Guid businessId);\n        Task AssignAgentToContactAsync(Guid businessId, Guid contactId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IChatSessionStateService.cs",
      "sha256": "3ade6df9341ebca2e5a478331e57315273317bc803a529a4e068cccc323f1693",
      "language": "csharp",
      "size": 404,
      "content": "namespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IChatSessionStateService\n    {\n        Task<string> GetChatModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAgentModeAsync(Guid businessId, Guid contactId);\n        Task SwitchToAutomationModeAsync(Guid businessId, Guid contactId);\n        Task SetChatModeAsync(Guid businessId, Guid contactId, string mode);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IInboxService.cs",
      "sha256": "58b2b14fb055263d0f08348900a55c5cbd62c16609e1b4ba082beb34a84efc49",
      "language": "csharp",
      "size": 885,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.MessageManagement.DTOs;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IInboxService\n    {\n        Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50);\n        Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto);\n        Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto);\n        Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId);\n        Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId);\n        Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId);\n\n        Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId);\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/InboxService.cs",
      "sha256": "8bbfdb66619466ec1c134351db9fc8b8fd32a8d30a45da7c3d142e41f17ae8f7",
      "language": "csharp",
      "size": 3941,
      "content": "using Microsoft.EntityFrameworkCore;\nusing System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Repositories;\nusing xbytechat.api.Features.MessageManagement.DTOs;\nusing xbytechat.api.Helpers;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class InboxService : IInboxService\n    {\n        private readonly IInboxRepository _repository;\n\n        public InboxService(IInboxRepository repository)\n        {\n            _repository = repository;\n        }\n\n        public async Task<List<MessageLog>> GetConversationAsync(Guid businessId, string userPhone, string contactPhone, int limit = 50)\n        {\n            return await _repository.GetConversationAsync(businessId, userPhone, contactPhone, limit);\n        }\n\n        public async Task<MessageLog> SaveIncomingMessageAsync(InboxMessageDto dto)\n        {\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n                IsIncoming = true,\n                CreatedAt = DateTime.UtcNow,\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n\n        public async Task<MessageLog> SaveOutgoingMessageAsync(InboxMessageDto dto)\n        {\n            var message = new MessageLog\n            {\n                Id = Guid.NewGuid(),\n                BusinessId = dto.BusinessId,\n                RecipientNumber = dto.RecipientPhone,\n                MessageContent = dto.MessageBody,\n                IsIncoming = false,\n                CreatedAt = DateTime.UtcNow,\n                ContactId = dto.ContactId,\n                CTAFlowStepId = dto.CTAFlowStepId,\n                CTAFlowConfigId = dto.CTAFlowConfigId,\n                CampaignId = dto.CampaignId,\n                RenderedBody = dto.RenderedBody\n            };\n\n            await _repository.AddMessageAsync(message);\n            await _repository.SaveChangesAsync();\n\n            return message;\n        }\n   \n        public async Task<List<MessageLogDto>> GetMessagesByContactAsync(Guid businessId, Guid contactId)\n        {\n            var messages = await _repository.GetMessagesByContactIdAsync(businessId, contactId);\n\n            return messages.Select(m => new MessageLogDto\n            {\n                Id = m.Id,\n                ContactId = m.ContactId,\n                RecipientNumber = m.RecipientNumber, // ✅ optional but helpful\n                MessageContent = m.MessageContent,\n                CreatedAt = m.CreatedAt,\n                IsIncoming = m.IsIncoming,\n                RenderedBody = m.RenderedBody,\n                CampaignId = m.CampaignId,\n                CampaignName = m.SourceCampaign?.Name, // ✅ ✅ This is crucial\n                CTAFlowConfigId = m.CTAFlowConfigId,\n                CTAFlowStepId = m.CTAFlowStepId\n            }).ToList();\n        }\n\n\n        public async Task<Dictionary<Guid, int>> GetUnreadMessageCountsAsync(Guid businessId)\n        {\n            return await _repository.GetUnreadMessageCountsAsync(businessId);\n        }\n        public async Task MarkMessagesAsReadAsync(Guid businessId, Guid contactId)\n        {\n            await _repository.MarkMessagesAsReadAsync(businessId, contactId);\n        }\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsForUserAsync(Guid businessId, Guid userId)\n        {\n            return await _repository.GetUnreadCountsForUserAsync(businessId, userId);\n        }\n\n\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IQuickReplyService.cs",
      "sha256": "531cc91cab752357d88cfa2483ab059e7a9ffdcfe4507a3105595cc17e33c1c0",
      "language": "csharp",
      "size": 816,
      "content": "using xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IQuickReplyService\n    {\n        Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true);\n\n        Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto);\n        Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto);\n        Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive);\n        Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/IUnreadCountService.cs",
      "sha256": "a7e51e22be544e5387038cd46027d2a58f968fbe1db1a3d792cde75ac9bfd4de",
      "language": "csharp",
      "size": 272,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Threading.Tasks;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public interface IUnreadCountService\n    {\n        Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId);\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/QuickReplyService.cs",
      "sha256": "594274585168680028dd399dbf8b94c4efa5438224541ec8ee1140c4a2482253",
      "language": "csharp",
      "size": 8104,
      "content": "using Microsoft.EntityFrameworkCore;\nusing Serilog;\nusing xbytechat.api.Features.Inbox.DTOs;\nusing xbytechat.api.Features.Inbox.Models;\nusing xbytechat.api.Helpers;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class QuickReplyService : IQuickReplyService\n    {\n        private readonly AppDbContext _db;\n\n        public QuickReplyService(AppDbContext db) => _db = db;\n\n        public async Task<List<QuickReplyDto>> GetAllAsync(Guid businessId, Guid userId,\n            string? search = null, bool includeBusiness = true, bool includePersonal = true)\n        {\n            var q = _db.Set<QuickReply>()\n                .AsNoTracking()\n                .Where(qr => qr.BusinessId == businessId && !qr.IsDeleted && qr.IsActive);\n\n            if (!includeBusiness) q = q.Where(x => x.Scope == QuickReplyScope.Personal);\n            if (!includePersonal) q = q.Where(x => x.Scope == QuickReplyScope.Business);\n            if (includePersonal && includeBusiness == false)\n                q = q.Where(x => x.OwnerUserId == userId || x.Scope == QuickReplyScope.Business);\n            else if (includePersonal)\n                q = q.Where(x => x.Scope == QuickReplyScope.Business || x.OwnerUserId == userId);\n\n            if (!string.IsNullOrWhiteSpace(search))\n            {\n                var s = search.Trim().ToLower();\n                q = q.Where(x =>\n                    x.Title.ToLower().Contains(s) ||\n                    x.Body.ToLower().Contains(s) ||\n                    (x.TagsCsv != null && x.TagsCsv.ToLower().Contains(s)));\n            }\n\n            return await q\n                .OrderByDescending(x => x.Scope)\n                .ThenBy(x => x.Title)\n                .Select(x => new QuickReplyDto\n                {\n                    Id = x.Id,\n                    BusinessId = x.BusinessId,\n                    OwnerUserId = x.OwnerUserId,\n                    Scope = x.Scope,\n                    Title = x.Title,\n                    Body = x.Body,\n                    TagsCsv = x.TagsCsv,\n                    Language = x.Language,\n                    IsActive = x.IsActive,\n                    UpdatedAt = x.UpdatedAt\n                }).ToListAsync();\n        }\n\n        public async Task<ResponseResult> CreateAsync(Guid businessId, Guid userId, string actor, QuickReplyCreateDto dto)\n        {\n            try\n            {\n                var entity = new QuickReply\n                {\n                    Id = Guid.NewGuid(),\n                    BusinessId = businessId,\n                    OwnerUserId = dto.Scope == QuickReplyScope.Personal ? userId : null,\n                    Scope = dto.Scope,\n                    Title = dto.Title.Trim(),\n                    Body = dto.Body,\n                    TagsCsv = dto.TagsCsv,\n                    Language = dto.Language,\n                    IsActive = true,\n                    CreatedAt = DateTime.UtcNow,\n                    UpdatedAt = DateTime.UtcNow,\n                    CreatedBy = actor,\n                    UpdatedBy = actor\n                };\n\n                _db.Add(entity);\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply created {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    entity.Id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"✅ Quick reply created.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error creating quick reply for business {BusinessId}\", businessId);\n                return ResponseResult.ErrorInfo(\"❌ Failed to create quick reply.\", ex.ToString()); // pattern like Campaign. :contentReference[oaicite:3]{index=3}\n            }\n        }\n\n        public async Task<ResponseResult> UpdateAsync(Guid businessId, Guid userId, string actor, Guid id, QuickReplyUpdateDto dto)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"❌ Quick reply not found.\");\n\n                // Only owner can edit personal; business-scope allowed for now\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"⛔ You cannot edit another user's personal quick reply.\");\n\n                entity.Title = dto.Title.Trim();\n                entity.Body = dto.Body;\n                entity.TagsCsv = dto.TagsCsv;\n                entity.Language = dto.Language;\n                entity.IsActive = dto.IsActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply updated {@QuickReplyId} for business {@BusinessId} by {@Actor}\",\n                    id, businessId, actor);\n\n                return ResponseResult.SuccessInfo(\"✅ Quick reply updated.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error updating quick reply {@QuickReplyId} for business {BusinessId}\", id, businessId);\n                return ResponseResult.ErrorInfo(\"❌ Failed to update quick reply.\", ex.ToString()); // campaign-style. :contentReference[oaicite:4]{index=4}\n            }\n        }\n\n        public async Task<ResponseResult> ToggleActiveAsync(Guid businessId, Guid userId, string actor, Guid id, bool isActive)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"❌ Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"⛔ You cannot modify another user's personal quick reply.\");\n\n                entity.IsActive = isActive;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply toggled {@QuickReplyId} -> {IsActive} by {@Actor}\",\n                    id, isActive, actor);\n\n                return ResponseResult.SuccessInfo(isActive ? \"✅ Enabled.\" : \"✅ Disabled.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error toggling quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"❌ Failed to toggle quick reply.\", ex.ToString());\n            }\n        }\n\n        public async Task<ResponseResult> DeleteAsync(Guid businessId, Guid userId, string actor, Guid id)\n        {\n            try\n            {\n                var entity = await _db.Set<QuickReply>()\n                    .FirstOrDefaultAsync(x => x.Id == id && x.BusinessId == businessId && !x.IsDeleted);\n\n                if (entity == null)\n                    return ResponseResult.ErrorInfo(\"❌ Quick reply not found.\");\n\n                if (entity.Scope == QuickReplyScope.Personal && entity.OwnerUserId != userId)\n                    return ResponseResult.ErrorInfo(\"⛔ You cannot delete another user's personal quick reply.\");\n\n                entity.IsDeleted = true;\n                entity.IsActive = false;\n                entity.UpdatedAt = DateTime.UtcNow;\n                entity.UpdatedBy = actor;\n\n                await _db.SaveChangesAsync();\n\n                Log.Information(\"QuickReply soft-deleted {@QuickReplyId} by {@Actor}\", id, actor);\n                return ResponseResult.SuccessInfo(\"🗑️ Deleted.\");\n            }\n            catch (Exception ex)\n            {\n                Log.Error(ex, \"Error deleting quick reply {@QuickReplyId}\", id);\n                return ResponseResult.ErrorInfo(\"❌ Failed to delete quick reply.\", ex.ToString());\n            }\n        }\n    }\n}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/Services/UnreadCountService.cs",
      "sha256": "61cccb822d2bb8ea2545681af2caec74ed43ae1710eb3125f22dddf56ce4d7e9",
      "language": "csharp",
      "size": 3014,
      "content": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Threading.Tasks;\nusing Microsoft.EntityFrameworkCore;\nusing xbytechat.api.Shared;\n\nnamespace xbytechat.api.Features.Inbox.Services\n{\n    public class UnreadCountService : IUnreadCountService\n    {\n        private readonly AppDbContext _db;\n\n        public UnreadCountService(AppDbContext db)\n        {\n            _db = db;\n        }\n\n        public async Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId)\n        {\n            if (businessId == Guid.Empty || userId == Guid.Empty)\n                return new Dictionary<Guid, int>();\n\n            var userReads = _db.ContactReads.AsNoTracking()\n                .Where(r => r.BusinessId == businessId && r.UserId == userId);\n\n            var query = _db.MessageLogs.AsNoTracking()\n                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n                .GroupJoin(\n                    userReads,\n                    m => m.ContactId,\n                    r => r.ContactId,\n                    (m, rj) => new { m, rj }\n                )\n                .SelectMany(x => x.rj.DefaultIfEmpty(), (x, r) => new { x.m, r })\n                .Where(x => x.r == null || (x.m.SentAt ?? x.m.CreatedAt) > x.r.LastReadAt)\n                .GroupBy(x => x.m.ContactId!.Value)\n                .Select(g => new { ContactId = g.Key, Count = g.Count() });\n\n            return await query.ToDictionaryAsync(x => x.ContactId, x => x.Count);\n        }\n    }\n}\n\n\n//using Microsoft.EntityFrameworkCore;\n//using xbytechat.api.Shared;\n//using xbytechat.api.Models;\n\n//namespace xbytechat.api.Features.Inbox.Services\n//{\n//    public class UnreadCountService : IUnreadCountService\n//    {\n//        private readonly AppDbContext _db;\n\n//        public UnreadCountService(AppDbContext db)\n//        {\n//            _db = db;\n//        }\n\n//        public async Task<Dictionary<Guid, int>> GetUnreadCountsAsync(Guid businessId, Guid userId)\n//        {\n//            // ✅ Load all incoming messages for the business\n//            var allMessages = await _db.MessageLogs\n//                .Where(m => m.BusinessId == businessId && m.IsIncoming && m.ContactId != null)\n//                .ToListAsync();\n\n//            // ✅ Load last read times for this user\n//            var contactReads = await _db.ContactReads\n//                .Where(r => r.UserId == userId && r.BusinessId == businessId)\n//                .ToDictionaryAsync(r => r.ContactId, r => r.LastReadAt);\n\n//            // ✅ Compute unread counts in-memory\n//            var unreadCounts = allMessages\n//                .GroupBy(m => m.ContactId!.Value)\n//                .ToDictionary(\n//                    g => g.Key,\n//                    g => g.Count(m =>\n//                        !contactReads.ContainsKey(g.Key) ||\n//                        (m.SentAt ?? m.CreatedAt) > contactReads[g.Key])\n//                );\n\n//            return unreadCounts;\n//        }\n//    }\n//}\n"
    },
    {
      "path": "xbytechat-api/Features/Inbox/SignalR/NameUserIdProvider.cs",
      "sha256": "177581fc6482f75de65f8a7db7a93d17a7d887e148d35eb77ca640d9df0e311f",
      "language": "csharp",
      "size": 336,
      "content": "using Microsoft.AspNetCore.SignalR;\nusing System.Security.Claims;\n\nnamespace xbytechat.api.SignalR\n{\n    public class NameUserIdProvider : IUserIdProvider\n    {\n        public string? GetUserId(HubConnectionContext connection)\n        {\n            return connection.User?.FindFirst(ClaimTypes.NameIdentifier)?.Value;\n        }\n    }\n}\n"
    }
  ]
}
